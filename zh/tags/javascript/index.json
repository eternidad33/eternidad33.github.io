[{"content":" 本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。\n 数据结构 具有八个结点的二叉树共有多少种（）？\n正确答案: D 你的答案: D\rA、8\rB、256\rC、960\rD、1430\r链接：https://www.nowcoder.com/questionTerminal/c0f432a4d4be460793018defccd1f630\n分析过程： （1）先考虑只有一个节点的情形，设此时的形态有f(1)种，那么很明显f(1)=1\n（2）如果有两个节点呢？我们很自然想到，应该在f(1)的基础上考虑递推关系。那么，如果固定一个节点后，左右子树的分布情况为1=1+0=0+1，故有f(2) = f(1) + f(1)\n（3）如果有三个节点，（我们需要考虑固定两个节点的情况么？当然不，因为当节点数量大于等于2时，无论你如何固定，其形态必然有多种）我们考虑固定一个节点，即根节点。好的，按照这个思路，还剩2个节点，那么左右子树的分布情况为2=2+0=1+1=0+2。 所以有3个节点时，递归形式为f(3)=f(2) + f(1)*f(1) + f(2)。注意这里的乘法，因为左右子树一起组成整棵树，根据排列组合里面的乘法原理即可得出)\n（4）那么有n个节点呢？我们固定一个节点，那么左右子树的分布情况为n-1=n-1 + 0 = n-2 + 1 = … = 1 + n-2 = 0+n-1。此时递归表达式为f(n) = f(n-1) + f(n-2)f(1) + f(n-3)f(2) + … + f(1)f(n-2) + f(n-1)\n接下来我们定义没有节点的情况，此时也只有一种情况，即f(0)=1，那么则有: f(0)=1，f(1)=1 f(2)=f(1)f(0)+f(0)f(1) f(3)=f(2)f(0)+f(1)f(1)+f(0)f(2) . . . . f(n)=f(n-1)f(0)+f(n-2)f(1)+……….+f(1)f(n-2)+f(0)f(n-1) 该数列称为卡特兰数（Catalan数），该递推关系的解为： 即含n个节点的二叉树有f(n)种形态。\n两人在一个n个点的无向完全图上进行游戏，每次可以选择当前图中两个端点度数奇偶性相同的边删除，谁不能操作谁输，则在n=1,2,3,\u0026hellip;\u0026hellip;,9,10中，有（）个图先手有必胜策略。\n正确答案: D 你的答案: D\rA、2\rB、3\rC、4\rD、5\rE、6\rF、7\r链接：https://www.nowcoder.com/questionTerminal/5365a6a013e0421f8af9fff72aa1734d\nN个点的无向完全图边数为：N*（N-1）/2；先手获胜必须总数为奇数；\nN=1,2,3,\u0026hellip;\u0026hellip;,9,10代入公式，为奇数的只有N=2,3,6,7,10这5个。\n对n个记录的文件进行快速排序，所需要的辅助存储空间大致为\n正确答案: C 你的答案: C\rA、O（1）\rB、O（n）\rC、O（1og2n）\rD、O（n2）\r链接：https://www.nowcoder.com/questionTerminal/d4d3b9e4c5974aae869ce1fd61fd8c8a\n辅助存储空间 = 时间复杂度 额外存储空间 = 空间复杂度\n快速排序对待排序序列得划分大约是log2n次，因为快速排序是通过递归算法来实现的，递归深度大约是log2n，所以所需得辅助空间为log2n\n基于比较的排序算法是（ ）\n正确答案: B D 你的答案: B D\rA、基数排序\rB、冒泡排序\rC、桶排序\rD、希尔排序\r链接：https://www.nowcoder.com/questionTerminal/5a7581e365d94db0966ab808ce304928\n1、基于比较的排序算法有：（1）直接插入排序；（2）冒泡排序；（3）简单选择排序；（4）希尔排序；（5）快速排序；（6）堆排序；（7）归并排序。\n2、基数排序、桶排序都属于分配式排序，且都是稳定排序算法。\n待排序元素规模较小时，宜选取哪种排序算法效率最高（ ）\n正确答案: C 你的答案: C\rA、堆排序\rB、归并排序\rC、冒泡排序\rD、希尔排序\r链接：https://www.nowcoder.com/questionTerminal/a95f7e2431174ed69422df4b5354113a\n笔记：递归时间可能长于比较时间\n下面有关P问题，NP问题和NPC问题，说法错误的是\n正确答案: D 你的答案: D\rA、如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题\rB、NP问题是指可以在多项式的时间里验证一个解的问题\rC、所有的P类问题都是NP问题\rD、NPC问题不一定是个NP问题，只要保证所有的NP问题都可以约化到它即可\r链接：https://www.nowcoder.com/questionTerminal/8b52ba2d570545fdae8ee1f7cb264ec1\nP: 能在多项式时间内解决的问题\nNP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题\nNPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。\nNP hard:NP难问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。\nint main(){fork()||fork();}共创建几个进程：\n正确答案: C 你的答案: C\rA、1\rB、2\rC、3\rD、4\rE、5\rF、6\r链接：https://www.nowcoder.com/questionTerminal/b8321978323c43c694a561d151e69fd0\nfork()给子进程返回一个零值，而给父进程返回一个非零值；\n在main这个主进程中，首先执行 fork()|| fork(), 左边的fork()返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程，由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中，fork()||fork()这条语句左边表达式的返回值是0, 所以||右边的表达式要执行，这时在子进程中又创建了一个进程，即main进程-\u0026gt;子进程-\u0026gt;子进程，一共创建了3个进程。\n操作系统 以下哪个命令用于查看tar（backup.tar）文件的内容而不提取它?（）\n正确答案: B 你的答案: B\rA、tar -xvf backup.tar\rB、tar -tvf backup.tar\rC、tar -svf backup.tar\rD、none of these\r链接：https://www.nowcoder.com/questionTerminal/4e632ee9fb3c45e2bad336236b5ef3a9\nlinux中tar命令用法\n把常用的tar解压命令总结下，当作备忘：\ntar\n-c: 建立压缩档案\n-x：解压\n-t：查看内容\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。\n-z：有gzip属性的\n-j：有bz2属性的\n-Z：有compress属性的\n-v：显示所有过程\n-O：将文件解开到标准输出\n压缩\n  tar –cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg zip格式的压缩，需要先下载zip for linux\n  解压\n tar –xvf file.tar 解压 tar包 tar -xzvf file.tar.gz 解压tar.gz tar -xjvf file.tar.bz2 解压 tar.bz2 tar –xZvf file.tar.Z 解压tar.Z unrar e file.rar 解压rar unzip file.zip 解压zip  总结\n *.tar 用 tar –xvf 解压 *.gz 用 gzip -d或者gunzip 解压 *.tar.gz和*.tgz 用 tar –xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar –xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar –xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压  在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是（）。\n正确答案: D 你的答案: D\rA、无上邻空闲区，也无下邻空闲区\rB、有上邻空闲区，但无下邻空闲区\rC、有下邻空闲区，但无上邻空闲区\rD、有上邻空闲区，也有下邻空闲区\r 链接：https://www.nowcoder.com/questionTerminal/ef0dbdf2f0ff4e609c7bce9265125357\n可变分区分配方式下，当收回主存时，应检查是否有与归还区相邻的空闲区，若有，则应合并成一个空闲区。相邻可能有上邻空闲区、下邻空闲区、既上邻又下邻空闲区、既无上邻又无下邻空闲区。\n若有上邻空闲区，只修改上邻空闲区长度（为收回的空闲区长度与原上邻区长度之和）即可；\n若有下邻空闲区，改记录这个下邻空闲区记录的地址为收回空闲区的地址，长度为下邻空闲区的长度和收回空闲区的长度即可；\n若既有上邻又有下邻空闲区，改记录上邻区记录的长度（为上邻区长度、下邻区长度和收回区长度之和），再把下邻区记录的标志位改为空即可；\n若既无上邻区又无下邻区，那么找一个标志位为空的记录，记下该回收区的起始地址和长度，且改写相应的标志位为未分配，表明该登记栏中指示了一个空闲区。\n 下列说法中，错误的是（）\n正确答案: D 你的答案: D\rA、指令就是命令，它用来规定CPU执行什么操作\rB、指令是构成程序的基本单位，程序是由一连串指令组成的\rC、指令采用二进位表示\rD、指令一般由4个部分组成\r 链接：https://www.nowcoder.com/questionTerminal/35ad5448a793489d90d197823c879195\n指令一般由两部分组成：\n操作码：该指令完成操作的类型或性质 地址码：操作对象的地址\n 有作业控制块JCB连成一串而形成的排队队列称为（）。\n正确答案: D 你的答案: D\rA、挂起队列\rB、阻塞队列\rC、就绪队列\rD、后备队列\r链接：https://www.nowcoder.com/questionTerminal/489c515483794a789dc303aee0e6ebc8\n高级调度：从后备作业队列（作业控制块）中将作业调入进就绪进程队列，所以作业控制块中存放的是后背作业队列。\n中级调度：是为了提高内存的使用率，将一些暂时不能运行的进程从内存移动到外存上去，即内存外出不断交换，所以中级调度会涉及到虚拟存储器。暂时不能运行的进程，由就绪挂起队列，阻塞挂起队列。而阻塞队列里的进程会由于等待时间过长自动调入到阻塞挂起队列里面去。\n低级调度（短程调度）分两类，非抢占式调度和抢占式调度，从就绪进程队列中选取合适进程送到CPU上运行。\n死锁的预防方法中，不太可能的一种方法是（ ）。\n正确答案: A 你的答案: A\rA、摒弃互斥条件\rB、摒弃请求和保持条件\rC、摒弃不剥夺条件\rD、摒弃环路等待条件\r链接：https://www.nowcoder.com/questionTerminal/93cf7ebf8e074a7c9f0a36254391afd4\n  互斥条件：一个资源每次只能被一个进程使用。不可破坏\n  请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。一次性分配：要么全给，要么啥也不给。\n  不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 设置优先级，高优先级可要求低优先级让出资源。\n  循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。对资源进行编号，按照编号顺序申请访问\n  下列性质中，哪一个不是分时系统的特征（）。\n正确答案: C 你的答案: C\rA、交互性\rB、多路性\rC、成批性\rD、独占性\r链接：https://www.nowcoder.com/questionTerminal/19cba64765944273a5d8938e165e26b0\n分时系统具有多路性、交互性、独占性和及时性的特征。\n多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。\n交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。\n独占性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。\n及时性指，系统对用户提出的请求及时响应。\n实时操作系统基本特征：及时性，可靠性\n下面哪个不是进程和程序的区别()\n正确答案: B 你的答案: B\rA、程序是一组有序的静态指令，进程是一次程序的执行过程\rB、程序只能在前台运行，而进程可以在前台或后台运行\rC、程序可以长期保存，进程是暂时的\rD、程序没有状态，而进程是有有状态的\r链接：https://www.nowcoder.com/questionTerminal/a7eb18af3b4d47c2b0642726497442b1\nA：程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。\nB：一般情况下，后台程序也叫任务级程序，前台程序也叫事件处理级程序。\nC：程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。\nD：程序没有状态，而进程是有有状态的，进程状态分为五个基本状态，即初始状态，就绪状态，执行状态，等待状态与终止状态。\n关于总线的说法中正确的是( )\n正确答案: A 你的答案: A\rA、总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路\rB、I/O总线是用于连接CPU和内存的总线\rC、CPU总线是连接内存和I/O设备（包括外存）的总线\rD、计算机总线中只包含CPU总线\r链接：https://www.nowcoder.com/questionTerminal/15f2927d582a48c4b1677d7b9e0342ea\n总线按功能和规范可分为五大类型:\n 数据总线(Data Bus):在CPU与RAM之间来回传送需要处理或是需要储存的数据。 地址总线(Address Bus):用来指定在RAM(Random Access Memory)之中储存的数据的地址。 控制总线(Control Bus):将微处理器控制单元(Control Unit)的信号，传送到周边设备，一般常见的为USB Bus和1394 Bus。 扩展总线(Expansion Bus):可连接扩展槽和电脑。 局部总线(Local Bus):取代更高速数据传输的扩展总线。  数据库 在mysql中，以下哪种方式可以开启一个事务？\n正确答案: A C 你的答案: A C\rA、START TRANSACTION\rB、START\rC、BEGIN\rD、BEIGN TRANSACTION\r链接：https://www.nowcoder.com/questionTerminal/018e6413d33f403384f0a4aa980f6bf5\n BEGIN或START TRANSACTION；显示地开启一个事务 COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的 ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改 SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常 ROLLBACK TO identifier；把事务回滚到标记点 SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。  下列四项中，不属于数据库系统的主要特点的是（ ）。\n正确答案: D 你的答案: D\rA、数据结构化\rB、数据的冗余度小\rC、较高的数据独立性\rD、程序的标准化\r 链接：https://www.nowcoder.com/questionTerminal/800eecdc01a240228910fb48f42087a6\n数据库系统的特点 数据结构化 数据共享性高,冗余度低,易扩充 数据独立性高\n 下面有关sql 语句中 delete truncate的说法正确的是？（）\n正确答案: A C 你的答案: A C\rA、论清理表数据的速度，truncate一般比delete更快\rB、truncate命令可以用来删除部分数据。\rC、truncate只删除表的数据不删除表的结构\rD、delete能够回收高水位\r链接：https://www.nowcoder.com/questionTerminal/f3053b1c256e471b99a2a7da445a6d47\n 处理效率：drop\u0026gt;trustcate\u0026gt;delete drop删除整个表；trustcate删除全部记录，但不删除表；delete删除部分记录 delete不影响所用extent，高水线保持原位置不动；trustcate会将高水线复位。  计算机网络 现有一完全的P2P共享协议，每次两个节点通讯后都能获取对方已经获取的全部信息，现在使得系统中每个节点都知道所有节点的文件信息，共17个节点，假设只能通过多次两个对等节点之间通讯的方式，则最少需要（）次通讯\n正确答案: C 你的答案: C\rA、32\rB、31\rC、30\rD、29\r链接：https://www.nowcoder.com/questionTerminal/21efe6541da84d13af68fcf9d658ea93\n如上图1所示，假设有5个节点，按连线1、2、3、4通讯之后，节点4和5就掌握了所有节点的信息，之后，1、2、3节点只需跟4或5任一节点通讯一次即连线5、6、7就可保证每个节点都知道所有节点的信息，总的通讯次数是(n-1)+(n-2)=2n-3次。\n如果将所有节点分成两组，如图2所示，两组中的节点分别按连线1-8顺序通讯之后，节点4和5就掌握了1-5所有节点的信息，节点9和0就掌握了6-0所有节点的信息，再按连线9、10通讯之后，节点4、5、9、0就掌握了1-0所有节点的信息，剩下的节点只需跟4、5、9、0任一节点通讯一次就可保证每个节点知道所有节点信息，和图1相比，多了9和10两次通讯，总的通讯次数是(2n1-3)+(2n2-3)+2=2n-4次(n1和n2分别表示分组中元素个数)。\n分3组的情况是(2n1-3)+(2n2-3)+(2n3-3)+6=2n-3次\n分4组的情况是(2n1-3)+(2n2-3)+(2n3-3)+(2n4-3)+8=2n-4次\n下面对http状态码描述正确的是？（）\n正确答案: A D 你的答案: A D\rA、1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\rB、3**：表示服务端无法响应\rC、4**：表示服务端错误\rD、5**：表示服务器端错误\r链接：https://www.nowcoder.com/questionTerminal/a8e19032005f470f96e1f6c0dde1f1e4\n1XX（信息状态码）接受请求正在处理\n2XX（成功状态码） 请求正常处理完毕\n3XX（重定向状态码） 需要附加操作已完成请求\n4XX（客户端错误状态码） 服务器无法处理请求\n5XX（服务器错误状态码） 服务器处理请求出错\nRPC、SQL、NFS属于OSI的哪一层？\n正确答案: C 你的答案: C\rA、应用层\rB、表示层\rC、会话层\rD、传输层\r 链接：https://www.nowcoder.com/questionTerminal/7cf6990ea2e345b6bc96d882944c4d6b\n第一层：物理层\n第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY 第三层：网络层 IP、IPX、APPLETALK、ICMP 第四层：传输层 TCP、UDP、SPX 第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP\n第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG 第七层：应用层 HTTP、FTP、SNMP等\n Java 下列代码输出结果为（）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Animal{\rpublic void move(){\rSystem.out.println(\u0026#34;动物可以移动\u0026#34;);\r}\r}\rclass Dog extends Animal{\rpublic void move(){\rSystem.out.println(\u0026#34;狗可以跑和走\u0026#34;);\r}\rpublic void bark(){\rSystem.out.println(\u0026#34;狗可以吠叫\u0026#34;);\r}\r}\rpublic class TestDog{\rpublic static void main(String args[]){\rAnimal a = new Animal();\rAnimal b = new Dog(); a.move();\rb.move();\rb.bark();\r}\r}\r正确答案: D 你的答案: D\rA、 动物可以移动\r狗可以跑和走\r狗可以吠叫\rB、 动物可以移动\r动物可以移动\r狗可以吠叫\rC、 运行错误\rD、 编译错误\r  链接：https://www.nowcoder.com/questionTerminal/8b7e3edf00d646afb15319c31206ad31\n编译看左边，运行看右边。 父类型引用指向子类型对象，无法调用只在子类型里定义的方法\n下面关于垃圾收集的说法正确的是\n正确答案: D 你的答案: D\rA、一旦一个对象成为垃圾，就立刻被收集掉。\rB、对象空间被收集掉之后，会执行该对象的finalize方法\rC、finalize方法和C++的析构函数是完全一回事情\rD、一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此\r链接：https://www.nowcoder.com/questionTerminal/c6586555a3774654a663c3141688aba5\n 以前我是堆，你是栈\n你总是能精准的找到我，给我指明出路\n后来有一天我明白了\n我变成了栈，你却隐身堆海\n我却找不到你了，空指针了\n我不愿意如此，在下一轮full gc前\n我找到了object家的finalize\n又找到了你，这次我不会放手\n在世界重启前，一边躲着full gc一边老去\n 1、在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行。\n2、一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法， 并且在下一次垃圾回收动作发生时，才会真正的回收对象占用的内存（《java 编程思想》）\n3、在C++中，对象的内存在哪个时刻被回收，是可以确定的，在C++中，析构函数和资源的释放息息相关，能不能正确处理析构函数，关乎能否正确回收对象内存资源。\n**在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行，**在java中，所有的对象，包括对象中包含的其他对象，它们所占的内存的回收都依靠垃圾回收器，因此不需要一个函数如C++析构函数那样来做必要的垃圾回收工作。当然存在本地方法时需要finalize()方法来清理本地对象。在《java编程思想》中提及，finalize()方法的一个作用是用来回收“本地方法”中的本地对象\n4、“但是线程并非如此”不理解，希望大佬补充\n下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：\n1 2 3 4 5 6 7 8  byte[] src,dst;\r正确答案: B 你的答案: B\rA、dst=String.fromBytes(src，\u0026#34;GBK\u0026#34;).getBytes(\u0026#34;UTF-8\u0026#34;)\rB、dst=new String(src，\u0026#34;GBK\u0026#34;).getBytes(\u0026#34;UTF-8\u0026#34;)\rC、dst=new String(\u0026#34;GBK\u0026#34;，src).getBytes()\rD、dst=String.encode(String.decode(src，\u0026#34;GBK\u0026#34;))，\u0026#34;UTF-8\u0026#34; )\r   链接：https://www.nowcoder.com/questionTerminal/093bfa948d144ce3b0a68b938ae8b4ec\n选B，先通过GBK编码还原字符串，在该字符串正确的基础上得到“UTF-8”所对应的字节串。\n socket编程中，以下哪个socket的操作是不属于服务端操作的（）？\n正确答案: C 你的答案: C\rA、accept\rB、listen\rC、connect\rD、close\r链接：https://www.nowcoder.com/questionTerminal/38fb0886232b42b6a542c288d256eee1\nTCP客户端：\n 建立连接套接字，设置Ip和端口监听，socket() 建立连接 connect write() 获取网络流对象 发送数据 read()获取网络流对象 接收数据 关闭套接字  TCP服务器端\n 建立端口监听 socket() 绑定指定端口 bind() listen 进行端口监听 accept() 阻塞式 直到有客户端访问 read()获取客户端发送数据 write()发送返回数据 close关闭端口监听  下面关于volatile的功能说法正确的是哪个\n正确答案: B C 你的答案: B C\rA、原子性\rB、有序性\rC、可见性\rD、持久性\r 链接：https://www.nowcoder.com/questionTerminal/81888b413fae42348429b845242c4edd\nsynchronized保证三大性，原子性，有序性，可见性，volatile保证有序性，可见性，不能保证原子性\n volatile到底做了什么:\n  禁止了指令重排\n  保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的\n  不保证原子性（线程不安全）\n  synchronized关键字和volatile关键字比较：\n volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性  以下哪些jvm的垃圾回收方式采用的是复制算法回收\n正确答案: A D 你的答案: A D\rA、新生代串行收集器\rB、老年代串行收集器\rC、并行收集器\rD、新生代并行回收收集器\rE、老年代并行回收收集器\rF、cms收集器\r链接：https://www.nowcoder.com/questionTerminal/795b066b67c84478aec4dc400b3d0153\n两个最基本的java回收算法：复制算法和标记清理算法\n复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法\n标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出\n标记整理算法：多了碎片整理，整理出更大的内存放更大的对象\n两个概念：新生代和老年代\n新生代：初始对象，生命周期短的\n老年代：长时间存在的对象\n整个java的垃圾回收是新生代和老年代的协作，这种叫做分代回收。\n Serial New收集器是针对新生代的收集器，采用的是复制算法\nParallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理\nParallel Scavenge（并行）收集器，针对新生代，采用复制收集算法\nSerial Old（串行）收集器，新生代采用复制，老年代采用标记整理\nParallel Old（并行）收集器，针对老年代，标记整理\nCMS收集器，基于标记清理\nG1收集器：整体上是基于标记 整理 ，局部采用复制\n综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。\n 假如某个JAVA进程的JVM参数配置如下：-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3 请问eden区最终分配的大小是多少？\n正确答案: C 你的答案: C\rA、64M\rB、500M\rC、300M\rD、100M\r链接：https://www.nowcoder.com/questionTerminal/d712bfe6954140958c953adcb6bf04d1\nXms 起始内存\nXmx 最大内存\nXmn 新生代内存\nXss 栈大小。 就是创建线程后，分配给每一个线程的内存大小\n-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-XX:MaxPermSize=n:设置持久代大小\n收集器设置\n-XX:+UseSerialGC:设置串行收集器\n-XX:+UseParallelGC:设置并行收集器\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n-XX:+UseConcMarkSweepGC:设置并发收集器\n垃圾回收统计信息\n-XX:+PrintGC\n-XX:+PrintGCDetails\n-XX:+PrintGCTimeStamps\n-Xloggc:filename\n并行收集器设置\n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。\n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间\n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n并发收集器设置\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以( )\n正确答案: A 你的答案: A\rA、让该类不使用任何关键字\rB、使用private关键字\rC、使用protected关键字\rD、使用void关键字\r 链接：https://www.nowcoder.com/questionTerminal/fe708884a2074763b6d5d1dd62a52817\ndefault和protected的区别是： 前者只要是外部包，就不允许访问。 后者只要是子类就允许访问，即使子类位于外部包。\n总结：default拒绝一切包外访问；protected接受包外的子类访问\n 不能用来修饰interface的有（ ）（仅限外部接口）\n正确答案: A C D 你的答案: A C D\rA、private\rB、public\rC、protected\rD、static\r​ 1、抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。原因如下：抽象方法没有方法体，是用来被继承的，所以不能用private修饰；static修饰的方法可以通过类名来访问该方法（即该方法的方法体），抽象方法用static修饰没有意义；使用synchronized关键字是为该方法加一个锁。。而如果该关键字修饰的方法是static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象，因为该方法不是在该抽象类中实现的。是在其子类实现的。所以。锁应该归其子类所有。所以。抽象方法也就不能用synchronized关键字修饰了；native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个吧方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢？\n2、接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用。而且protected访问修饰符也不能使用，因为接口可以让所有的类去实现（非继承），不只是其子类，但是要用public去修饰。接口可以去继承一个已有的接口。\n题考察修饰符，函数定义等，故从网上搜罗了下相关资料，总结如下：\n类、方法、成员变量和局部变量的可用修饰符\n   修饰符 类 成员访求 构造方法 成员变量 局部变量     abstract（抽象的） √ √      static （静态的）  √  √    public（公共的） √ √ √ √    protected（受保护的）  √ √ √    private（私有的）  √ √ √    synchronized（同步的）  √      native（本地的）  √      transient（暂时的）    √    volatie（易失的）    √    final（不要改变的） √ √  √ √       类 修饰符      Public 可以从其他类中访问   Abstract 本类不能被实例化   Final 不能再声明子类   构造函数修饰符    Public 可以从所有的类中访问   Protected 只能从自己的类和它的子类中访问   Private 只能在本类中访问   域/成员变量修饰符    Public 可以从所有的类中访问   Protected 只能从本类和它的子类中访问   Private 只能从本类中访问它   Static 对该类的所有实例只能有一个域值存在   transient 不是一个对象持久状态的一部份   Volatile 可以被异步的线程所修改   final 必须对它赋予初值并且不能修改它   局部变量 修饰符    final 必须对它赋予初值并且不能修改它   方法修饰符    Public 可以从所有的类中访问它   Protected 只能从本类及其子类中访问它   Private 只能从本类中访问它   abstract 没有方法体，属于一个抽象类   final 子类不能覆盖它   static 被绑定于类本身而不是类的实例   native 该方法由其他编程语言实现   asnchronized 在一个线程调用它之前必须先给它加    类的修饰符整合\n一．类\n类的修饰符：\nPublic:可以在其他任何类中使用，默认为统一包下的任意类。\nAbstract:抽象类，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。\nFinal:不能被继承。\n二．变量\n变量修饰符：\n一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是局部变量。\n  可访问修饰符：\n  static：类变量：一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。\n  final：常量。\n  volatile：声明一个可能同时被并存运行的几个线程所控制和修改的变量。\n  实例变量：和类变量对应，即每个对象都拥有各自独立的实例变量。\n三．方法：（和变量对象分为实例方法和类方法，并用有无static修饰区别）\n类方法：使用static关键字说明的方法\n  第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。\n  类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例来调用，当然也可以通过对象来调用。\n  实例方法：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。\n方法可以重载，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）\n方法的返回类型：若无返回类型，则声明为void.\n方法中的变量作用域：\n  成员变量：整个类。\n  局部变量：定义起到方法块结束为止。\n  方法参数：整个方法或者构造方法。\n  异常处理参数：参数传递给异常处理方法。\n  构造方法：和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。\n静态初始化器：格式：static{\u0026lt;赋值语句组\u0026gt;}\n静态初始化器与构造方法的区别：\n   静态初始化器 构造方法     对类的静态域初始化 对新建的对象初始化   类进入内存后，系统调用执行 执行new后自动执行   属特殊语句（仅执行一次） 属特殊方法    方法的修饰符：\n**抽象方法：**用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。\n**类方法：**静态方法，用static修饰，\n  调用时，使用类名作为前缀，而不是类的某个实例对象名\n  不能被单独对象拥有，属于整个类共享\n  不能处理成员变量\n  最终方法：用final修饰，不能被子类重新定义的方法。\n本地方法：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。\n四．类成员的访问控制符：\n即类的方法和成员变量的访问控制符，一个类作为整体对象不可见，并不代表他的所有域和方法也对程序其他部分不可见，需要有他们的访问修饰符判断。\n权限如下：\n   访问修饰符 同一个类 同包 不同包，子类 不同包，非子类     private √      protected √ √ √    public √ √ √ √   默认 √ √      jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些\n正确答案: C D E 你的答案: C D E\rA、栈空间满\rB、年轻代空间满\rC、老年代满\rD、持久代满\rE、System.gc()\r链接：https://www.nowcoder.com/questionTerminal/6e9fadc9f3234551bd92d6331a14607d\n垃圾收集机制：新生代、老年代、持久代  新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。 老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。 持久代：持久代如果满了，将触发Full GC。  下面有关SPRING的事务传播特性，说法错误的是？\n正确答案: B 你的答案: B\rA、PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行\rB、PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常\rC、PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起\rD、PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚\r链接：https://www.nowcoder.com/questionTerminal/1c65d30e47fb4f59a5e5af728218cac4\n事务属性的种类：传播行为、隔离级别、只读和事务超时\na)传播行为定义了被调用方法的事务边界。\n   传播行为 意义     PROPERGATION_MANDATORY 表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常   PROPAGATION_NESTED 表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED 看起来没什么俩样   PROPAGATION_NEVER 表示方法不能运行在一个事务中，否则抛出异常   PROPAGATION_NOT_SUPPORTED 表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起   PROPAGATION_REQUIRED 表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务   PROPAGATION_REQUIRES_NEW 表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起   PROPAGATION_SUPPORTS 表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中    b)隔离级别\n在操作数据时可能带来3个副作用，分别是脏读、不可重复读、幻读。为了避免这3种副作用的发生，在标准的SQL语句中定义了4种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。而在spring事务中提供了5种隔离级别来对应在SQL中定义的4种隔离级别，如下：\n   隔离级别 意义     ISOLATION_DEFAULT 使用后端数据库默认的隔离级别   ISOLATION_READ_UNCOMMITTED 允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读   ISOLATION_READ_COMMITTED 允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读   ISOLATION_REPEATABLE_READ 一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读   ISOLATION_SERIALIZABLE 这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。    c)只读\n如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（READ_ONLY_MARKER）,这样更有利于数据库进行优化。\n因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为(PROPAGATION_NESTED、PROPAGATION_REQUIRED、PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。\n如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。\nd)事务超时\n如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。\n关于java集合下列说法不正确的有哪些（）\n正确答案: A B D 你的答案: A B D\rA、HashSet 它是线程安全的，不允许存储相同的对象\rB、ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复\rC、Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用\rD、ArrayList线程安全的，允许存放重复对象\r链接：https://www.nowcoder.com/questionTerminal/3dbb60125c2b47918b03ecb112b9c2cb\n线程安全(Thread-safe)的集合对象：\n Vector HashTable StringBuffer  非线程安全的集合对象：\n ArrayList LinkedList HashMap HashSet TreeMap TreeSet StringBulider  若有定义语句： int a=10 ; double b=3.14 ; 则表达式 \u0026lsquo;A'+a+b 值的类型是（）\n正确答案: C 你的答案: C\rA、char\rB、int\rC、double\rD、float\r 链接：https://www.nowcoder.com/questionTerminal/460e40f8824244efaf73ae088724f5f3\nchar \u0026lt; short \u0026lt; int \u0026lt; float \u0026lt; double 不同类型运算结果类型向右边靠齐。\n 检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package algorithms.com.guan.javajicu; public class Example { String str = new String(\u0026#34;good\u0026#34;); char[] ch = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}; public static void main(String[] args) { Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str +\u0026#34;and\u0026#34;); System.out.print(ex.ch); } public void change(String str, char ch[]){ str= \u0026#34;test ok\u0026#34;; ch[0]= \u0026#39;g\u0026#39;; } } 正确答案: D 你的答案: D\rA、test okandabc\rB、test okandgbc\rC、goodandabc\rD、goodandgbc\r  链接：https://www.nowcoder.com/questionTerminal/f7e3d10c71ef4d5ea435a1322d2ccfdf\njava 中String是 immutable的，也就是不可变，一旦初始化，其引用指向的内容是不可变的。\n也就是说，String str = “aa”；str=“bb”；第二句不是改变“aa”所存储地址的内容，而是另外开辟了一个空间用来存储“bb”；同时由str指向原来的“aa”，现在已经不可达，GC时会自动回收。\n因此String作为参数传进来时候，str= \u0026ldquo;test ok\u0026rdquo;; 实际给副本引用str指向了新分配的地址，该地址存储“test ok”。\n因此，原先的str仍然指向“good”\nJVM内存不包含如下哪个部分( )\n正确答案: D 你的答案: D\rA、Stacks\rB、PC寄存器\rC、Heap\rD、Heap Frame\r链接：https://www.nowcoder.com/questionTerminal/04c442aaf1e14bf9819075cc1f29d899\nJVM内存五大区域\n关于下列程序段的输出结果，说法正确的是：（ ）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class MyClass{\rstatic int i;\rpublic static void main(String argv[]){\rSystem.out.println(i);\r}\r}\r正确答案: D 你的答案: D\rA、有错误，变量i没有初始化。\rB、null\rC、1\rD、0\r   链接：https://www.nowcoder.com/questionTerminal/9316826838a644b3a66ff1e9e610eb34\n类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值。\n 下列哪些方法是针对循环优化进行的\n正确答案: A B D 你的答案: A B D\rA、强度削弱\rB、删除归纳变量\rC、删除多余运算\rD、代码外提\r链接：https://www.nowcoder.com/questionTerminal/9c5a9ddea8784c1a81e8648895e0e06b\n常见的代码优化技术有：复写传播，删除死代码, 强度削弱，归纳变量删除\n（下面抄几页PPT和别人的博客，QAQ，关键是编译原理没认真学过，咱家不太会。。。)\n如果有同学有研究过这部分内容，并总结过，有更好的答案，请联系我删除本篇非原创解答\n复写传播:\n 复写语句：形式为f = g 的赋值  优化过程中会大量引入复写 复写传播变换的做法是在复写语句f = g后，尽可能用g代表f 复写传播变换本身并不是优化，但它给其他优化带来机会  常量合并（编译时可完成的计算） 死代码删除      死代码删除\n 死代码是指计算的结果决不被引用的语句 一些优化变换可能会引起死代码  代码外提\n 代码外提是循环优化的一种 循环优化的其它重要技术  归纳变量删除 强度削弱    例:\n1 2 3 4  while(i \u0026lt;= limit - 2)\r// 代码外提后变成\rt = limit - 2;\rwhile``(i \u0026lt;= t) ....\r  归纳变量删除\n1 2 3 4  j = j - 1\rt4 = 4 * j\rt5 = a[t4]\rif t5 \u0026gt; value goto B3\r   j和t4的值步伐一致地变化，这样的变量叫作归纳变量 在循环中有多个归纳变量时，也许只需要留下一个 这个操作由归纳变量删除过程来完成 对本例可以先做强度削弱，它给删除归纳变量创造机会  强度削弱\n 强度削弱的本质是把强度大的运算换算成强度小的运算，例如将乘法换成加法运算。  参考资料\n \u0026ldquo;某个不知名PPT\u0026rdquo; \u0026quot;《编译原理之代码优化》(By 墨篙和小奶猫)\u0026quot;  关于OutOfMemoryError，下面说法正确的是（）\n正确答案: A B C 你的答案: A B C\rA、java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。\rB、java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现\rC、java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小\rD、java.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到\r链接：https://www.nowcoder.com/questionTerminal/4aeaf31fd13a473dab3921d128752589\n关于此题，《深入理解java虚拟机》有关于OOM（OutOfMemory）问题的解释 A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题\nB：属于堆空间不足导致的错误，问题比较少见，解决方式和C相同\nC：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出，如果是内存列楼，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题 D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。\n以下程序执行的结果是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class X{\rY y=new Y();\rpublic X(){\rSystem.out.print(\u0026#34;X\u0026#34;);\r}\r}\rclass Y{\rpublic Y(){\rSystem.out.print(\u0026#34;Y\u0026#34;);\r}\r}\rpublic class Z extends X{\rY y=new Y();\rpublic Z(){\rSystem.out.print(\u0026#34;Z\u0026#34;);\r}\rpublic static void main(String[] args) {\rnew Z();\r}\r}\r正确答案: C 你的答案: C\rA、ZYXX\rB、ZYXY\rC、YXYZ\rD、XYZX\r  链接：https://www.nowcoder.com/questionTerminal/27a89bce14c242d1a4161fbeca2b6b7e\n初始化过程：\n 初始化父类中的静态成员变量和静态代码块 ； 初始化子类中的静态成员变量和静态代码块 ； 初始化父类的普通成员变量和代码块，再执行父类的构造方法； 初始化子类的普通成员变量和代码块，再执行子类的构造方法；  执行过程：\n（1）初始化父类的普通成员变量和代码块，执行Y y=new Y();输出Y （2）再执行父类的构造方法；输出X\n（3）初始化子类的普通成员变量和代码块，执行Y y=new Y();输出Y\n（4）再执行子类的构造方法；输出Z\n（5）所以输出YXYZ\n常识 UNIX操作系统是著名的（）。\n正确答案: B 你的答案: B\rA、多道批处理系统\rB、分时系统\rC、实时系统\rD、分布式系统\r链接：https://www.nowcoder.com/questionTerminal/a1b1da8583b9490fa91e319bd090ca2e\n操作系统分类\n批处理操作系统 （Batch Processing Operating System）它的特点是：多道和成批处理。\n分时操作系统(Time Sharing Operating System，简称TSOS) 分时系统具有多路性、交互性、“独占”性和及时性的特征。多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。“独占”性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。及时性指，系统对用户提出的请求及时响应。\n实时操作系统(Real Time Operating System，简称RTOS) 实时操作系统要追求的目标是：对外部请求在严格时间范围内做出反应，有高可靠性和完整性。其主要特点是资源的分配和调度首先要考虑实时性然后才是效率。此外，实时操作系统应有较强的容错能力。\n网络操作系统（Network Operating System，简称NOS）通常运行在服务器上的操作系统，是基于计算机网络的，其目标是相互通信及资源共享。\n分布式操作系统 (Distributed Software Systems)是为分布计算系统配置的操作系统。大量的计算机通过网络被连结在一起，可以获得极高的运算能力及广泛的数据共享。\n分布式操作系统是网络操作系统的更高形式，它保持了网络操作系统的全部功能，而且还具有透明性、可靠性和高性能等。网络操作系统和分布式操作系统虽然都用于管理分布在不同地理位置的计算机，但最大的差别是：网络操作系统知道确切的网址，而分布式系统则不知道计算机的确切地址；分布式操作系统负责整个的资源分配，能很好地隐藏系统内部的实现细节，如对象的物理位置等。这些都是对用户透明的。\n计算机内的传输是 （）传输，而通信线路上的传输是（）传输。\n正确答案: A 你的答案: A\rA、并行，串行\rB、串行，并行\rC、并行，并行\rD、串行，串行\r链接： https://www.nowcoder.com/questionTerminal/00560b154d994da0846e4c8e13b2a626\n并行数据传输: 是在传输中有多个数据位同时在设备之间进行的传输.一个编了码的字符通常是由若干位二进制数表示,如用ASCII码编码的符号是由8位二进制数表示的,则并行传输ASCII编码符号就需要8个传输信道,使表示一个符号的所有数据位能同时沿着各自的信道并排的传输.。\n串行数据传输:是在传输中只有1个数据位在设备之间进行的传输.对任何一个由若干位二进制表示的字符,串行传输都是用一个传输信道,按位有序的对字符进行传输。\n区别: 串行传输的速度比并行传输的速度要慢得多,但费用低.并行传输适用距离短,而串行传输适用远距离传输\n下面哪项技术可以用在WEB开发中实现会话跟踪实现？\n正确答案: A B C D 你的答案: A B C D\rA、session\rB、Cookie\rC、地址重写\rD、隐藏域\r链接：https://www.nowcoder.com/questionTerminal/8d86bb29952642169e816d519f8417f3\n会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。\nHTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。\n有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。\n 隐藏表单域：，非常适合步需要大量数据存储的会话应用。 URL重写:URL可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 Cookie:一个Cookie是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为HTTP响应的一部分传送到客户端，客户端被请求保存Cookie值，在对同一服务器的后续请求使用一个Cookie头标将之返回到服务器。与其它技术比较，Cookie的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值 Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话  Windows 操作系统中，文件组织采用（）目录结构。\n正确答案: C 你的答案: C\rA、分区\rB、关系型\rC、树型\rD、网状\r 链接：https://www.nowcoder.com/questionTerminal/dc12220c61044df6b4d3105020e220ab\nwindows操作系统的目录结构是树形结构。就像一棵树，它的树干就是根目录，然后第一个分枝之后是第一层目录\n 目录在linux文件系统中是以怎样的形式存在的？\n正确答案: B 你的答案: B\rA、文件夹\rB、文件\rC、inode\rD、软链接\r 链接：https://www.nowcoder.com/questionTerminal/39c85d760469456aa105ea30d591c109\nLinux系统下，一切都是文件，硬件设备也是文件\n 下列进程通信机制中， UNIX 系统中没有采用的机制是（ ）\n正确答案: B 你的答案: B\rA、信号量集\rB、管程机制\rC、软中断信号\rD、套接字\rLinux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)\nLinux线程间通信：互斥量（mutex），信号量，条件变量\nWindows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket)\nWindows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）\n笔记  IPv4地址32位\nMAC地址48位\nIPv6地址128位\n 网络状态码\n   状态码 英文 解释     100 Continue 继续。客户端应继续其请求   101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议   200 OK 请求成功。一般用于GET与POST请求   201 Created 已创建。成功请求并创建了新的资源   202 Accepted 已接受。已经接受请求，但未处理完成   203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   206 Partial Content 部分内容。服务器成功处理了部分GET请求   300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替   302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   303 See Other 查看其它地址。与301类似。使用GET和POST请求查看   304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源   305 Use Proxy 使用***。所请求的资源必须通过***访问   306 Unused 已经被废弃的HTTP状态码   307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向   400 Bad Request 客户端请求的语法错误，服务器无法理解   401 Unauthorized 请求要求用户的身份认证   402 Payment Required 保留，将来使用   403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求   404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\u0026quot;您所请求的资源无法找到\u0026quot;的个性页面   405 Method Not Allowed 客户端请求中的方法被禁止   406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求   407 Proxy Authentication Required 请求要求***的身份认证，与401类似，但请求者应当使用***进行授权   408 Request Time-out 服务器等待客户端发送的请求时间过长，超时   409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突   410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   412 Precondition Failed 客户端请求信息的先决条件错误   413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理   415 Unsupported Media Type 服务器无法处理请求附带的媒体格式   416 Requested range not satisfiable 客户端请求的范围无效   417 Expectation Failed 服务器无法满足Expect的请求头信息   500 Internal Server Error 服务器内部错误，无法完成请求   501 Not Implemented 服务器不支持请求的功能，无法完成请求   502 Bad Gateway 作为网关或者***工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应   503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   504 Gateway Time-out 充当网关或***的服务器，未及时从远端服务器获取请求   505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理    设计模式分类\n一、创建型模式\n工厂模式（Factory Pattern）\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton Pattern）\n建造者模式（Builder Pattern）\n原型模式（Prototype Pattern）\n二、结构型模式\n适配器模式（Adapter Pattern）\n桥接模式（Bridge Pattern）\n过滤器模式（Filter、Criteria Pattern）\n组合模式（Composite Pattern）\n装饰器模式（Decorator Pattern）\n外观模式（Facade Pattern）\n享元模式（Flyweight Pattern）\n代理模式（Proxy Pattern）\n三、行为型模式\n责任链模式（Chain of Responsibility Pattern）\n命令模式（Command Pattern）\n解释器模式（Interpreter Pattern）\n迭代器模式（Iterator Pattern）\n中介者模式（Mediator Pattern）\n备忘录模式（Memento Pattern）\n观察者模式（Observer Pattern）\n状态模式（State Pattern）\n空对象模式（Null Object Pattern）\n策略模式（Strategy Pattern）\n模板模式（Template Pattern）\n访问者模式（Visitor Pattern）\n 常用 ASCII 码值\n空格为 32\n数字0为 48\n“A”为 65\n“a”值为 97\n JVM常用命令\n jps：查看本机java进程信息。 jstack：打印线程的栈信息，制作线程dump文件。 jmap：打印内存映射，制作堆dump文件 jstat：性能监控工具 jhat：内存分析工具 jconsole：简易的可视化控制台 jvisualvm：功能强大的控制台  数据库系统的三级模式结构\n数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成.\n为了能够在系统内部实现这 3 个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：\n外模式/模式映像（映像定义通常包含在各自外模式的描述中，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性，应用程序是依据外模式编写的）\n模式/内模式映像（包含在模式描述中，此映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系，它保证了数据与程序的物理独立性，所以称为数据的物理独立性）\n1NF,2NF,3NF\n1NF : 属性是原子性的，即不可拆分的；例如姓名这个属性是一般不可拆分的；而社会保险号如果是由出生年月日与姓名缩写构成的话，就是可拆分的：包含可拆分的含义：出生年月日，姓名； 是否可拆分取决于对含义的解释；\n2NF：解决了非主键属性对主键属性的部分依赖；如表（A, B, C, D），其中ABCD代表属性，假设（A, B）是主键，若C只依赖于B，则这个表是不符合2NF的，可拆分为（A, B, D）与 （B, C）两张表；很明显，如果主键只有一个属性，那么肯定是2NF\n3NF：解决了非主键属性对主键属性的传递依赖；如表（A,B,C,D），如果主键是A, 而B依赖于A，C依赖于B，则这个表有传递依赖，是不符合3NF的；\n范式的目的是为了减少/消除冗余\n共享锁/排他锁\n共享锁【S锁】，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。\n排他锁【X锁】，又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。\n事务的特性\n原子性（Atomicity）：是事务执行的最小单位。不允许分割。事务的原子性确保动作要么全部成功，要么全部失败\n一致性（Consistency）：执行事务的前后，数据保持不变\n隔离性（Isolation）：并发访问事务时，一个用户的事务数据不能被其他事务所干扰。各并发事务之间的数据库是独立的\n持久性（Durability）：一个事物被提交后，他对数据库的数据改变时持久的。即使数据库发生故障，也不应该对数据有影响\n","description":"本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。","id":0,"section":"posts","tags":null,"title":"牛客高赞评论整理","uri":"https://eternidad33.github.io/zh/posts/%E7%89%9B%E5%AE%A2%E9%AB%98%E8%B5%9E%E8%AF%84%E8%AE%BA/"},{"content":"Collection结构图 Map结构图 总结 推荐视频：Java零基础教程视频（适合Java 0基础，Java初学入门）\nArrayList：底层是数组\nLinkedList：底层是双向链表\nVector：底层是数组，线程安全的，效率较低，使用较少\nHashSet：底层是 HashMap，放到 HashSet集合中的元素等同于放到HashMap集合 key部分\nTreeSet：底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合key部分\nHashMap：底层是哈希表\nHashTable：底层是哈希表，线程安全，效率较低，使用较少\nProperties：线程安全的，key和value只能存储字符串\nTreeMap：底层是二叉树，它的key可以自动按照大小排序\nList集合存储元素的特点：\n 有序：存进去和取出来的顺序相同，每个元素都有下标 可重复  Set集合存储元素的特点：\n 无序：存进去和取出来的顺序不相同，Set集合中元素没有有下标 不可重复  SortedSet（SortedMap）集合存储元素的特点\n 无序不可重复 SortedSet集合中元素是可排序的 可排序：可以按照大小顺序排列  Map集合的key就是一个Set集合，往Set集合放数据实际上放到了Map集合的key部分。\nArrayList  默认初始化容量为10 底层是object数组 扩容1.5倍 建议给定一个预估的初始化容量，减少数组的扩容次数 优点：随机增删元素效率低 缺点：末尾增删元素效率高  LinkedList  底层也是有下标的，双向链表 检索、查询的时候只能从头结点开始 优点：随机增删元素效率高 缺点：查询效率低  Vector  线程安全 初始化容量为10 2倍扩容 底层是数组  HashSet  底层HashMap 无序，不可重复 无序是指没有下标  TreeSet  底层TreeMap 无序，不可重复 元素会自动排序存储 要实现Comparable\u0026lt;T\u0026gt;的 compareTo(T o)方法  HashMap   底层是哈希表\n  数组+单向链表\n  源码\n1 2 3 4 5 6 7 8 9 10 11  public class HashMap\u0026lt;K,V\u0026gt;{\r//数组\r transient Node\u0026lt;K,V\u0026gt;[] table;\r//链表\r static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; {\rfinal int hash;\rfinal K key;\rV value;\rNode\u0026lt;K,V\u0026gt; next;\r}\r}\r    同一个链表的hash值相等\n  放在HashMap中的元素需要重写equals和hashCode方法\n  map.put(k,v)\n 封装node对象 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，直接将Node添加到这个位置 有元素，在链表每个节点进行euquals()比较，如果全为false，在末尾添加，如果有True，更新Value    map.get(k)\n 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，返回None 下标有链表，对链表元素的Key比较equals，有true返回value，全为false，代表没有元素，返回null    扩容是原来长度的2倍\n  允许key值为null\n  HashTable  key和value都不能为null 线程安全 初始化容量11 扩容2倍+1  Properties  继承HashTable，线程安全的 key和value只能存储字符串  TreeMap  放到TreeMap集合中的元素的key部分进行排序有两种实现方式  实现java.lang.Comparable的compareTo方法 构造TreeSet或TreeMap集合的时候传一个比较器对象Comparator   比较规则不会发生改变或者比较规则只有一个的时候使用Comparable 比较规则多个，并且比较规则需要频繁切换Comparator  ","description":"ArrayList：底层是数组，LinkedList：底层是双向链表，Vector：底层是数组，线程安全的，效率较低，使用较少，HashSet：底层是 HashMap，放到 HashSet集合中的元素等同于放到HashMap集合 key部分，TreeSet：底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合key部分，HashMap：底层是哈希表","id":1,"section":"posts","tags":["java"],"title":"Java集合","uri":"https://eternidad33.github.io/zh/posts/java%E9%9B%86%E5%90%88/"},{"content":"欢迎大家访问我的github\n创建以用户名为名称的仓库\n自定义自己的README文件即可在自己的github显示了\n我这个上边显示的编码时长，是添加了一个action每天更新自己的编码时长\n具体设计步骤可参考 github上的athul/waka-readme项目\n总结一下简要的步骤\n 注册wakatime账号 在自己常用的IDE上下载wakatime插件，配置上自己的API key 将自己的API key存到自己GitHub仓库的secrets 在README文件上加上  1 2  \u0026lt;!--START_SECTION:waka--\u0026gt;\r\u0026lt;!--END_SECTION:waka--\u0026gt;\r  配置GitHub仓库的Action，这样就能每天自动运行了  ","description":"","id":2,"section":"posts","tags":["github"],"title":"自定义GitHub主页","uri":"https://eternidad33.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89github%E4%B8%BB%E9%A1%B5/"},{"content":"连接SQLite 要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；\n连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。\nPython定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。\n由于SQLite的驱动内置在Python标准库中，可以直接来操作SQLite数据库。\n1 2  # 导入SQLite驱动: import sqlite3   1 2 3 4  # 连接到SQLite数据库 # 数据库文件是test.db # 如果文件不存在，会自动在当前目录创建: conn = sqlite3.connect(\u0026#39;test.db\u0026#39;)   1 2  # 创建一个Cursor: cursor = conn.cursor()   1 2  # 执行一条SQL语句，创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 继续执行一条SQL语句，插入一条记录: cursor.execute(\u0026#39;insert into user (id, name) values (\u0026#34;1\u0026#34;, \u0026#34;vigilr\u0026#34;)\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 通过rowcount获得插入的行数: cursor.rowcount   1  1 2 3 4 5 6  # 关闭Cursor: cursor.close() # 提交事务: conn.commit() # 关闭Connection: conn.close()   1 2 3 4  conn = sqlite3.connect(\u0026#39;test.db\u0026#39;) cursor = conn.cursor() # 执行查询语句: cursor.execute(\u0026#39;select * from user where id=?\u0026#39;,(\u0026#39;1\u0026#39;,))   \u0026lt;sqlite3.Cursor at 0x2040e224810\u0026gt;  1 2 3  # 获得查询结果集: values = cursor.fetchall() values   [('1', 'vigilr')]  1 2  cursor.close() conn.close()   使用Python的DB-API时，只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用。\n使用Cursor对象执行insert，update，delete语句时，执行结果由rowcount返回影响的行数，就可以拿到执行结果。\n使用Cursor对象执行select语句时，通过featchall()可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。\n如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，例如：\n1  cursor.execute(\u0026#39;select * from user where name=? and pwd=?\u0026#39;, (\u0026#39;abc\u0026#39;, \u0026#39;password\u0026#39;))   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # -*- coding: utf-8 -*- import sqlite3 # 初始数据: conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;create table user(id varchar(20) primary key, name varchar(20), score int)\u0026#39;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-001\u0026#39;, \u0026#39;Adam\u0026#39;, 95)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-002\u0026#39;, \u0026#39;Bart\u0026#39;, 62)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-003\u0026#39;, \u0026#39;Lisa\u0026#39;, 78)\u0026#34;) cursor.close() conn.commit() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13  def get_score_in(low, high): \u0026#39;\u0026#39;\u0026#39;返回指定分数区间的名字，按分数从低到高排序\u0026#39;\u0026#39;\u0026#39; conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;select name from user where score\u0026gt;=? and score\u0026lt;=? ORDER BY score\u0026#39;,(low,high)) temp=cursor.fetchall() result=[] for t in temp: for i in t: result.append(i) cursor.close() conn.close() return result   1 2 3 4 5 6 7  # 测试: assert get_score_in(80, 95) == [\u0026#39;Adam\u0026#39;], get_score_in(80, 95) assert get_score_in(60, 80) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;], get_score_in(60, 80) assert get_score_in(60, 100) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;, \u0026#39;Adam\u0026#39;], get_score_in(60, 100) print(\u0026#39;Pass\u0026#39;)   Pass  连接MySQL 安装MySQL驱动\n由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。\nMySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数--allow-external：\npip install mysql-connector-python --allow-external mysql-connector-python\n如果上面的命令安装失败，可以试试另一个驱动：\npip install mysql-connector\n除了使用mysql.connector还可以使用pymysql\n1 2  # 导入pymysql模块 import pymysql   1 2 3 4 5 6 7 8 9 10 11 12  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;) cursor.close() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 插入一行记录，注意MySQL的占位符是%s: cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;1\u0026#39;, \u0026#39;wasd\u0026#39;]) cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;2\u0026#39;, \u0026#39;zxc\u0026#39;]) print(\u0026#39;受影响行数：\u0026#39;,cursor.rowcount) # 提交事务: conn.commit() cursor.close() conn.close()   受影响行数： 1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) # 运行查询: cursor = conn.cursor() cursor.execute(\u0026#39;select * from user\u0026#39;) values = cursor.fetchall() print(values) # 关闭Cursor和Connection: cursor.close() conn.close()   (('1', 'wasd'), ('2', 'zxc'))  使用SQLAlchemy ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。\n在Python中，最有名的ORM框架是SQLAlchemy。\n首先通过pip安装SQLAlchemy：pip install sqlalchemy\n1 2 3 4 5 6  # 第一步，导入SQLAlchemy，并初始化DBSession： # 导入: from sqlalchemy import Column, String, create_engine,ForeignKey from sqlalchemy.orm import sessionmaker,relationship from sqlalchemy.ext.declarative import declarative_base   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 创建对象的基类: Base = declarative_base() # 定义User对象: class User(Base): # 表的名字: __tablename__ = \u0026#39;users\u0026#39; # 表的结构: id = Column(String(20), primary_key=True) name = Column(String(20)) # 以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如Scho class School(Base): __tablename__ = \u0026#39;school\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # 初始化数据库连接:mysqlconnector和pymysql都可以用 # engine = create_engine(\u0026#39;mysql+mysqlconnector://root:123456@localhost:3308/test\u0026#39;) engine = create_engine(\u0026#39;mysql+pymysql://root:123456@localhost:3308/test\u0026#39;) # 创建DBSession类型: DBSession = sessionmaker(bind=engine)   create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：\n数据库类型+数据库驱动名称://用户名:密码@数据库地址:端口号/数据库名\n由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 创建所有定义的表到数据库中 Base.metadata.create_all(engine) # 创建session对象: session = DBSession() # 创建新User对象: user1 = User(id=\u0026#39;1\u0026#39;, name=\u0026#39;wasd\u0026#39;) user2 = User(id=\u0026#39;2\u0026#39;, name=\u0026#39;zxc\u0026#39;) user3 = User(id=\u0026#39;3\u0026#39;, name=\u0026#39;qwe\u0026#39;) user4 = User(id=\u0026#39;4\u0026#39;, name=\u0026#39;rty\u0026#39;) user5 = User(id=\u0026#39;5\u0026#39;, name=\u0026#39;vbn\u0026#39;) user6 = User(id=\u0026#39;6\u0026#39;, name=\u0026#39;fgh\u0026#39;) # 添加到session: session.add(user1) session.add(user2) session.add(user3) session.add(user4) session.add(user5) session.add(user6) # 提交即保存到数据库: session.commit() # 关闭session: session.close() # 关键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接。   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\pymysql\\cursors.py:170: Warning: (1366, \u0026quot;Incorrect string value: '\\\\xD6\\\\xD0\\\\xB9\\\\xFA\\\\xB1\\\\xEA...' for column 'VARIABLE_VALUE' at row 489\u0026quot;) result = self._query(query)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 查询数据 # 创建Session: session = DBSession() # 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行: user = session.query(User).filter(User.id==\u0026#39;1\u0026#39;).one() users = session.query(User).filter(User.id!=\u0026#39;1\u0026#39;).all() # 打印类型和对象的name属性: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) for user in users: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) # 关闭Session: session.close()   type: \u0026lt;class '__main__.User'\u0026gt; name: wasd type: \u0026lt;class '__main__.User'\u0026gt; name: zxc type: \u0026lt;class '__main__.User'\u0026gt; name: qwe type: \u0026lt;class '__main__.User'\u0026gt; name: rty type: \u0026lt;class '__main__.User'\u0026gt; name: vbn type: \u0026lt;class '__main__.User'\u0026gt; name: fgh  ORM就是把数据库表的行与相应的对象建立关联，互相转换。\n由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。\n例如，如果一个User拥有多个Book，就可以定义一对多关系如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class User(Base): __tablename__ = \u0026#39;user\u0026#39; __table_args__ = {\u0026#39;extend_existing\u0026#39;: True} id = Column(String(20), primary_key=True) name = Column(String(20)) # 一对多: books = relationship(\u0026#39;Book\u0026#39;) class Book(Base): __tablename__ = \u0026#39;book\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # “多”的一方的book表是通过外键关联到user表的: user_id = Column(String(20), ForeignKey(\u0026#39;user.id\u0026#39;)) # 当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。 # 创建所有定义的表到数据库中 Base.metadata.create_all(engine)   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\sqlalchemy\\ext\\declarative\\clsregistry.py:129: SAWarning: This declarative base already contains a class with the same class name and module name as __main__.User, and will be replaced in the string-lookup table. % (item.__module__, item.__name__)  更多用法可参考：这篇文章https://www.jianshu.com/p/65903a69d61d\n","description":"","id":3,"section":"posts","tags":["python"],"title":"Python三种连接数据库的方式","uri":"https://eternidad33.github.io/zh/posts/python%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"content":"购买服务器 直接购买皆可以了\n有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器\n现在购买可以91.8一年\n学生购买是9.50一个月（参与云翼计划然后学生认证即可）\n 我是单买的一个月的，因为不经常用，想用的时候就买一个月的\n 安装镜像 从镜像市场选择宝塔控制面板安装\n 宝塔Linux面板（LAMP/LNMP/Tomcat/Node.js）\n功能强大且终身免费的Linux服务器管理软件，一键部署：LAMP/LNMP/Tomcat/Node.js、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。\n 镜像安装完要配置安全组打开相应端口\n面板配置 bt命令进行相关的操作\n可以更改掉默认的用户名和密码\n浏览器访问公网ip:8888进行环境的安装\n可以选择LNMP安装，大约5~6分钟安装完成\n配置mysql数据库相应的端口，默认3306，可以改为其他端口\n安装完成后可以数据库的root密码\n安装Tomcat 从左侧的软件商店安装Tomcat（不用单独安装Java，面板自动安装Java）\n安装完tomcat后要在面板中放行8080端口，前边的安全组也要放行8080端口\n浏览器成功访问公网ip:8080，即为成功安装\n部署项目 本文部署的是GitHub上的 一个基于SSM+Websocket的实时在线聊天室项目\n配置数据库信息并生成war包\n成功生成war包后的效果如下：\n在服务器的mysql运行本项目中的sql文件\n将生成的war文件上传到/www/server/tomcat/webapps目录下，tomcat会自动解压\n 上传文件方法有很多，可以通过命令行，也可以用工具，我知道的工具如下：\n xshell及xftp IDEA的阿里云部署插件(Alibaba Cloud Toolkit) 通过宝塔面板上传   浏览器访问公网IP:8080/网站应用名，出现下面的界面即为成功部署\n","description":"","id":4,"section":"posts","tags":["java"],"title":"阿里云宝塔面板配置及部署Java项目","uri":"https://eternidad33.github.io/zh/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE/"},{"content":" Scrapy is a fast high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.\n​\t\u0026mdash;\u0026mdash;\u0026mdash;来自官方文档的介绍\n  Engine从Spider处获得爬取请求(Request) Engine将爬取请求转发给Scheduler，用于调度 Engine从Scheduler处获得下一个要爬取的请求 Engine将爬取请求通过中间件发送给Downloader 爬取网页后，Downloader形成响应（Response）通过中间件发给Engine Engine将收到的响应通过中间件发送给Spider处理 Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine Engine将爬取项发送给Item Pipeline（框架出口） Engine将爬取请求发送给Scheduler  Engine控制各模块数据流，不间断从Scheduler处获得爬取请求，直至请求为空。\n数据流的出入口\n框架入口：Spider的初始爬取请求\n框架出口：Item Pipeline\n用户只需编写(配置)Spider和Item Pipeline\nEngine\n 控制所有模块之间的数据流 根据条件触发事件  不需要用户修改\nDownloader\n根据请求下载网页\n不需要用户修改\nScheduler\n对所有爬取请求进行调度管理\n不需要用户修改\nDownloader Middleware\n目的：实施Engine、Scheduler和Downloader之间进行用户可配置的控制\n功能：修改、丢弃、新增请求或响应\n用户可以编写配置代码\nSpider\n 解析Downloader返回的响应（Response） 产生爬取项（scraped item） 产生额外的爬取请求（Request）  需要用户编写配置代码\nItem Pipelines\n 以流水线方式处理Spider产生的爬取项 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库  需要用户编写配置代码\nSpider Middleware\n目的：对请求和爬取项的再处理\n功能：修改、丢弃、新增请求或爬取项\n用户可以编写配置代码\nrequests 和 Scrapy的异同\n相同点：\n 两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线 两者可用性都好，文档丰富，入门简单 两者都没有处理js、提交表单、应对验证码等功能（可扩展）  不同点：\n   requests Scrapy     页面级爬虫 网站级爬虫   功能库 框架   并发性考虑不足，性能较差 并发性好，性能较高   重点在于页面下载 重点在于爬虫结构   定制灵活 一般定制灵活，深度定制困难   上手十分简单 入门稍难    Scrapy常用命令\n   命令 说明 格式     startproject 创建一个新工程 scrapy startproject \u0026lt;name\u0026gt; [dir]   genspider 创建一个爬虫 scrapy genspider [options] \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt;   settings 获得爬虫配置信息 scrapy settings [options]   crawl 运行一个爬虫 scrapy crawl \u0026lt;spider\u0026gt;   list 列出工程中所有爬虫 scrapy list   shell 启动URL调试命令行 scrapy shell [url]    生成的工程目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  PS E:\\scrapyDemo\u0026gt; tree /f 卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r│ scrapy.cfg -------------------\u0026gt;\u0026gt;部署Scrapy爬虫的配置文件\r│\r└─scrapyDemo ------------\u0026gt;\u0026gt;Scrapy框架的用户自定义Python代码\r│ items.py --------------\u0026gt;\u0026gt;Items代码模板（继承类）\r│ middlewares.py -------\u0026gt;\u0026gt;Middlewares代码模板（继承类）\r│ pipelines.py ---------\u0026gt;\u0026gt;Pipelines代码模板（继承类）\r│ settings.py --------\u0026gt;\u0026gt;Scrapy爬虫的配置文件\r│ __init__.py ---------\u0026gt;\u0026gt;初始化脚本\r│\r├─spiders --------------\u0026gt;\u0026gt;Spiders代码模板目录（继承类）\r│ │ firstSpider.py ------\u0026gt;\u0026gt;生成的爬虫\r│ │ __init__.py ------\u0026gt;\u0026gt;初始文件，无需修改\r│ │\r│ └─__pycache__ --------\u0026gt;\u0026gt;缓存目录，无需修改\r│ firstSpider.cpython-37.pyc\r│ __init__.cpython-37.pyc\r│\r└─__pycache__ -----------\u0026gt;\u0026gt;缓存目录，无需修改\rsettings.cpython-37.pyc\r__init__.cpython-37.pyc\r  Scrapy爬虫的使用步骤\n步骤1：创建一个工程和Spider模板\n步骤2：编写Spider\n步骤3：编写Item Pipeline\n步骤4：优化配置策略\nScrapy爬虫的数据类型\n  Request类\nRequest对象表示一个HTTP请求，由Spider生成，由Downloader执行\n  Response类\nResponse对象表示一个HTTP响应，由Downloader生成，由Spider处理\n  Item类\nItem对象表示一个从HTML页面中提取的信息内容，由Spider生成，由Item Pipeline处理，Item类似字典类型，可以按照字典类型操作\n  Scrapy爬虫支持多种HTML信息提取方法：\n Beautiful Soup lxml re XPath Selector CSS Selector  ","description":"","id":5,"section":"posts","tags":["python"],"title":"Scrapy 框架笔记","uri":"https://eternidad33.github.io/zh/posts/scrapy/"},{"content":"基础页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;\r\u0026lt;h2\u0026gt;前端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;List1\u0026#34;\u0026gt;\r\u0026lt;li id=\u0026#34;li1\u0026#34;\u0026gt;HTML\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;h2\u0026gt;后端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;list2\u0026#34;\u0026gt;\r\u0026lt;li title=\u0026#34;C语言\u0026#34;\u0026gt;C\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;Java语言\u0026#34;\u0026gt;Java\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;我是Python\u0026#34;\u0026gt;Python\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;C Sharp\u0026#34;\u0026gt;C#\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r  运行结果\n通过ID获取元素 1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;list1\u0026#34;);\rvar c2 = document.getElementById(\u0026#34;li1\u0026#34;)\rdocument.write(\u0026#34;通过ID获取 ul 标签\u0026#34; + c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#34;通过ID获取 li 标签\u0026#34; + c2);\r\u0026lt;/script\u0026gt;\r  显示结果：\ninnerHTML用于获取或修改p标签内容\n1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\rc1.innerHTML = \u0026#39;我是修改后的p标签\u0026#39;;\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\r\u0026lt;/script\u0026gt;\r  显示结果：\n改变HTML样式 基本语法格式：Object.style.property=str;\n1 2 3 4 5 6 7  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.style.color = \u0026#39;red\u0026#39;\rc1.style.fontSize = \u0026#39;30px\u0026#39;\rc1.style.fontFamily = \u0026#39;隶书\u0026#39;\rc1.style.backgroundColor = \u0026#39;#cccccc\u0026#39;\r\u0026lt;/script\u0026gt;\r  显示效果：\n改变类选择器 格式object.className = classname\n1 2  var c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.className = \u0026#39;test\u0026#39;\r  显示结果：\n通过name属性获取元素 格式document.getElementsByName(str);\n1 2 3  var c1 = document.getElementsByName(\u0026#39;myname\u0026#39;);\rdocument.write(c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#39;数组的长度为\u0026#39; + c1.length);\r  显示结果：\n通过标签名字获取标签 格式：document.getElementsByTagName(str);\n1 2  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\r  显示结果：\nID是唯一的。\nName可以重复。\nTagName是某一标签类的集合。\n获取属性值 格式：elementNode.getAttribute(name)\n1 2 3 4 5 6 7 8  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  设置新属性 elementNode.setAttribute(name,value)\n1 2 3 4 5 6 7 8 9 10 11 12  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text == \u0026#34;C Sharp\u0026#34;) {\rc1[i].setAttribute(\u0026#39;title\u0026#39;, \u0026#39;C#\u0026#39;)\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;)\r}\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  节点对象属性 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：\n  nodeName : 节点的名称\n  nodeValue ：节点的值\n  nodeType ：节点的类型\n  1 2 3 4 5 6  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的名称:\u0026#34; + c1[i].nodeName)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的类型:\u0026#34; + c1[i].nodeType)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的值:\u0026#34; + c1[i].nodeValue)\r}\r  访问子节点 elementNode.childNodes用于访问子节点\nnode.firstChild用于访问第一个子节点\nnode.lastChild用于访问最后一个子节点\n访问父节点 elementNode.parentNode用于访问父节点\nelementNode.parentNode.parentNode用于访问祖节点\n访问兄弟节点   nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。nodeObject.nextSibling\n  previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。nodeObject.previousSibling \n   如果无兄弟节点，则该属性返回 null。\n 插入节点 appendChild(newnode)\n1 2 3 4  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.appendChild(newNode)\r  insertBefore() 方法可在已有的子节点前插入一个新的子节点。\ninsertBefore(newnode,node);\n1 2 3 4 5  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rvar lNode = document.getElementById(\u0026#39;List1\u0026#39;).firstChild\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.insertBefore(newNode, lNode)\r  删除节点 removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。\nnodeObject.removeChild(node)\n node ：必需，指定需要删除的节点。\n 替换元素节点 replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。\nnode.replaceChild (newnode,oldnew ) \n newnode : 必需，用于替换 oldnew 的对象。\noldnew : 必需，被 newnode 替换的对象。\n 创建元素节点 createElement()方法可创建元素节点。此方法可返回一个 Element 对象。\ndocument.createElement(tagName)\ntagName：字符串值，这个字符串用来指明创建元素的类型。\n 要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。\n 创建文本节点 createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。\ndocument.createTextNode(data)\ndata : 字符串值，可规定此节点的文本。\n","description":"目录 基础页面，通过ID获取元素，改变HTML样式，改变类选择器，通过name属性获取元素，通过标签名字获取标签，获取属性值，设置新属性节点，对象属性访问子节点，访问父节点，访问兄弟节点，插入节点，删除节点，替换元素节点，创建元素节点，创建文本节点","id":6,"section":"posts","tags":["javaScript","html"],"title":"JavaScript DOM 操作","uri":"https://eternidad33.github.io/zh/posts/javascript-dom%E6%93%8D%E4%BD%9C/"},{"content":"项目配置 @Value(“${变量名}”) 变量名：配置文件中的全局变量\n1 2 3 4  @Value(\u0026#34;${name}\u0026#34;)\rprivate String name;\r@Value(\u0026#34;${desc}\u0026#34;)\rprivate String desc;\r  yml配置文件中的配置\n1 2  name:维吉尔desc:你好，${name}！  @ConfigurationProperties(prefix = \u0026ldquo;对象名\u0026rdquo;) @ConfigurationProperties(prefix = \u0026ldquo;person\u0026rdquo;)注解要和@Component一起用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  @Component\r@ConfigurationProperties(prefix = \u0026#34;person\u0026#34;)\rpublic class Person {\rprivate String name;\rprivate int age;\rprivate String sex;\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\r@Override\rpublic String toString() {\rfinal StringBuffer sb = new StringBuffer(\u0026#34;Person{\u0026#34;);\rsb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#34;, age=\u0026#34;).append(age);\rsb.append(\u0026#34;, sex=\u0026#39;\u0026#34;).append(sex).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#39;}\u0026#39;);\rreturn sb.toString();\r}\r}\r  yml配置文件中的对象配置\n1 2 3 4  person:name:Vigilrage:23sex:男  调用方式，会用到@Autowired和@GetMapping(\u0026quot;/person\u0026quot;)\n1 2 3 4 5 6 7  @Autowired\rprivate Person person;\r@GetMapping(\u0026#34;/person\u0026#34;)\rpublic String printPerson() {\rreturn this.person.toString();\r}\r  请求方式    代码 说明 举例     @GetMapping(\u0026quot;/url\u0026quot;) get请求 @GetMapping(\u0026quot;/user/{id}\u0026quot;)   @PostMapping(\u0026quot;/url\u0026quot;) post请求 @PostMapping(\u0026quot;/user\u0026quot;)   @PutMapping(\u0026quot;/url\u0026quot;) put请求 @PutMapping(\u0026quot;/user/{id}\u0026quot;)    Controller相关注解 @Controller 1 2 3 4 5 6 7  @Controller\rpublic class HelloController {\r@GetMapping(\u0026#34;/index\u0026#34;)\rpublic String printIndex() {\rreturn \u0026#34;index\u0026#34;;\r}\r}\r  直接用可解析HTML\n@ResponseBody 与@Controller配合使用\n1 2 3 4 5 6 7 8  @Controller\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\r@ResponseBody\rpublic String sayHello() {\rreturn desc;\r}\r}\r  @RestController @RestController=@Controller+@ResponseBody\n1 2 3 4 5 6 7  @RestController\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\rpublic String sayHello() {\rreturn desc;\r}\r}\r  获取参数 @PathVariable(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4  @GetMapping(\u0026#34;/user/{id}\u0026#34;)\rpublic UserEntity findId(@PathVariable(\u0026#34;id\u0026#34;) Integer id) {\rreturn repository.findById(id).orElse(null);\r}\r  @RequestParam(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4 5 6 7 8 9  @PostMapping(\u0026#34;/user\u0026#34;)\rpublic UserEntity create(@RequestParam(\u0026#34;age\u0026#34;) Integer age,\r@RequestParam(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;sex\u0026#34;) String sex) {\rUserEntity userEntity = new UserEntity();\ruserEntity.setAge(age);\ruserEntity.setName(name);\ruserEntity.setSex(sex);\rreturn repository.save(userEntity);\r}\r  数据库相关 @Entity 表的定义\n@Id 设置主键\n@GeneratedValue 设置自增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  @Entity\rpublic class UserEntity {\r@Id\r@GeneratedValue\rprivate Integer id;\rprivate String name;\rprivate String sex;\rprivate Integer age;\rpublic UserEntity() {\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\rpublic Integer getAge() {\rreturn age;\r}\rpublic void setAge(Integer age) {\rthis.age = age;\r}\r}\r   在IDEA中声明@Entity后，左侧会有数据库的标志\n @Transactional 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Transactional\rpublic void createTwo() {\rUserEntity userEntity1 = new UserEntity();\ruserEntity1.setAge(12);\ruserEntity1.setName(\u0026#34;wasd\u0026#34;);\ruserEntity1.setSex(\u0026#34;sssss\u0026#34;);\rrepository.save(userEntity1);\rUserEntity userEntity2 = new UserEntity();\ruserEntity2.setAge(1314);\ruserEntity2.setName(\u0026#34;zxcvbnm\u0026#34;);\ruserEntity2.setSex(\u0026#34;ddddddd\u0026#34;);\rrepository.save(userEntity2);\r}\r  数据库表的引擎必须为INNODB才可进行事务管理\n","description":"Spring Boot常用注解项目配置@Value(“${变量名}”)变量名：配置文件中的全局变量","id":7,"section":"posts","tags":["java","springboot"],"title":"SpringBoot 必备注解","uri":"https://eternidad33.github.io/zh/posts/springboot%E5%BF%85%E5%A4%87%E6%B3%A8%E8%A7%A3/"},{"content":"[toc]\n简易的图书管理系统 项目简介 推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql\n用到的知识：Java，MySQL\n源码已上传至码云\n项目整体架构 源码目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  PS E:\\IdeaProjects\\BookManager\\src\u0026gt; tree /f\r卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r├─dao\r│ BookDao.java\r│ BookTypeDao.java\r│ UserDao.java\r│\r├─entity\r│ Book.java\r│ Booktype.java\r│ User.java\r│\r├─images\r│ book.png\r│ susu.jpg\r│\r├─META-INF\r│ MANIFEST.MF\r│\r├─util\r│ DbUtil.java\r│ StringUtil.java\r│\r└─view\rAbout.java\rAbout.jfd\rBookAddFrm.java\rBookAddFrm.jfd\rBookTypeAddFrm.java\rBookTypeAddFrm.jfd\rBookTypeManagerFrm.java\rBookTypeManagerFrm.jfd\rLogin.form\rLogin.java\rMainFrm.java\rMainFrm.jfd\r  由此可见，本项目也是采用的 MVC 架构，dao包用于操作数据库，entity包包含本项目的实体类，images包是本项目用到的图片，META-INF包是生成 Jar 包时产生的文件夹，util包包含本项目用到的工具类，view包是本项目的视图层，用于设计窗口显示。\n项目中各类的依赖关系如下图\n具体实现 util包 本项目的工具包，包含两个工具类\nDbUtil.java主要是设计了数据库的驱动，地址，用户名及密码，和控制数据库的连接与断开\nStringUtil.java只是用于判断字符串是否为空，只有空格也算为空\nentity包 此包包含了数据库表的实体对象，可以自己写，也可以通过 idea 的EasyCode插件进行代码生成，但是后边要用到的必要的构造方法要自己写。\n大多数情况下都是简单类包含 Getter 和 Setter 方法，如下是EasyCode插件生成的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  public class Booktype implements Serializable {\rprivate static final long serialVersionUID = -43707012852599825L;\rprivate Integer id;\rprivate String booktypename;\r@Override\rpublic String toString() {\rreturn this.booktypename;\r}\rprivate String booktypedesc;\rpublic Booktype(String booktypename, String booktypedesc) {\rthis.booktypename = booktypename;\rthis.booktypedesc = booktypedesc;\r}\rpublic Booktype() {\rsuper();\r}\rpublic Booktype(Integer id, String booktypename, String booktypedesc) {\rthis(booktypename, booktypedesc);\rthis.id = id;\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getBooktypename() {\rreturn booktypename;\r}\rpublic void setBooktypename(String booktypename) {\rthis.booktypename = booktypename;\r}\rpublic String getBooktypedesc() {\rreturn booktypedesc;\r}\rpublic void setBooktypedesc(String booktypedesc) {\rthis.booktypedesc = booktypedesc;\r}\r}\r  dao包 进行数据库的访问\n类中的方法定义形式基本为public 返回类型 方法名(Connection conn, 实体类 对象名) throws SQLException\n例如用户登录的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public User login(Connection connection, User user) throws SQLException {\rUser resultUser = null;\rString sql = \u0026#34;select * from table_user where userName=? and password=?\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, user.getUserName());\rpsmt.setString(2, user.getPassword());\rResultSet resultSet = psmt.executeQuery();\rif (resultSet.next()) {\rresultUser = new User();\rresultUser.setId(resultSet.getInt(\u0026#34;id\u0026#34;));\rresultUser.setUserName(resultSet.getString(\u0026#34;userName\u0026#34;));\rresultUser.setPassword(resultSet.getString(\u0026#34;password\u0026#34;));\r}\rreturn resultUser;\r}\r  步骤总结：\n  其中 SQL 语句中的要查找的值要用?代替，方便后面设置\nString sql = \u0026quot;select * from table_user where userName=? and password=?\u0026quot;;\n  然后创建 SQL 语句的游标对象\npsmt，PreparedStatement psmt = connection.prepareStatement(sql);\n  设置 SQL 语句中的变量值，第几个?为几，索引就是几，没有 0\npsmt.setString(1, user.getUserName());\n  执行查询语句，并返回ResultSet对象用于保存查询结果\nResultSet resultSet = psmt.executeQuery();\n  然后根据需求进行其他操作\n  BookDao类的设计如下，dao包下的其他类类似\n添加图书\n1 2 3 4 5 6 7 8 9 10 11  public static int add(Connection connection, Book book) throws SQLException {\rString sql = \u0026#34;insert into book values(null,?,?,?,?,?,?)\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setInt(4, book.getBooktypeid());\rpsmt.setString(5, book.getBookdesc());\rpsmt.setFloat(6, book.getPrice());\rreturn psmt.executeUpdate();\r}\r  添加成功返回 1，添加失败返回 0\n删除图书\n1 2 3 4 5 6  public static int delete(Connection conn, String id) throws SQLException {\rString sql = \u0026#34;delete from book where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, id);\rreturn psmt.executeUpdate();\r}\r  删除成功返回 1，删除失败返回 0\n修改图书\n1 2 3 4 5 6 7 8 9 10 11 12  public static int update(Connection conn, Book book) throws SQLException {\rString sql = \u0026#34;update book set bookName=?,author=?,sex=?,price=?,bookTypeid=?,bookDesc=? where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setFloat(4, book.getPrice());\rpsmt.setInt(5, book.getBooktypeid());\rpsmt.setString(6, book.getBookdesc());\rpsmt.setInt(7, book.getId());\rreturn psmt.executeUpdate();\r}\r  修改成功返回 1，修改失败返回 0\n查询图书\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static ResultSet list(Connection conn, Book book) throws SQLException {\rStringBuffer sb = new StringBuffer(\u0026#34;select * from book b,table_booktype bt where b.bookTypeId=bt.id\u0026#34;);\rif (!StringUtil.isEmpty(book.getBookname())) {\rsb.append(\u0026#34; and b.bookName like \u0026#39;%\u0026#34; + book.getBookname() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (!StringUtil.isEmpty(book.getAuthor())) {\rsb.append(\u0026#34; and b.author like \u0026#39;%\u0026#34; + book.getAuthor() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (book.getBooktypeid() != null \u0026amp;\u0026amp; book.getBooktypeid() != -1) {\rsb.append(\u0026#34; and b.bookTypeId=\u0026#34; + book.getBooktypeid());\r}\rPreparedStatement psmt = conn.prepareStatement(sb.toString());\rreturn psmt.executeQuery();\r}\r  返回查询结果\nview包 视图层是利用的 swing 组件设计，但这个不是本项目的重点，因为 Java 的 swing 已经很少有人用了，可以直接使用 idea 中的JFormDesigner插件进行拖拉控件，使用时一定要注意将框架的布局类型设为null Layout，大小设为Design size\n我们只需设计按钮和表格的触发事件\n例如图书添加事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  private void button1ActionPerformed(ActionEvent e) {\rString bookName = this.booknameTXT.getText();\rString author = this.bookAuthorTXT.getText();\rString price = this.bookPriceTXT.getText();\rString bookDesc = this.bookDescTXT.getText();\rif (StringUtil.isEmpty(bookName)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书名称不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(author)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书作者不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(price)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格不能为空\u0026#34;);\rreturn;\r}\rtry {\rfloat pricef = Float.parseFloat(price);\r} catch (NumberFormatException numberFormatException) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格应为数字\u0026#34;);\rreturn;\r}\rString sex = \u0026#34;\u0026#34;;\rif (this.man.isSelected()) {\rsex = \u0026#34;男\u0026#34;;\r} else {\rsex = \u0026#34;女\u0026#34;;\r}\rBooktype booktype = (Booktype) this.booktypecb.getSelectedItem();\rassert booktype != null;\rint booktypeId = booktype.getId();\rBook book = new Book(bookName, author, sex, Float.parseFloat(price), booktypeId, bookDesc);\rConnection conn = null;\rtry {\rconn = dbUtil.getConnection();\rint addNum = BookDao.add(conn, book);\rif (addNum == 1) {\rJOptionPane.showMessageDialog(null, \u0026#34;添加成功\u0026#34;);\rresetValue();\r} else {\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r}\r} catch (Exception ex) {\rex.printStackTrace();\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r} finally {\rtry {\rconn.close();\r} catch (SQLException ex) {\rex.printStackTrace();\r}\r}\r}\r  设计思想：\n 判断必需的输入框是否为空，以及类型是否一致 获取各输入框的数据 根据数据实例化对象 调用dao包中对应的方法进行操作  其他的删除，修改，查询的操作思想基本和添加的方法一样\n项目总结 项目中使用到了 Java 的 swing 技术，但是现在已经很少有人会用 Java 去写软件界面了，Java 不能像 C#那样拖拉控件设计界面，但是可以在 idea 中安装JFormDesigner插件实现 C#那样的效果了。\n MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。\n MVC 即围绕着数据库进行操作，本项目只是简单地实现了对数据库的增删改查，比较适合新手练习。\n","description":"推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql用到的知识：Java，MySQL工具：IDEA源码已上传至码云点击查看预览效果","id":8,"section":"posts","tags":["java","mysql"],"title":"简易的图书管理系统(Java+MySQL8.0)","uri":"https://eternidad33.github.io/zh/posts/%E7%AE%80%E6%98%93%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fjava+mysql8.0/"},{"content":"小程序基本架构 基本架构 利用 app.json文件对小程序进行全局配置\n利用同名.json文件对本页面窗口表现进行配置\n全局配置\n   属性 类型 必填 描述     pages string 是 页面路径列表   window Object 否 全局的默认窗口表现   tabBar Object 否 底部 tab 栏的表现   networkTimeout object 否 网络超时时间    Pages 配置\npages 用于指定小程序由哪些页面组成，每一项都对应一个页面的路径（含文件名）信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的.json，.js，.wxml，.wxss四个文件进行处理。数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。\nWindow 配置\n   属性 类型 描述     navigationBarBackground Color HexColor 导航栏背景颜色，如#000000   navigationBarTextStyle string 导航栏标题颜色，仅支持 black/ white   navigationBarTitleText string 导航栏标题文字内容   backgroundColor HexColor 窗口的背景色    tabBar 配置\n   属性 类型 描述     color HexColor tab 上的文字的默认颜色   selectedColor HexColor tab 上选中文字的颜色   backgroundColor HexColor tab 的背景色   borderStyle string tabbar 上边框的颜色，仅支持 black / white    list 配置\n   属性 类型 必填 说明     pagePath string 是 页面路径，必须在 pages 中先定义   text string 是 tab 上按钮文字   iconPath string 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px*81px，不支持网络图片   selectedIconPath string 否 选中时的图片路径    执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13  //app.js\rApp({\r//\r onLaunch: function() {\rconsole.log(\u0026#34;【app.js】小程序初始化\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【app.js】小程序显示\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【app.js】小程序隐藏\u0026#34;);\r}\r});\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //index.js\rPage({\ronLoad: function() {\rconsole.log(\u0026#34;【index.js】onLoad页面加载\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【index.js】onShow页面显示\u0026#34;);\r},\ronReady: function() {\rconsole.log(\u0026#34;【index.js】onRead页面渲染\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【index.js】onHide页面隐藏\u0026#34;);\r},\ronUnload: function() {\rconsole.log(\u0026#34;【index.js】onUnLoad页面卸载\u0026#34;);\r}\r});\r  显示效果：\n小程序整个生命周期的执行基本顺序是：\n","description":"小程序基本架构 基本架构 利用 `app.json`文件对小程序进行全局配置 利用同名`.json`文件对本页面窗口表现进行配置","id":9,"section":"posts","tags":null,"title":"小程序基本架构","uri":"https://eternidad33.github.io/zh/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"},{"content":"作为一个学习计算机相关知识的人，如果不经常写博客，就容易把刚学到的知识忘记，写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用 Markdown，这样可以很好地使我们的博客页面变得更加美观，这篇文章介绍的就是一些使用的 Markdown 使用技巧。\n推荐工具：Typora，VScode(插件Markdown-preview-enhanced)\n段落格式 字体设置 Markdown 代码\n1  \u0026lt;font size=10 face=\u0026#34;隶书\u0026#34; color=#ff0000\u0026gt;红色 10 号隶书\u0026lt;/font\u0026gt;   运行结果：\n红色 10 号隶书\n粗斜体   用*表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  用下划线表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  下划线 Markdown 代码：\n1  \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt;   显示结果为：\n带下划线文本\n删除线 Markdown 代码：\n1  ~~删除线~~   显示结果为：\n删除线\n脚注格式 Markdown 代码：\n1 2  创建脚注格式是这样的 [^lorem]。 [^lorem]: Lorem ipsum dolor.   显示结果为：\n创建脚注格式是这样的 1。\n引用格式 嵌套结构 Markdown 代码：\n1 2 3 4 5  \u0026gt; 最外层 \u0026gt; \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; 第二层嵌套   显示结果：\n 最外层\n 第一层嵌套\n 第二层嵌套\n   引用中使用列表 Markdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026gt; 引用中使用列表 \u0026gt; \u0026gt; 1. 有序列表第一项 \u0026gt; 2. 有序列表第二项 \u0026gt; 3. 有序列表第三项 \u0026gt; \u0026gt; - 无序列表第一项 \u0026gt; - 无序列表第二项 \u0026gt; - 无序列表第三项   显示结果：\n 引用中使用列表\n 有序列表第一项 有序列表第二项 有序列表第三项   无序列表第一项 无序列表第二项 无序列表第三项   列表项中的引用 Markdown 代码：\n1 2 3 4 5  1. 第一项 \u0026gt; 第一行引用 \u0026gt; 第二行引用 2. 第二项 3. 第三项   显示结果：\n 第一项  第一行引用\n第二行引用\n  第二项 第三项  代码格式 行内代码 Markdown 代码：\n1  Python 代码`print(\u0026#39;helloworld\u0026#39;)`，控制台打印 helloworld   显示结果：\nPython 代码print('helloworld')，控制台打印 helloworld\n代码块  按 Tab 键或四个空格 用```包括起来，第一个后面加上代码语言，可以高亮显示  图片样式  直接放置图片\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png)   显示结果：\n 鼠标悬浮时，显示名称\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png \u0026#34;戴帽子的犬夜叉\u0026#34;)   显示结果：\n 使用 img 标签定义图片的宽高\nMarkdown 代码： 1  \u0026lt;img src=\u0026#39;https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png\u0026#39; width=50% height=50%\u0026gt;   显示结果：\n  链接样式   直接写\nMarkdown 代码：\n1  [百度一下，你就知道](https://www.baidu.com)   显示结果：\n百度一下，你就知道\n  链接用 a 作为网址变量,然后为变量赋值\nMarkdown 代码：\n1 2  [百度一下，你就知道][a] [a]: https://www.baidu.com   显示结果：\n百度一下，你就知道\n  表格样式 Markdown 代码：\n1 2 3 4  | 左对齐 | 居中对齐 | 右对齐 | | :----- | :------: | -----: | | 1 | 2 | 3 | | 4 | 5 | 6 |   显示结果：\n| 左对齐 | 居中对齐 | 右对齐 |\n| :\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;: | \u0026mdash;\u0026ndash;: |\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n支持的 HTML 标签 Markdown 支持很多 HTML 标签,下面列举几个常用的标签\nMarkdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026lt;kbd\u0026gt;Win\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Prtsc\u0026lt;/kbd\u0026gt; 快速截图 \u0026lt;em\u0026gt;强调\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;加强强调\u0026lt;/strong\u0026gt; \u0026lt;b\u0026gt;加粗\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;倾斜\u0026lt;/i\u0026gt; 上标如，3\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; 下标，如 CO\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; 换行符\u0026lt;br\u0026gt; 分割线\u0026lt;hr\u0026gt;   显示结果：\nWin+Prtsc 快速截图\n强调\n加强强调\n加粗\n倾斜\n上标如，32\n下标，如 CO2\n换行符\n分割线\n转义字符 以下这些符号前面加上反斜杠\\来帮助插入普通的符号：\n\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号  特殊符号    符号 代码     © \u0026amp;copy;   ™ \u0026amp;trade;   \u0026amp; \u0026amp;amp;   \u0026lt; \u0026amp;lt;   \u0026gt; \u0026amp;gt;   £ \u0026amp;pound;   ¥ \u0026amp;yen;   € \u0026amp;euro;   ® \u0026amp;reg;   ± \u0026amp;plusmn;   § \u0026amp;sect;   X² X\u0026amp;sup2;   Y³ Y\u0026amp;sup3;   ¾ \u0026amp;frac34;   « \u0026amp;laquo;   » \u0026amp;raquo;   37ºC 37\u0026amp;ordm;C     Lorem ipsum dolor. \u0026#x21a9;\u0026#xfe0e;\n   ","description":"写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用Markdown","id":10,"section":"posts","tags":["markdown"],"title":"用Markdown代码写出好看的页面","uri":"https://eternidad33.github.io/zh/posts/%E7%94%A8markdown%E4%BB%A3%E7%A0%81%E5%86%99%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E9%A1%B5%E9%9D%A2/"},{"content":"开发工具 IDEA 从入门到爱不释手-课程笔记 1-1 代码生成 Generate  Alt+Insert,或者右键-Generate：生成 getter 或 setter  1-2 高效的代码编辑技能    快捷键 功能     Ctrl+Alt+L 格式化   Ctrl+D 复制光标所在行   Alt+Shift+上/下 移动所在行或所选行    1-3 Demo 项目介绍 分层结构\n Config：所有的配置 Controller：请求入口 Service：逻辑层 Mapper：持久层 Domain(Po)：表映射实体 Dto：数据传输对象  1-4 git 更多操作 顶部添加 git 提交选项\n1-5 快速查找和替换    快捷键 功能     Ctrl+F 查找   Ctrl+R 替换   Ctrl+Shift+F 全局查找   Ctrl+Shift+R 全局替换   Ctrl+Shift+N 查找文件   Ctrl+Shift+A 查找所有的菜单或操作   双击 shift 万能查找    2-1 代码模板  psvm：生成主函数 sout：System.out.println(); fori：for 循环 fore：foreach 循环 Live Templates postfix：先打变量或表达式，再打快捷键  2-2 代码重构 Refactor    快捷键 功能     Shift+F6 代码重命名   Ctrl+Alt+V 自动生成返回值   Alt+Delete 安全删除   F5 文件复制粘贴     一个方法只负责实现一个功能  2-3 快速跳转    快捷键 功能     Ctrl+左/右 跳过一个单词   Ctrl+G 快速跳转到指定行   Alt+左/右 左右切换 Tabs   Ctrl+E 查看最近浏览过的文件    3-1 更多实用技巧  Ctrl+Alt+Shift+J ：选中文件中所有和被选中的代码一样的代码  ","description":"推荐几个比较好用的插件 图片背景`Background Image Plus` 彩虹括号`Rainbow Brackets` 主题`Material Theme ul` 记录编码时长`wakatime` 统计项目代码行数`Statistic`","id":11,"section":"posts","tags":["idea"],"title":"idea使用技巧总结","uri":"https://eternidad33.github.io/zh/posts/idea%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"content":"m10c 主题配置 主题地址：GitHub 仓库地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  title = \u0026#34;Vigilr的博客\u0026#34;\r[params]\rdescription = \u0026#34;宁为玉碎，不为瓦全\u0026#34;\ravatar = \u0026#34;avatar.jpg\u0026#34;\r[[params.social]]\rname = \u0026#34;github\u0026#34;\rurl = \u0026#34;https://github.com/eternidad33\u0026#34;\r[[params.social]]\rname = \u0026#34;mail\u0026#34;\rurl = \u0026#34;mailto:3496655347@qq.com\u0026#34;\r[[params.social]]\rname = \u0026#34;link\u0026#34;\rurl = \u0026#34;https://blog.csdn.net/qq_42907802\u0026#34;\r  主题仓库要下载到站点目录/themes下\n文章目录为：站点目录/content/posts\n头像的路径：站点目录/static/avatar.jpg\n只是简单地设计了几个链接，链接的图标在主题目录/data/m10c/icons.json文件中定义\n博客启动：hugo server -t hugo-theme-m10c -D\n浏览器访问:http://localhost:1313/\n至此博客启动成功\n","description":"m10c是一款比较简洁的主题，而且容易配置","id":12,"section":"posts","tags":["hugo","theme"],"title":"m10c主题配置","uri":"https://eternidad33.github.io/zh/posts/m10c%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"content":"Hugo 博客搭建 本地部署 推荐视频：手把手教你从 0 开始搭建自己的个人博客 |第二种姿势 | hugo\n  下载 Hugo，下载地址：GitHub\n  配置环境变量\n  创建自己的站点文件夹hugo new site myHugoSite\n生成的目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  PS C:\\Users\\Administrator\\Desktop\\myHogoSite\u0026gt; tree /f\r文件夹 PATH 列表\r卷序列号为 2A8A-01A5\rC:.\r│ config.toml\r│\r├─archetypes\r│ default.md\r │\r├─content\r├─data\r├─layouts\r├─static\r└─themes\r    新建文章\n在 content 目录下生成博客hugo new 我的第一篇博客.md\n在 content/posts 目录下生成博客hugo new posts/我的第二篇博客.md\n  下载m10c 主题并配置\n  部署到 GitHub  创建远程仓库,仓库名必须为用户名.github.io 生成 public 文件夹hugo -t 主题名 -b https://用户名.github.io -D 然后就是一系列 git 操作 进入 public，初始化 git 仓库 添加到暂存区 提交仓库 连接远程仓库 推送到远程仓库  不清楚的命令可以通过hugo help查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  $ hugo help\rhugo is the main command, used to build your Hugo site.\rHugo is a Fast and Flexible Static Site Generator\rbuilt with love by spf13 and friends in Go.\rComplete documentation is available at http://gohugo.io/.\rUsage:\rhugo [flags]\rhugo [command]\rAvailable Commands:\rconfig Print the site configuration\rconvert Convert your content to different formats\rdeploy Deploy your site to a Cloud provider.\renv Print Hugo version and environment info\rgen A collection of several useful generators.\rhelp Help about any command\rimport Import your site from others.\rlist Listing out various types of content\rmod Various Hugo Modules helpers.\rnew Create new content for your site\rserver A high performance webserver\rversion Print the version number of Hugo\rFlags:\r-b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/\r--templateMetrics display metrics about template executions\r--templateMetricsHints calculate some improvement hints when combined with --templateMetrics\r-t, --theme strings themes to use (located in /themes/THEMENAME/)\r--themesDir string filesystem path to themes directory\r--trace file write trace to file (not useful in general)\r-v, --verbose verbose output\r--verboseLog verbose logging\r-w, --watch watch filesystem for changes and recreate as needed\rAdditional help topics:\rhugo check Contains some verification checks\rUse \u0026#34;hugo [command] --help\u0026#34; for more information about a command.\r  ","description":"本文介绍如何搭建Hugo个人博客","id":13,"section":"posts","tags":["hugo"],"title":"Hugo博客搭建","uri":"https://eternidad33.github.io/zh/posts/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"推荐书籍：\n 《Java 编程的逻辑》 《疯狂 Java 讲义精粹》  Java 基础 从当前所在路径加载类SET ClASSPATH=.\nPATH：是操作系统提供的路径配置，定义所有可执行程序的路径\nCLASSPATH：是由 JRE 提供的，用于定义 Java 程序解释时类加载路径CLASSPATH=路径的命令形式来进行定义；\nJava 1.9 之后才有的Jshell\nint的取值范围为-2147483648 到 2147483647\n大写字母范围：A(65)~Z(90)\n小写字母范围：a(97)~z(122)\n数值范围：\u0026lsquo;0\u0026rsquo;(48)~'9\u0026rsquo;(57)\nthis关键字\nthis():调用无参的构造函数\nthis(name):调用参数为 name 的构造函数\nthis(\u0026hellip;):必须放在首行\nStatic 属性由类名直接调用\nstatic 方法只允许调用 static 属性或 static 方法\n非 static 方法允许调用 static 属性或 static 方法\nstatic 的定义的方法或属性都不是代码编写之初所需要考虑的内容，只有在回避实例化对象描述公共属性的情况下才会考虑 static 定义的属性或者是方法\n静态代码块最先执行，而且只会执行一次，用于对静态属性的初始化，构造块会优于构造方法先执行\n数组 int数组初始化默认为 0\n必须实例化数组才能使用数组下标\nforeach循环可以避免使用下标，\nforeach遍历二维数组\n返回数组的方法\n将数组封装成一个组件\n数组快速排序\n数组逆序\n数组相关的类库\n数组排序可以这样写java.util.Arrays.sort(data);\n系统自带的数组拷贝System.arraycopy(dataA,5,dataB,5,3);是将数组dataA中从索引为 5，长度为 3 的一段数组复制到dataB中索引位置为 5 的地方，并替换掉相应长度\n可变参数\n在方法参数列表中...表示可变参数\n可变参数的作用在于，在以后进行一些程序设计或者开发者调用的时候，利用此种形式可以避免数组的传递操作\n对象数组定义格式如下：\n 动态初始化：类 对象数组名称[]=new 类[长度]，每一个元素的内容都是 null 静态初始化：类 对象数组名称[]=new 类[]{实例化对象，实例化对象，实例化对象\u0026hellip;}  String java 源代码目录:C:\\Program Files (x86)\\Java\\jdk-9\\lib\\src.zip\nJDK 1.8 及以前的 String 支持类\nJDK 1.9 的 String 支持类\nJDK 1.8 及以前 String 类保存的是字符数组\nJDK 1.9 及以后 String 类保存的是字节数组\nString 对象的比较\n直接为字符串赋值会是字符串变量指向字符串池中的内存地址\nnew String()会开辟新的内存\n将所有小写字母转换成大写\n先将字符串转换成字符数组，然后每个字符的编码-32\n判断是否全为数字\n先将字符串转换成字符数组，if (result[i] \u0026lt; '0' || result[i] \u0026gt; '9')\n然后挨个判断每个字符\n字符串的比较\nstr.equals(str1)区分大小写比较\nstr.equalsIgnoreCase(str1)不区分大小写比较\nstr.compareTo(str1)字符串的大小的比较\nstr.compareToIgnoreCase(str1)忽略大小写的字符串大小比较\n字符串的查找\nstr.contains(\u0026quot;hello\u0026quot;)判断字符串中是否含有 hello\nstr.indexOf(\u0026quot;Java\u0026quot;)查询 Java 是否存在于 str 中，存在返回首字母索引位置，不存在返回-1\nstr.lastIndexOf(\u0026quot;Java\u0026quot;)从后向前查询\nstr2.endsWith(\u0026quot;com\u0026quot;)判断是否以 com 结尾\nstr2.startsWith(\u0026quot;www\u0026quot;)判断是否以 www 开头\n字符串的替换\nstr.replaceAll(\u0026quot;Java\u0026quot;, \u0026quot;Python\u0026quot;)将全部的 Java 替换成 Python\nstr.replaceFirst(\u0026quot;Java\u0026quot;, \u0026quot;Python\u0026quot;)将第一个 Java 替换成 Python\n字符串的拆分\nstr.split(\u0026quot; \u0026quot;)以空格全部拆分，返回字符串数组\nstr.split(\u0026quot; \u0026quot;,2)以空格拆分成 2 个，返回字符串数组\nstr1.split(\u0026quot;\\\\.\u0026quot;)拆不开的情况要用\u0026rdquo;\\\u0026ldquo;进行转义\n字符串的截取\nstr.substring(startIndex,endIndex)截取str从startIndex到endIndex的字符串片段\n字符串的格式化\nformat 是一个静态方法,直接通过String 类调用String.format(\u0026quot;姓名：%s，年龄：%d，分数：%5.2f\u0026quot;,name,age,score)\n其他字符串相关的方法\nstr.concat(str2)字符串的连接\nstr.isEmpty()判断字符串内容是否为空\nstr.trim()去掉字符串中所有空格\nstr.toUpperCase()全部转换成大写\n(str.toLowerCase()全部转换成小写\n面向对象 继承 public class object.Student extends object.PersonStudent 类继承 Person 所有共有的属性和方法\n子类被实例化时先调用父类的构造方法\nsuper(...)必须放在首行，this(...)也必须放在首行，所以两者不可同时出现\n多层继承\n理论上层数最多不能超过三层\n 父类的私有方法不存在覆写 子类调用有父类覆写的方法要加 super     Overloading Override     重载 覆写   方法名称相同，参数的类型及个数不同 方法名称，参数类型及个数，返回值相同   没有权限限制 被覆写方法不能拥有更严格的控制权限   发生在一个类中 发生在继承关系类中     在程序类中使用 this 表示先从本类查找所需要的的属性或方法，如果本类中不存在则查找父类定义，如果使用 super 则不查找子类，直接查找父类\n fanal 代表不能被覆写的方法，常量\nAnnotation 注解\n@Override准确覆写\n@Deprecated 代表过时的类或方法\n@SuppressWarnings 压制警告\n多态 向上转型base f = new son()可以调用父类的方法和子类中重写父类的方法\n向下转型son1 s=(son)f不安全\ninstanceof\ninstanceof为了保证向下转型的正确性，用于在转型之前进行判断，判断某个实例是否是某个类的对象\nObject 类 Object 类是所有类型的父类，所以 Object 类可以接收所有子类的对象\ntoString()是 Object 自带的方法，所有继承类都可以使用\n 对象比较 equals() 判断对象是否为 null 判断是不是同一地址 判断 obj 是否转换为 person 判断内容是否相同  抽象类 抽象方法所在的类必须为抽象类，抽象类必须用abstract关键字来定义\n抽象类就是在普通类上追加了抽象方法\n抽象类是无法被实例化的\n 抽象类必须提供子类 抽象类的子类（非抽象类）一定要覆写抽象类中的全部抽象方法 抽象类的对象实例化可以通过子类向上转型的方式完成   抽象类自己无法直接实例化\n final不允许有子类，abstract必须有子类\n 抽象类中可以使用普通方法调用抽象方法\n 包装类 Int temp = new Int(10);装箱，将基本数据类型保存在包装类中\nint x = temp.intValue();拆箱，从包装类中获取基本数据类型\n 对象型的包装类，Boolen,Character 数值型的包装类,Byte,Short,Integer,Long,Float,Double  基本的装箱与拆箱操作\njdk1.5 之后可以实现自动装箱与拆箱操作，包装类可以直接参与数学运算\n接口 接口的组成以抽象方法和全局常量为主，使用关键字interface定义，接口的名称通常首字母加上I\n 接口需要被子类实现，关键字implements，一个子类可以实现多个接口 子类（非抽象类）必须覆写接口中的全部抽象方法 接口对象可以通过子类对象的向上转型实例化  接口的主要目的是一个子类可以实现多个接口\n接口不允许继承父类\n Object 类对象可以接收所有的数据类型，包括基本数据类型，类对象，接口对象，数组…\n方法不写访问权限也是public，不是default\n 接口可以通过extends集成多个父接口\n接口的使用：\n 进行标准设置 表示一种操作的能力 暴露远程方法视图  JDK1.8 之前，在进行设计时，一般子类不直接继承接口，中间加一个过渡抽象类\n接口的方法加上public default代表普通方法\n设计模式 代理设计模式\n一个接口提供两个子类，其中一个是真实业务操作类，另一个是代理业务操作类\n接口与抽象类的比较\n   接口 抽象类     interface 接口名称{} abstract class 抽象类名称{}   抽象方法，全局常量，普通方法，静态方法 构造，普通方法，静态方法，全局变量，成员   只有 public 权限 可以使用各类权限   子类通过implements关键字可以继承多个接口 子类通过extends关键字继承一个抽象类   接口不允许结成抽象类，可以继承多个父接口 抽象类可以实现若干个接口    使用时的共同点\n 抽象类或接口必须定义子类 子类必须覆写抽象类或接口的全部抽象方法 通过子类的向上转型实现抽象类或接口的对象实例化  单例设计\n懒汉式\n在第一次使用时进行实例化处理\n饿汉式\n在系统加载类时，实例化对象\n多例设计\n单例设计是指只保留一个实例化对象，多例设计是指保留多个实例化对象\n单例设计和多例设计的本质是相同的，一定都会在内部提供有static方法以返回实例化对象。都要进行构造方法私有化\n泛型 基本数据类型 → 包装类型 →Object类\n向上转型成Object类，容易出现ClassCastException异常\n  泛型之中只允许设置引用类型，如果要操作基本类型必须使用包装类 泛型对象实例化对象可以简化为Point\u0026lt;Integer\u0026gt; p1=new Point\u0026lt;\u0026gt;();   通配符\u0026lt;?\u0026gt;可以使泛型对象在方法中不被改变\n\u0026lt;T extends 类\u0026gt;:设置泛型的上限\n\u0026lt;T super 类\u0026gt;:设置泛型的下限\n泛型接口\n子类实现泛型接口两种方式：\n  在子类之中继续设置泛型定义\n  子类实现父接口是直接定义泛型类型\n  泛型方法\n泛型方法不一定出现在泛型类之中\n工厂模式中使用泛型方法\n包 同一个目录下不能有同名的程序文件，要创建不同的目录，不同的的目录就是不同的包\njavac -d . hello.java\n-d:表示要生成目录，目录为package定义的结构\n.:表示从当前目录开始生成\n类的名称：包.类名称\nimport util.Message;导入其他包的类\n当导入的几个包中出现重名的类时，定义类要用完整的类名称Message msg=new util.Message();。\n静态导入\nimport static util.Math.*;静态导入后可以直接使用util.Math中的方法\nJar\n想用javac编译，然后用jar打包\njar -cvf \u0026quot;名称.jar\u0026quot; 文件夹\n-c创建一个新的jar文件\n-v得到一个详细输出\n-f设置生成的Jar文件名称\n系统常见包\njava.lang包括 String，Number，Object 等\njava.lang.reflect反射机制处理包\njava.util工具类的定义，包括数据结构的定义\njava.io进行输入与输出流操作的包\njava.net网络程序开发的程序包\njava.sql进行数据库编程的开发包\njava.awt和java.swingJava 的图形界面开发包，awt 是重量级的组件，swing 是轻量级的组件\n访问控制权限\n面向对象的三个主要特点：封装，继承，多态\n   访问范围 private default protected public     同一包中的同一类 √ √ √ √   同一包中的不同类  √ √ √   不同包的子类   √ √   不同包的所有类    √    UML UML 是统一的建模语言，本质是利用图形化的形式来实现程序类关系的描述\n类图\n类一般用三层结构来显示\n   类名称     属性   方法    抽象类一般用斜体表示，也可以加上abstract\n属性的格式为访问权限 属性名称：属性类型\n访问权限的表示符为 public(+),private(-),protected(#)\n方法的格式为访问权限 方法名称():返回值结构\n子类实现接口用\u0026quot;三角和虚线\u0026rdquo;,类的继承用\u0026quot;三角和实线\u0026rdquo;,由子类指向父类\n时序图\n时序图用于描述代码的执行流程\n用例图\n用例图用于描述程序的执行分配\n枚举 枚举主要作用于定义有限个数对象的一种结构（多例设计），通过enum定义枚举类\n遍历枚举\nc.ordinal():c 在枚举类中的序号\nc.name():c 的值\n enum:是从 JDK1.5 之后提供的一个关键字，用来定义枚举类 Enum：是一个抽象类，所有使用enum关键字定义的类，默认继承此类  异常 处理异常的三种组合：try...catch，try...catch...finally，try...finally\n通过e.printStackTrace();获取完整的异常信息\n异常处理流程\n 产生异常，自动产生异常的实例化对象 如果不处理异常，JVM 默认打印异常信息，然后退出程序 如果存在异常处理，异常实例化对象将会被try语句捕获 catch匹配异常 执行finally  处理异常最大的类型是Throwable，有两个子类\n Error:此时程序还未执行出现的错误，开发者无法处理 Exception:程序中出现的异常  在多个异常处理的时候要将捕获范围大的异常放在捕获范围小的异常后面\n通过throws抛出异常\nthrow手动抛出异常\nthrow和throws的区别\n throw是在代码块中使用的，主要是手工对异常对象的抛出 throws是在方法定义上使用的，表示将此方法中可能产生的异常明确告诉给调用处，由调用处进行处理  RuntimeException是Exception的子类\n常见的RuntimeException： NullPointerException，ClassCastException，IndexOutOfBoundsException\n内部类 内部类的优点是可以轻松地访问外部类的私有属性，缺陷是破坏了类的结构\n内部类和外部类之间的操作不需要setter和getter，内部类实例化对象的格式外部类.内部类 内部类对象=new 外部类().new 内部类;\n如果Inner类加上private属性，则Inner无法在外部进行使用\nstatic的类和方法只能访问外部类的static的属性或方法.\nstatic定义的内部类并不常用，static定义内部接口更常用\n在方法中定义内部类\n方法中的内部类既能访问方法中的参数，又能访问外部类的私有成员属性。对于方法中参数的访问是从 JDK1.8 开始支持的。\n匿名内部类的使用\n 往往使用静态方法做一个内部的匿名内部类\n 匿名内部类只是一个没有名字的只能够使用一次的，并且结构固定的一个子类\n函数式编程 从 JDK1.8 开始提供有Lambda表达式的支持\nLambda表达式使用时有一个重要的实现要求就是 SAM(Single Abstract Method)只有一个抽象方法,该接口被称为函数式接口\nLambda 表达式的三种格式：\n 没有参数：()-\u0026gt;{}; 有参数：(参数,参数)-\u0026gt;{}; 只有一条返回语句(参数,参数)-\u0026gt;语句;  对方法的引用\n  引用静态方法：类名称::static 方法名称;\nIFunction\u0026lt;String, Integer\u0026gt; fun = String::valueOf;\n  引用某个实例对象的方法：实例化对象::普通方法;\nIFunction fun=\u0026quot;hellojava\u0026quot;::toUpperCase;\n  引用特定类型的方法：特定类::普通方法;\nIFunction\u0026lt;String\u0026gt; fun=String::compareTo;\n  引用构造方法：类名称::new\nIFunction\u0026lt;Person\u0026gt; fun=Person::new;\n  在java.util.funtion包中可以直接使用函数式接口\n  功能性函数式接口\n1 2  Function\u0026lt;String,Boolean\u0026gt; fun=\u0026#34;hellojava\u0026#34;::startsWith;\rSystem.out.println(fun.apply(\u0026#34;hello\u0026#34;));\r    消费型函数式接口:只能进行数据的处理，没有任何的返回\n1 2  Consumer\u0026lt;String\u0026gt; fun=System.out::println;\rfun.accept(\u0026#34;HelloJava\u0026#34;);\r    供给型函数式接口\n1 2  Supplier\u0026lt;String\u0026gt; fun=\u0026#34;hellojava\u0026#34;::toUpperCase;\rSystem.out.println(fun.get());\r    断言型函数式接口\n1 2  Predicate\u0026lt;String\u0026gt; fun=\u0026#34;hello\u0026#34;::equals;\rSystem.out.println(fun.test(\u0026#34;hello\u0026#34;));\r    链表 由于数组的长度是固定的，所以要引入链表\n链表节点的增加\n 判断增加的节点是否为空 判断根节点是否为空 添加节点  Link 类只负责数据的操作与根节点的处理而所有后续节点的处理全部都是有 Node 类负责。\n获取链表元素的个数\n  在ILink接口中增加size()方法\n  在LinkImpl中重写size()方法\n  在LinkImpl中增加私有属性count,然后在add(E e)加上this.count++;语句\n  判断链表是否为空\n既可以判断根节点是否为空，也可以判断长度是否为 0\n返回链表数据\n  在ILink接口中追加public Object[] toArray();方法\n  在LinkImpl中加上两个属性\n  在Node中递归获取数据\n  在LinkImpl中重写public Object[] toArray();方法\n  链表数据的返回是以数组的形式返回\n根据索引获取数据\n  ILink加上public E get(int index);\n  在Node中定义public E getNode(int index)\n  在LinkImpl中重写public E get(int index)\n  修改指定索引的数据\n 在ILink加上public void set(int index,E value); 在Node中定义public void setNode(int index,E value) 在LinkImpl中重写public void set(int index, E value)  判断指定数据是否存在\n 在ILink加上public boolean contains(E data) 在Node中定义public boolean containsNode(E data) 在LinkImpl中重写public boolean contains(E data)  数据删除\n 在ILink中加上public void remove(E data) 在LinkImpl中判断要删除的元素是否为根节点 如果不是根节点，在Node中定义删除节点 在LinkImpl中完善public void remove(E data)方法  数据清除\n 在ILink中追加public void clean();方法 在LinkImpl中重写public void clean()  AWT   AWT 界面组件：包括窗口、对话框、基本组件、菜单组件。 AWT 布局管理器：包括流式布局 FlowLayout、区域布局 BorderLayout、网格布局 GridLayout、卡片布局 CardLayout。 AWT 事件处理：事件授权模型、事件类型，监听器和适配器的使用。   AWT 的组件包括两大类：Component 和 MenuComponent，即组件与菜单栏\n类 java.awt.Component 是许多组件类的父类，Component 类中封装了组件通用的方法和属性，如图形的组件对象、大小、显示位置、前景色和背景色、边界、可见性等。\n一般我们要生成一个窗口，通常是用 Window 的子类 Frame 来进行实例化，而不是直接用到 Window 类\nPanel是一个容器，放在 Frame 组件内，可以用于包装一组组件。\n idea 中中文乱码设置VM option: -Dfile.encoding=GB18030\n 对话框Dialog\n创建文本对话框FileDialog\n基本组件\n 文本Label 按钮Button 复选框Checkbox 复选框组CheckboxGroup 下拉列表Choice 文本框TextField 文本区域TextArea 列表List 画布CAnvas  菜单组件\n 菜单栏MenuBar 菜单Menu 菜单选项MenuItem  AWT 布局管理器\n Frame 是一个顶级窗口。Frame 的默认布局管理器为BorderLayout。\nPanel 无法单独显示，必须添加到某个容器中。Panel 的默认布局管理器为 FlowLayout。\n当把 Panel 作为一个组件添加到某个容器中后，该 Panel 仍然可以有自己的布局管理器。因此，可以利用 Panel 使得BorderLayout中某个区域显示多个组件，达到设计复杂用户界面的目的。\n如果采用无布局管理器setLayout(null)，则必须使用setLocation()、setSize()、setBounds()等方法手工设置组件的大小和位置，此方法会导致平台相关，不鼓励使用。\n 流式布局 FlowLayout\nFlowLayout 是 Panel、Applet 的默认布局管理器。其组件的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个组件先添加到容器中第一行的最左边，后续的组件依次添加到上一个组件的右边，如果当前行已放置不下该组件，则放置到下一行的最左边。\nFlowLayout(FlowLayout.RIGHT,20,40);：第一个参数表示组件的对齐方式，指组件在这一行中的位置是居中对齐、居右对齐还是居左对齐，第二个参数是组件之间的横向间隔，第三个参数是组件之间的纵向间隔，单位是像素。\n区域布局 BorderLayout\nBorderLayout 是 Window、Frame 和 Dialog 的默认布局管理器。BorderLayout 布局管理器把容器分成 5 个区域：North、South、East、West 和 Center，每个区域只能放置一个组件。\n 不一定所有的区域都有组件，如果四周的区域（West、East、North、South 区域）没有组件，则由 Center 区域去补充，但是如果 Center 区域没有组件，则保持空白\n 网格布局 GridLayout\nGridLayout 使容器中各个组件呈网格状布局，平均占据容器的空间，创建该布局时需要指定网格的行数和列数，然后依次添加各个组件时，会按照先行后列的顺序依次添加。\n卡片布局 CardLayout\nCardLayout 卡片布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件，当然每层都可以利用 Panel 来实现复杂的用户界面。\nAWT 事件处理\n使用授权处理模型进行事件处理的一般方法归纳如下。\n  对于某种类型的事件 XXXEvent，要想接收并处理这类事件，必须定义相应的事件监听器类，该类需要实现与该事件相对应的接口 XXXListener。\n  事件源实例化以后，必须进行授权，注册该类事件的监听器，使用 addXXXListener(XXXListener )方法来注册监听器。\n  AWT 事件共有 10 类，可以归为两大类：低级事件和高级事件。\n低级事件是指基于组件和容器的事件，当一个组件上发生事件，如：鼠标的进入、单击、拖放等，或组件的窗口开关等，触发了组件事件。\n高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类，如在 TextField 中按 Enter 键会触发 ActionEvent 事件，滑动滚动条会触发 AdjustmentEvent 事件，或是选中项目列表的某一条就会触发 ItemEvent 事件。\n事件监听器\n每类事件都有对应的事件监听器，监听器是接口，根据动作来定义方法\n使用事件监听器：实现监听器接口、使用内部类和匿名类。\n使用事件适配器。\n多媒体处理\n 图像处理——java.awt.image 二维图像绘制——Java2D。 音频录制与播放——JavaSound。 视频拍照与播放——JMF。  正则表达式 基本语法\n 八进制表示的字符，以\\0开头，后跟 1 ～ 3 位数字 十六进制表示的字符，以\\x开头，后跟两位字符 Unicode 编号表示的字符，以\\u开头，后跟 4 位字符 点号字符.是一个元字符，默认模式下，它匹配除了换行符以外的任意字符 以(? s)开头，s 表示 single line，即单行匹配模式 为方便表示连续的多个字符，字符组中可以使用连字符\u0026rsquo;-\u0026rsquo; 字符组支持排除的概念，在[后紧跟一个字符^,只有在字符组的开头才是元字符，如果不在开头，就是普通字符，匹配它自身 \\d: d 表示 digit，匹配一个数字字符 \\w: w 表示 word，匹配一个单词字符 \\s: s 表示 space，匹配一个空白字符 \\D：匹配一个非数字字符 \\W：匹配一个非单词字符 \\S：匹配一个非空白字符  量词指的是指定出现次数的元字符：\n +：表示前面字符的一次或多次出现 \\*：表示前面字符的零次或多次出现 ? ：表示前面字符可能出现，也可能不出现 更为通用的表示出现次数的语法是{m, n}，出现次数从 m 到 n，包括 m 和 n，如果 n 没有限制，可以省略，如果 m 和 n 一样，可以写为{m} 使用懒惰量词，在量词的后面加一个符号? 表达式可以用括号()括起来，表示一个分组  特殊边界匹配\n 默认情况下，^匹配整个字符串的开始 默认情况下，$匹配整个字符串的结束 \\A与^类似，但不管什么模式，它匹配的总是整个字符串的开始边界。 \\Z和\\z与$类似，但不管什么模式，它们匹配的总是整个字符串的结束边界。 \\b匹配的是单词边界  环视边界匹配\n环视的字面意思就是左右看看，需要左右符合一些条件，本质上，它也是匹配边界，对边界有一些要求，这个要求是针对左边或右边的字符串的。\n 肯定顺序环视，语法是(? =...)，要求右边的字符串匹配指定的表达式。 否定顺序环视，语法是(? ! ...)，要求右边的字符串不能匹配指定的表达式。 肯定逆序环视，语法是(? \u0026lt;=...)，要求左边的字符串匹配指定的表达式。 否定逆序环视，语法是(? \u0026lt;! ...)，要求左边的字符串不能匹配指定的表达式。  这些环视结构也被称为断言，断言的对象是边界，边界不占用字符，没有宽度，所以也被称为零宽度断言。\nJava API\n正则表达式相关的类位于包 java.util.regex 下，有两个主要的类，一个是 Pattern，另一个是 Matcher\n  表示正则表达式\n在 Java 中，没有什么特殊的语法能直接表示正则表达式，需要用字符串表示，而在字符串中，''也是一个元字符，为了在字符串中表示正则表达式的\u0026rsquo;'，就需要使用两个\u0026rsquo;'，即\u0026rsquo;\\'，而要匹配\u0026rsquo;'本身，就需要 4 个\u0026rsquo;'，即\u0026rsquo;\\\\\u0026rsquo;\n三种匹配模式：单行模式（点号模式）、多行模式和大小写无关模式，它们对应的常量分别为：Pattern.DOTALL、Pattern.MULTILINE 和 Pattern.CASE_INSENSI-TIVE，多个模式可以一起使用，通过'|'连起来即可\n  切分\n  验证\n  查找\n  替换\n  List 集合 集合操作最常用的两种方法：add()，iterator()\npublic interface List\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt;\nCollection 的继承关系，如图：\nList 的三个常用子类：\n ArrayList LinkedList Vector  ArrayList\n继承关系\n1 2 3  public class ArrayList\u0026lt;E\u0026gt;\rextends AbstractList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, Serializable\r  LinkedList\n继承关系\n1 2 3  public class LinkedList\u0026lt;E\u0026gt;\rextends AbstractSequentialList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, Serializable\r  Vector\nVector 是一个古老的集合（从 JDK 1.0 就有了）\n继承关系\n1 2 3  public class Vector\u0026lt;E\u0026gt;\rextends AbstractList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, Serializable\r  Set 集合 Set 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add 方法返回 false，且新元素不会被加入。\nSet 判断两个对象相同不是使用==运算符，而是根据 equals 方法\nHashSet\nHashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。\nHashSet 不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或者两个以上线程同时修改了 HashSet 集合时，则必须通过代码来保证其同步。\nLinkedHashSet\nHashSet 还有一个子类 LinkedHashSet，LinkedHashSet 集合也是根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。\nTreeSet\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。\nTreeSet 并不是根据元素的插入顺序进行排序的，而是根据元素实际值的大小来进行排序的。\nEnumSet\nEnumSet 是一个专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式地指定。EnumSet 的集合元素也是有序的，EnumSet 以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。\nMap 集合 Map 用于保存具有映射关系的数据，因此 Map 集合里保存着两组值，一组值用于保存 Map 里的 key，另外一组值用于保存 Map 里的 value，key 和 value 都可以是任何引用类型的数据。\nMap 的继承关系，如图：\nHashMap和Hashtable都是 Map 接口的典型实现类，它们之间的关系完全类似于ArrayList和Vector的关系\n Hashtable 是一个线程安全的 Map 实现，但 HashMap 是线程不安全的实现\nHashtable 不允许使用 null 作为 key 和 value\n HashMap、Hashtable也不能保证其中 key-value 对的顺序。\nProperties类是Hashtable类的子类，正如它的名字所暗示的，该对象在处理属性文件时特别方便（Windows 操作平台上的 ini 文件就是一种属性文件）。\nTreeMap就是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap存储 key-value 对（节点）时，需要根据 key 对节点进行排序。\n ArrayList 和 Vector 的显著区别：ArrayList 是线程不安全的，当多个线程访问同一个 ArrayList 集合时，如果有超过一个线程修改了 ArrayList 集合，则程序必须手动保证该集合的同步性；但 Vector 集合则是线程安全的，无须程序保证该集合的同步性。\n Java 多线程编程 Java 是多线程的编程语言，有利于并发访问处理。\n继承Thread 类实现多线程\n多线程的执行的方法在run()中定义，\nstart()方法是并发执行\n每一个线程类对象只允许启动一次，如果重复启动，就会抛出异常\nRunnable接口的使用\n1 2  Thread th=new Thread(new MyThread(\u0026#34;线程1启动\u0026#34;));\rth.start();\r  Thread 与 Runnable 关系 Thread 用于实现 Runnable，如图所示：\n多线程的设计之中，使用了代理设计模式的结构，用户设计的线程主体负责项目核心功能，其他辅助功能由 Thread 类实现\n多线程开发的本质实质上是在于多个线程可以进行统一资源的抢占\nCallable 实现多线程\nCallable的定义\n1 2 3 4  @FunctionalInterface\rpublic interface Callable\u0026lt;V\u0026gt; {\rV call() throws Exception;\r}\r  如图 Callable 的继承关系：\n   Runnable Callable     JDK1.0 JDK1.5   只有 void run()，无返回值 V call()，有返回值    线程常用操作方法 构造方法public Thread(Runnable target, String name)\n设置名字public final synchronized void setName(String name)\n取得名字public final String getName()\n使用 Java 命令就会启动一个 JVM 的进程，一台电脑可以同时启动若干个 JVM 进程\n主线程可以创建若干个子线程，主线程负责处理整体流程，而子线程负责处理耗时操作\n线程休眠\n两种休眠处理方式\n一个参数，毫秒：public static native void sleep(long millis) throws InterruptedException;\n两个参数，毫秒纳秒public static void sleep(long millis, int nanos)throws InterruptedException\n休眠的主要特点是自动实现线程的唤醒，以继续进行后续的处理，多个线程休眠是有顺序的\n线程中断\n所有的线程都能被中断，线程中断必须进行异常处理\n线程的强制执行\n正常情况下主线程和子线程交替执行\n强制执行public final void join() throws InterruptedException\n线程礼让\n礼让方法：public static native void yield();\n线程优先级\n设置优先级public final void setPriority(int newPriority)\n获取优先级public final int getPriority()\n三个优先级常量\n1 2 3  public final static int MIN_PRIORITY = 1;\rpublic final static int NORM_PRIORITY = 5;\rpublic final static int MAX_PRIORITY = 10;\r  优先级高的最有可能先执行，并不是绝对先执行\n线程的同步与死锁 同步问题的引出\n系统休眠或网络延迟会产生数据不同步问题\n线程同步\n解决同步问题的关键是锁\n关键字synchronized\n同步实际上会使系统的性能降低\n解决同步问题的两种方法：同步代码块和同步方法\n线程死锁\n线程死锁就是若干个线程互相等待的状态\n死锁是开发中不确定的状态\n若干个线程访问同一资源时一定要进行同步处理，而过多的同步则会造成死锁\n基础类库 StringBuffer 类\n构造方法：public StringBuffer()\n构造方法：public StringBuffer(String str)\n基本操作方法：\n1 2 3 4 5 6 7  public static void main(String[] args) {\rStringBuffer sb=new StringBuffer(\u0026#34;baidu\u0026#34;);\rsb.append(\u0026#34;.com\u0026#34;).insert(0,\u0026#34;www.\u0026#34;);\rSystem.out.println(sb);\rsb.delete(0,4);\rSystem.out.println(sb);\r}\r  字符串反转：sb.reverse()\nStringBuffer属于线程安全的全部使用synchronized，StringBuilder是非线程安全的。\nCharSequence 接口\nCharSequence 是描述字符串结构的接口\n   String StringBuffer StringBuilder     public final class Stringextends Objectimplements Serializable, Comparable, CharSequence public final class StringBufferextends Objectimplements Serializable, CharSequence public final class StringBuilderextends Objectimplements Serializable, CharSequence    Runtime 类\n在每一个 JVM 只允许提供有一个 Runtime 类的对象，所以这个类的构造方法被默认私有化了\nSystem 类\n  数组拷贝：public static native void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);\n  获取当前日期时间数值：public static native long currentTimeMillis();\n  进行垃圾回收：public static void gc()\n  Math 类\nMath 类的全部方法:\n1 2 3 4 5 6 7 8  /**\r* 指定小数位数四舍五入\r* @param: [num, scale]\r* @return: double\r*/\rpublic static double round(double num,int scale){\rreturn Math.round(num*Math.pow(10,scale))/Math.pow(10,scale);\r}\r  Random 类\n生成不包含边界的随机正整数：public int nextInt(int bound)\nUUID 类\nUUID 是一种生成无重复字符串的一种程序类，这种程序类的主要功能是根据时间戳实现一个自动的无重复字符串定义。\n随机获取 UUID:public static UUID randomUUID()\n根据字符串获取 UUID 内容:public static UUID fromString(String name)\nOption 类\nOption 类的主要功能是进行 null 的相关处理\n返回空数据：public static\u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; empty()\n获取数据：public T get()\n保存数据，但是不许出现 null：public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; of(T value)\n保存数据，允许出现 null：public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value)\n空的时候返回其他数据:public T orElse(T other)\nThreadLocal 类\n构造方法：public ThreadLocal()\n设置数据：public void set(T value)\n取出数据：public T get()\n删除数据：public void remove()\nBase64 类\nBase64 可以实现加密与解密的处理，包含的内部类和方法如下图：\n比较器 Arrays 类\n数组的排序：public static void sort(int[] a)\n数组的输出：public static String toString(int[] a)\nComparable 比较器\n接口定义：public interface Comparable\u0026lt;T\u0026gt;\n实现比较的方法：int compareTo(T o)\nComparator 比较器\nComparator 属于一种挽救的比较器支持，其主要目的是解决一些没有使用 Comparable 排序的类的对象的数组排序操作\n红黑树原理  红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。\n红黑树是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。\n红黑树是一种特化的 AVL 树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。\n它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在 O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目。\n 红黑树的特点：\n 每个节点不是黑色就是红色 根节点必须是黑色 叶子节点是黑色  Java 实现的红黑树使用 null 代表空节点，因此遍历红黑树时将看不到黑丝的叶子节点，反而看到每个叶子节点都是红色的   红色节点的子节点必须是黑色的 一个节点到该节点的所有子孙节点的所有路径上包含相同数目的黑色节点  利用红色节点与黑色节点实现均衡的控制\n文件操作 File 类\n构造方法：public File(String pathname)\n构造方法：public File(String parent, String child)\n创建文件：public boolean createNewFile() throws IOException\n判断文件是否存在：public boolean exists()\n删除文件：public boolean delete()\nWindows 的路径分隔符是\\,Linux 的路径分隔符是/，\nFile 类中的路径分隔符常量separator\n获取父路径：public File getParentFile()\n创建单级目录：public boolean mkdir()\n创建多级目录：public boolean mkdirs()\n是否可读：public boolean canRead()\n是否可写：public boolean canWrite()\n获取文件长度：public long length()\n最后得到修改时间：public long lastModified()\n判断是否为目录：public boolean isFile()\n判断是否为文件：public boolean isDirectory()\n列出目录：public File[] listFiles()\n字节流与字符流 File 类只能够操作文件本身，而不能操作文件的内容\n字节处理流：OutputStream（输出字节流）,InputStream（输入字节流）\n字符处理流：Writer（输出字符流）,Reader（输入字符流）\n流的操作属于资源操作，资源操作必须进行关闭处理\nOutputStream字节输出流\n定义：public abstract class OutputStream implements Closeable, Flushable\nOutputStream的继承关系如图:\nOutputStream是一个公共的输出操作标准\nFileOutputStream是OutputStream的实现子类\n【覆盖】构造方法：public FileOutputStream(File file) throws FileNotFoundException\n【追加】构造方法：public FileOutputStream(File file, boolean append) throws FileNotFoundException\nInputStream字节输入流\nInputStream的继承关系与方法\n使用 read()方法读取的时候只能够以字节数组为主进行接收\nWriter字符输出流\nWriter 的继承关系及方法：\nWriter是字符流，字符处理的优势在于中文数据。\nReader字符输入流\nReader 的构造：\n字节流与字符流的区别\nOutputStream不关闭可以正常保存\nWriter不关闭不能正常保存\n因为Writer使用了缓冲区\n涉及中文信息的都采用字符流\n转换流\n   OutputStreamWriter InputStreamReader     public class OutputStreamWriter extends Writer public class InputStreamReader extends Reader   public OutputStreamWriter(OutputStream out) public InputStreamReader(InputStream in)    转换流可以使字节流转换为字符流\nFileWriter继承结构\nFileReader继承结构\nIO 操作深入 字符编码\n GBK/GB2312：国际编码，可以描述中文信息，GB2312 只描述简体中文 ISO8859-1：国际通用编码，可以用于描述所有字母信息 UNICODE 编码：采用十六进制方式存储，可用于描述所有的文字信息 UTF 编码：象形文字采用十六进制编码，字母采用 ISO8859-1 编码，有利于数据传输，节省带宽 项目中一般都统一使用 UTF-8 编码  列出系统信息System.getProperties().list(System.out);\n内存操作流\nJava 有两类内存操作流：\n  字节内存操作流\n  字符内存操作流\n  管道流\n 字节管道流 字符管道流  输入与输出支持 打印流\n   PrintStream PrintWriter     public class PrintStream extends FilterOutputStream implements Appendable, Closeable public class PrintWriter extends Writer   public PrintStream(OutputStream out) public PrintWriter (Writer out),public PrintWriter(OutputStream out)    对文件进行操作时通常使用打印流\nSystem 类对 IO 的支持\n 标准输出（显示器）：public final static PrintStream out = null; 错误输出：public final static PrintStream err = null; 标准输入（键盘）：public final static InputStream in = null;  1 2  System.out.println(\u0026#34;我是System.out\u0026#34;);\rSystem.err.println(\u0026#34;我是System.err\u0026#34;);\r  System.out输出黑色字体\nSystem.err输出红色字体\nSystem.in并不常用\nBufferedReader缓冲输入流\n读取一行数据public String readLine() throws IOException\nScanner 扫描流\n构造：public Scanner(InputStream source)\n判断是否有数据：public boolean hasNext()\n取出数据：public String next()\n设置分隔符：public Scanner useDelimiter(Pattern pattern)\n对象序列化  序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n Person 类产生的每一个对象都可以实现二进制的数据传输，属于可以被序列化的程序类\n序列化与反序列化\n   序列化 反序列化     ObjectOutputStream ObjectInputStream   public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants   public ObjectOutputStream(OutputStream out) throws IOException public ObjectInputStream(InputStream in) throws IOException   public final void writeObject(Object obj) throws IOException public final Object readObject() throws IOException, ClassNotFoundException    在 Java 中的序列化与反序列化必须使用内部提供的对象操作流，如果要实现一组对象的序列化，则可以使用对象数组完成\ntransient 关键字\n默认情况下当执行了对象序列化的时候会将类中的全部属性的内容进行全部的序列化操作，但是很多情况下有一些属性可能并不需要进行序列化的处理。\nprivate transient String name;\n进行序列化处理的时候，name属性的内容是不会被保存下来的，换言之，读取的数据name将是其对应数据类型的默认值null\n反射机制  所有的技术实现的目标只有一点：重用性\n 根据实例化对象反推出其类型\n 获取 Class 对象信息：public final Class\u0026lt;?\u0026gt; getClass()  class 类定义：public final class Class\u0026lt;T\u0026gt; implements java.io.Serializable,GenericDeclaration,Type,AnnotatedElement   JVM 直接支持采用“类.class”的形式实例化 Class.forName().public static Class\u0026lt;?\u0026gt; forName(String className) throws ClassNotFoundException  反射实例化对象\n通过public T newInstance()实例化对象\n相当于“类名 对象名 = new 类()”，但是该方法只能调用无参构造，JDK9 之后被废弃\n集合工具类 Stack 类\n入栈public E push(E item)\n出栈public synchronized E pop()\nStack 的继承结构如下：\n空栈时出栈会出现Exception in thread \u0026quot;main\u0026quot; java.util.EmptyStackException\nQueue 接口\n追加数据：boolean add(E e);或boolean offer(E e);\n通过队列获取数据：E poll();弹出后删除数据\n优先级队列PriorityQueue\nProperties 属性操作\nProperties 类只能操作 String\n使用 Properties 类型的最大特点是可以进行资源内容的输入与输出的处理操作\nCollections 类\n解释 Collection 与 Collections 的区别\n Collection 是集合接口，允许保存单值对象 Collections 是集合操作的工具类。  Stream 数据流 Stream 基础操作\nStream 主要功能是进行数据的分析处理，主要是针对于集合中的数据进行分析操作\n可以通过函数式编程进行数据的流式处理\n数据采集\n\u0026lt;R, A\u0026gt; R collect(Collector\u0026lt;? super T, A, R\u0026gt; collector);\n分页处理方法\n  设置取出的最大数据量：Stream\u0026lt;T\u0026gt; limit(long maxSize);\n  跳过指定数据量：Stream\u0026lt;T\u0026gt; skip(long n);\n  MapReduce 基础模型\nall.stream()用于初始化 Stream 对象\n.filter((ele)-\u0026gt;ele.getName().contains(\u0026quot;小米\u0026quot;))过滤出商品名称中含有小米的数据。\n.mapToDouble((olderObject)-\u0026gt;olderObject.getPrice()*olderObject.getCount()).summaryStatistics();计算出单种商品的总价，然后返回DoubleSummaryStatistics类型的对象。\nDoubleSummaryStatistics一些常用的方法\n网络编程 针对网络程序的开发有两种模型：\n C/S（Client/Server，客户端与服务器端） B/S（Browser/Server，浏览器与服务器端）  TCP（可靠的数据连接）\nUDP（不可靠的数据连接）\nTCP\nTCP 的程序开发是网络程序最基本的开发模型，其核心的特点是使用两个类实现数据的交互处理：ServerSocket（服务器端），Socket（客户端）\n简要工作流程如图：\nServerSocket 的主要目的是设置服务器监听的端口，Socket 要指明要连接的服务器地址与端口\nUDP\nUDP 程序是基于数据报的网络编程实现，如果想实现 UDP 程序需要两个类：DatagramSocket和DatagramPacket\nJDBC 对于 JDBC 的程序数据库的访问分为如下四种形式：\n  JDBC-ODBC 桥连接\n处理流程：程序 →JDBC→ODBC→ 数据库\n  JDBC 连接：直接通过 JDBC 进行数据库的连接\n处理流程：程序 →JDBC→ 数据库\n  JDBC 网络连接：通过特定的网络协议连接指定的数据库服务\n处理流程：程序 →JDBC→ 网络数据库(IP 地址，端口号)\n  JDBC 协议连接\n  Java 访问 MySQL 过程；\n  设置驱动\n1  `static final String JDBC_DRIVER = \u0026#34;com.mysql.jdbc.Driver\u0026#34;;\r    设置数据库地址\n1  static final String DB_URL = \u0026#34;jdbc:mysql://localhost:3308/test\u0026#34;;\r    设置用户名和密码\n1 2  static final String USER = \u0026#34;root\u0026#34;;\rstatic final String PASS = \u0026#34;123456\u0026#34;;\r    初始化连接对象和游标对象\n1 2  Connection conn = null;\rStatement stmt = null;\r    注册 JDBC 驱动\n1  Class.forName(JDBC_DRIVER);\r    打开连接\n1  conn = DriverManager.getConnection(DB_URL, USER, PASS);\r    执行查询语句\n1 2 3 4 5  System.out.println(\u0026#34; 实例化Statement对象...\u0026#34;);\rstmt = conn.createStatement();\rString sql;\rsql = \u0026#34;SELECT id, name, url FROM websites\u0026#34;;\rResultSet rs = stmt.executeQuery(sql);\r    用ResultSet对象接收返回结果\n1  ResultSet rs = stmt.executeQuery(sql);\r    遍历ResultSet对象\n1 2 3 4 5 6 7 8 9 10 11  while (rs.next()) {\r// 通过字段检索\r int id = rs.getInt(\u0026#34;id\u0026#34;);\rString name = rs.getString(\u0026#34;name\u0026#34;);\rString url = rs.getString(\u0026#34;url\u0026#34;);\r// 输出数据\r System.out.print(\u0026#34;ID: \u0026#34; + id);\rSystem.out.print(\u0026#34;, 站点名称: \u0026#34; + name);\rSystem.out.print(\u0026#34;, 站点 URL: \u0026#34; + url);\rSystem.out.print(\u0026#34;\\n\u0026#34;);\r}\r    关闭资源\n  1 2 3  rs.close();\rstmt.close();\rconn.close();\r  运行结果：\n1 2 3 4 5 6 7 8  Thu Apr 09 18:03:44 CST 2020 WARN: Establishing SSL connection without server\u0026#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn\u0026#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to \u0026#39;false\u0026#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\r实例化Statement对象...\rID: 1, 站点名称: Google, 站点 URL: https://www.google.cm/\rID: 2, 站点名称: 淘宝, 站点 URL: https://www.taobao.com/\rID: 3, 站点名称: 菜鸟教程, 站点 URL: http://www.runoob.com\rID: 4, 站点名称: 微博, 站点 URL: http://weibo.com/\rID: 5, 站点名称: Facebook, 站点 URL: https://www.facebook.com/\rGoodbye!\r   MySQL 8.0 以上版本需设置 JDBC 为static final String JDBC_DRIVER = \u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;;\n ","description":"本文系统的记录学习JavaSE的笔记，按照阿里云上的 Java 学习路线自学的，代码的解释可以访问我的简书个人主页","id":14,"section":"posts","tags":["java"],"title":"JavaSE 学习笔记","uri":"https://eternidad33.github.io/zh/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"码云上搭建 Hexo 静态博客   下载 Node.js\n  下载并配置 Git\n  安装 Hexo\n 设置 cnpm，设置为国内的淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 Hexo， cnpm install -g hexo-cli 查看是否安装成功 hexo -v    建立博客文件夹\n  执行hexo init\n  Hexo 常用的几个命令\n hexo s运行 Hexo hexo n 文件名.md创建博客文章，也可以直接在\\source\\_posts文件夹中创建 hexo g生成博客文件 hexo clean清理缓存 hexo d推送到远端服务器    创建远程仓库，仓库名要与自己的用户名相同\n  安装 Git 依赖，cnpm install --save hexo-deployer-git\n  修改配置文件\n1 2 3 4  deploy:type:gitrepo:https://gitee.com/eternidad33/eternidad33.gitbranch:master    开启Gitee Pages服务\n  推荐 B 站 Up 主：CodeSheep\n参考的是他的视频手把手教你从 0 开始搭建自己的个人博客 |无坑版视频教程| hexo\n","description":"","id":15,"section":"posts","tags":["hexo"],"title":"码云上搭建Hexo博客","uri":"https://eternidad33.github.io/zh/posts/%E7%A0%81%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"content":"学习类 中国大学 MOOC（涵盖各个行业的课程）\n慕课网（计算机互联网行业学习的网站）\n哔哩哔哩（各个领域的 UP 主）\nw3cSchool（学习编程）\n廖雪峰的官方网站（学习编程）\n菜鸟教程（学习编程）\n实验楼（学习编程）\n数据酷客（学习 Python，大数据）\n阿里云大学(提供编程各个方向的学习路线)\nhow2j（学习 Java）\n素材类 微信读书（只要有无限卡，全场免费读）\n鸠摩搜书（基本上想搜的书都能搜到）\nGreasy Fork（配合油猴插件下载脚本）\nMSDN，我告诉你（免费下载纯净的 Windows 系统镜像）\n我的 MSDN（免费下载纯净的 Windows 系统镜像）\n电脑壁纸（免费好看的桌面壁纸）\n阿里巴巴矢量图标库（下载各种格式的图标）\n第一 PPT（免费 PPT 模板）\n优品 PPT（免费 PPT 模板）\n站长素材（下载图标，字体，PSD，矢量图，jQuery 等）\n编程相关 ProcessOn（在线作图）\nGitHub（ 世界上最大的软件项目的托管平台 ）\n码云（相当于国内的 GitHub）\n牛客（刷题）\nLeetCode（刷题）\n洛谷（刷题）\nwakatime（记录编码时间）\nSM.MS（图床工具）\nShields.IO（生成展示在 Markdown 文档中的徽章）\nSimple Icons（下载 SVG 图标）\n","description":"大学期间收集的网站，主要分为学习类，素材类，和编程相关","id":16,"section":"posts","tags":null,"title":"网站推荐","uri":"https://eternidad33.github.io/zh/posts/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"},{"content":"1. Alibaba Cloud Tookit  Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；并且还内置了 Arthas 诊断、Dubbo 工具、Terminal 终端、文件上传、函数计算 和 MySQL 执行器等工具。（产品官网：https://www.aliyun.com/product/cloudtoolkit）\n 通过该插件就可以直接在 VScode 上直接控制自己的远程服务器了，可以很方便地上传本机的文件到服务器上。\n需要配置的就是服务器的 ip,AccessKeyId,AccessKeySecret,用户名和密码\n2. Auto Import  Automatically finds, parses and provides code actions and code completion for all available imports. Works with Typescript and TSX.\n 该插件用于在编写代码时，自动导入文件中忘记写的需要的包，配置里的钩根据自己的需求打就行了\n3. Auto Rename Tag  Automatically rename paired HTML/XML tag, same as Visual Studio IDE does.\n 顾名思义就是 html，xml 的起始标签改变时，结束标签也会跟随改变\n4. Code Runner  Run code snippet or code file for multiple languages: C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, and custom command\n 如果用 VScode 编写 Java 可以用该插件编译，调试，和运行，其他语言可能也行，配置信息根据自身需求设置\n 如果是编写 Java，VScode 会提示安装许多 Java 的插件，例如：Debugger for Java，Java Dependency Viewer，Java Extension Pack，Java Test Runner，Language support for Java ™ for Visual Studio Code，Maven for Java，自动安装上即可\n 5. Color Info 该插件是在编写 CSS 需要设置颜色时用的，可以快速从调色板中选取颜色，设置透明度等。即装即用，无需配置。\n6. GitLens — Git supercharged  GitLens supercharges the Git capabilities built into Visual Studio Code. It helps you to visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more.\n 这个 Git 插件配合 VScode 自带的源代码管理工具，可以很好的管理自己的本地仓库和远程仓库。\n这个需要先把快捷键配置上,将 commit 的快捷键设置为 Alt+/\n7. Indent-Rainbow 不同缩进会显示不同的颜色，编写 Python 必装的插件，因为 Python 对缩进的要求很严格，即装即用，无需配置\n显示效果：\n8. LeetCode 刷 LeetCode 上的题必备的插件，可以查看自己刷过的题，支持查看，测试，提交，看自己的运行结果等\n配置时先把 user-account 设为 leetcode-cn，然后登陆自己的账户即可，然后配置上自己习惯用的语言\n9. wakatime 记录自己的编码时间，在wakatime 官网上直接查看自己每天的编码时间，免费版最多可以保存最近 14 天的。\n如果使用其他的 IDE 也可以安装该插件，然后在官网上查看自己编写各种语言的时间，和使用各个 IDE 的时间，每周会给自己邮箱发一个周报\n只需配置上自己在官网上注册的账号的 api key 即可。\n10. PicGo 图床工具，支持的图床有 qiniu, tcyun, upyun, github, aliyun, imgur 和 SM.MS，默认是 SM.MS。但是 SM.MS 经常上传失败，我也不太清楚怎么解决。介绍一下 GitHub 图床的配置\n PicBed 设为GitHub branch 设为master Custom Url：https://cdn.jsdelivr.net/gh/user/repo@master采用 cdn 访问，因为国内访问 GitHub 相对较慢  gh表示 github user填写自己的用户名 repo填写自己图床的仓库 例如https://cdn.jsdelivr.net/gh/eternidad33/picbed@master   Path:images/图片上传到仓库中的 images 文件夹中 Repo：user/repo填写自己的仓库即可 Token：自己在 GitHub 上创建一个拥有 repo 权限的 Token，填上即可  上传本机图片的快捷键是 Ctrl+Alt+E\n11. Markdown Preview Enhanced with litvis 全面支持 Markdown 的预览，默认的 Markdown 预览显示的不太好看，[Toc]生成的目录是显示不出的，还有一些 HTML 的标签支持的也不是很好，而该插件就可以很好地显示，同时还可以将 Markdown 文件导出为 HTML，PDF 等格式的文件\nWallpaper 每日壁纸分享 标题：Fantasy World\n创作者：Mrs.Venus\n","description":"Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；","id":17,"section":"posts","tags":null,"title":"VSCode插件推荐","uri":"https://eternidad33.github.io/zh/posts/vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"content":"个人主页 代码：码云，Github\n博客：简书，CSDN，博客园\n刷题：牛客，LeetCode\n社交：今日头条，哔哩哔哩，steam，知乎，百度贴吧，微博\n欢迎大家关注我的动态\n","description":"个人动态","id":18,"section":"","tags":null,"title":"关于","uri":"https://eternidad33.github.io/zh/about/"}]