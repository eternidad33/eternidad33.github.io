[{"content":"Collection结构图 Map结构图 总结 推荐视频：Java零基础教程视频（适合Java 0基础，Java初学入门）\nArrayList：底层是数组\nLinkedList：底层是双向链表\nVector：底层是数组，线程安全的，效率较低，使用较少\nHashSet：底层是 HashMap，放到 HashSet集合中的元素等同于放到HashMap集合 key部分\nTreeSet：底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合key部分\nHashMap：底层是哈希表\nHashTable：底层是哈希表，线程安全，效率较低，使用较少\nProperties：线程安全的，key和value只能存储字符串\nTreeMap：底层是二叉树，它的key可以自动按照大小排序\nList集合存储元素的特点：\n 有序：存进去和取出来的顺序相同，每个元素都有下标 可重复  Set集合存储元素的特点：\n 无序：存进去和取出来的顺序不相同，Set集合中元素没有有下标 不可重复  SortedSet（SortedMap）集合存储元素的特点\n 无序不可重复 SortedSet集合中元素是可排序的 可排序：可以按照大小顺序排列  Map集合的key就是一个Set集合，往Set集合放数据实际上放到了Map集合的key部分。\nArrayList  默认初始化容量为10 底层是object数组 扩容1.5倍 建议给定一个预估的初始化容量，减少数组的扩容次数 优点：随机增删元素效率低 缺点：末尾增删元素效率高  LinkedList  底层也是有下标的，双向链表 检索、查询的时候只能从头结点开始 优点：随机增删元素效率高 缺点：查询效率低  Vector  线程安全 初始化容量为10 2倍扩容 底层是数组  HashSet  底层HashMap 无序，不可重复 无序是指没有下标  TreeSet  底层TreeMap 无序，不可重复 元素会自动排序存储 要实现Comparable\u0026lt;T\u0026gt;的 compareTo(T o)方法  HashMap   底层是哈希表\n  数组+单向链表\n  源码\n1 2 3 4 5 6 7 8 9 10 11  public class HashMap\u0026lt;K,V\u0026gt;{\r//数组\r transient Node\u0026lt;K,V\u0026gt;[] table;\r//链表\r static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; {\rfinal int hash;\rfinal K key;\rV value;\rNode\u0026lt;K,V\u0026gt; next;\r}\r}\r    同一个链表的hash值相等\n  放在HashMap中的元素需要重写equals和hashCode方法\n  map.put(k,v)\n 封装node对象 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，直接将Node添加到这个位置 有元素，在链表每个节点进行euquals()比较，如果全为false，在末尾添加，如果有True，更新Value    map.get(k)\n 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，返回None 下标有链表，对链表元素的Key比较equals，有true返回value，全为false，代表没有元素，返回null    扩容是原来长度的2倍\n  允许key值为null\n  HashTable  key和value都不能为null 线程安全 初始化容量11 扩容2倍+1  Properties  继承HashTable，线程安全的 key和value只能存储字符串  TreeMap  放到TreeMap集合中的元素的key部分进行排序有两种实现方式  实现java.lang.Comparable的compareTo方法 构造TreeSet或TreeMap集合的时候传一个比较器对象Comparator   比较规则不会发生改变或者比较规则只有一个的时候使用Comparable 比较规则多个，并且比较规则需要频繁切换Comparator  ","description":"ArrayList：底层是数组，LinkedList：底层是双向链表，Vector：底层是数组，线程安全的，效率较低，使用较少，HashSet：底层是 HashMap，放到 HashSet集合中的元素等同于放到HashMap集合 key部分，TreeSet：底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合key部分，HashMap：底层是哈希表","id":0,"section":"posts","tags":["java"],"title":"【干货】Java集合","uri":"https://eternidad33.github.io/zh/posts/java%E9%9B%86%E5%90%88/"},{"content":"欢迎大家访问我的github\n创建以用户名为名称的仓库\n自定义自己的README文件即可在自己的github显示了\n我这个上边显示的编码时长，是添加了一个action每天更新自己的编码时长\n具体设计步骤可参考 github上的athul/waka-readme项目\n总结一下简要的步骤\n 注册wakatime账号 在自己常用的IDE上下载wakatime插件，配置上自己的API key 将自己的API key存到自己GitHub仓库的secrets 在README文件上加上  1 2  \u0026lt;!--START_SECTION:waka--\u0026gt;\r\u0026lt;!--END_SECTION:waka--\u0026gt;\r  配置GitHub仓库的Action，这样就能每天自动运行了  ","description":"","id":1,"section":"posts","tags":["github"],"title":"自定义GitHub主页","uri":"https://eternidad33.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89github%E4%B8%BB%E9%A1%B5/"},{"content":"连接SQLite 要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；\n连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。\nPython定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。\n由于SQLite的驱动内置在Python标准库中，可以直接来操作SQLite数据库。\n1 2  # 导入SQLite驱动: import sqlite3   1 2 3 4  # 连接到SQLite数据库 # 数据库文件是test.db # 如果文件不存在，会自动在当前目录创建: conn = sqlite3.connect(\u0026#39;test.db\u0026#39;)   1 2  # 创建一个Cursor: cursor = conn.cursor()   1 2  # 执行一条SQL语句，创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 继续执行一条SQL语句，插入一条记录: cursor.execute(\u0026#39;insert into user (id, name) values (\u0026#34;1\u0026#34;, \u0026#34;vigilr\u0026#34;)\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 通过rowcount获得插入的行数: cursor.rowcount   1  1 2 3 4 5 6  # 关闭Cursor: cursor.close() # 提交事务: conn.commit() # 关闭Connection: conn.close()   1 2 3 4  conn = sqlite3.connect(\u0026#39;test.db\u0026#39;) cursor = conn.cursor() # 执行查询语句: cursor.execute(\u0026#39;select * from user where id=?\u0026#39;,(\u0026#39;1\u0026#39;,))   \u0026lt;sqlite3.Cursor at 0x2040e224810\u0026gt;  1 2 3  # 获得查询结果集: values = cursor.fetchall() values   [('1', 'vigilr')]  1 2  cursor.close() conn.close()   使用Python的DB-API时，只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用。\n使用Cursor对象执行insert，update，delete语句时，执行结果由rowcount返回影响的行数，就可以拿到执行结果。\n使用Cursor对象执行select语句时，通过featchall()可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。\n如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，例如：\n1  cursor.execute(\u0026#39;select * from user where name=? and pwd=?\u0026#39;, (\u0026#39;abc\u0026#39;, \u0026#39;password\u0026#39;))   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # -*- coding: utf-8 -*- import sqlite3 # 初始数据: conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;create table user(id varchar(20) primary key, name varchar(20), score int)\u0026#39;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-001\u0026#39;, \u0026#39;Adam\u0026#39;, 95)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-002\u0026#39;, \u0026#39;Bart\u0026#39;, 62)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-003\u0026#39;, \u0026#39;Lisa\u0026#39;, 78)\u0026#34;) cursor.close() conn.commit() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13  def get_score_in(low, high): \u0026#39;\u0026#39;\u0026#39;返回指定分数区间的名字，按分数从低到高排序\u0026#39;\u0026#39;\u0026#39; conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;select name from user where score\u0026gt;=? and score\u0026lt;=? ORDER BY score\u0026#39;,(low,high)) temp=cursor.fetchall() result=[] for t in temp: for i in t: result.append(i) cursor.close() conn.close() return result   1 2 3 4 5 6 7  # 测试: assert get_score_in(80, 95) == [\u0026#39;Adam\u0026#39;], get_score_in(80, 95) assert get_score_in(60, 80) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;], get_score_in(60, 80) assert get_score_in(60, 100) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;, \u0026#39;Adam\u0026#39;], get_score_in(60, 100) print(\u0026#39;Pass\u0026#39;)   Pass  连接MySQL 安装MySQL驱动\n由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。\nMySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数--allow-external：\npip install mysql-connector-python --allow-external mysql-connector-python\n如果上面的命令安装失败，可以试试另一个驱动：\npip install mysql-connector\n除了使用mysql.connector还可以使用pymysql\n1 2  # 导入pymysql模块 import pymysql   1 2 3 4 5 6 7 8 9 10 11 12  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;) cursor.close() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 插入一行记录，注意MySQL的占位符是%s: cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;1\u0026#39;, \u0026#39;wasd\u0026#39;]) cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;2\u0026#39;, \u0026#39;zxc\u0026#39;]) print(\u0026#39;受影响行数：\u0026#39;,cursor.rowcount) # 提交事务: conn.commit() cursor.close() conn.close()   受影响行数： 1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) # 运行查询: cursor = conn.cursor() cursor.execute(\u0026#39;select * from user\u0026#39;) values = cursor.fetchall() print(values) # 关闭Cursor和Connection: cursor.close() conn.close()   (('1', 'wasd'), ('2', 'zxc'))  使用SQLAlchemy ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。\n在Python中，最有名的ORM框架是SQLAlchemy。\n首先通过pip安装SQLAlchemy：pip install sqlalchemy\n1 2 3 4 5 6  # 第一步，导入SQLAlchemy，并初始化DBSession： # 导入: from sqlalchemy import Column, String, create_engine,ForeignKey from sqlalchemy.orm import sessionmaker,relationship from sqlalchemy.ext.declarative import declarative_base   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 创建对象的基类: Base = declarative_base() # 定义User对象: class User(Base): # 表的名字: __tablename__ = \u0026#39;users\u0026#39; # 表的结构: id = Column(String(20), primary_key=True) name = Column(String(20)) # 以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如Scho class School(Base): __tablename__ = \u0026#39;school\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # 初始化数据库连接:mysqlconnector和pymysql都可以用 # engine = create_engine(\u0026#39;mysql+mysqlconnector://root:123456@localhost:3308/test\u0026#39;) engine = create_engine(\u0026#39;mysql+pymysql://root:123456@localhost:3308/test\u0026#39;) # 创建DBSession类型: DBSession = sessionmaker(bind=engine)   create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：\n数据库类型+数据库驱动名称://用户名:密码@数据库地址:端口号/数据库名\n由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 创建所有定义的表到数据库中 Base.metadata.create_all(engine) # 创建session对象: session = DBSession() # 创建新User对象: user1 = User(id=\u0026#39;1\u0026#39;, name=\u0026#39;wasd\u0026#39;) user2 = User(id=\u0026#39;2\u0026#39;, name=\u0026#39;zxc\u0026#39;) user3 = User(id=\u0026#39;3\u0026#39;, name=\u0026#39;qwe\u0026#39;) user4 = User(id=\u0026#39;4\u0026#39;, name=\u0026#39;rty\u0026#39;) user5 = User(id=\u0026#39;5\u0026#39;, name=\u0026#39;vbn\u0026#39;) user6 = User(id=\u0026#39;6\u0026#39;, name=\u0026#39;fgh\u0026#39;) # 添加到session: session.add(user1) session.add(user2) session.add(user3) session.add(user4) session.add(user5) session.add(user6) # 提交即保存到数据库: session.commit() # 关闭session: session.close() # 关键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接。   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\pymysql\\cursors.py:170: Warning: (1366, \u0026quot;Incorrect string value: '\\\\xD6\\\\xD0\\\\xB9\\\\xFA\\\\xB1\\\\xEA...' for column 'VARIABLE_VALUE' at row 489\u0026quot;) result = self._query(query)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 查询数据 # 创建Session: session = DBSession() # 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行: user = session.query(User).filter(User.id==\u0026#39;1\u0026#39;).one() users = session.query(User).filter(User.id!=\u0026#39;1\u0026#39;).all() # 打印类型和对象的name属性: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) for user in users: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) # 关闭Session: session.close()   type: \u0026lt;class '__main__.User'\u0026gt; name: wasd type: \u0026lt;class '__main__.User'\u0026gt; name: zxc type: \u0026lt;class '__main__.User'\u0026gt; name: qwe type: \u0026lt;class '__main__.User'\u0026gt; name: rty type: \u0026lt;class '__main__.User'\u0026gt; name: vbn type: \u0026lt;class '__main__.User'\u0026gt; name: fgh  ORM就是把数据库表的行与相应的对象建立关联，互相转换。\n由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。\n例如，如果一个User拥有多个Book，就可以定义一对多关系如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class User(Base): __tablename__ = \u0026#39;user\u0026#39; __table_args__ = {\u0026#39;extend_existing\u0026#39;: True} id = Column(String(20), primary_key=True) name = Column(String(20)) # 一对多: books = relationship(\u0026#39;Book\u0026#39;) class Book(Base): __tablename__ = \u0026#39;book\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # “多”的一方的book表是通过外键关联到user表的: user_id = Column(String(20), ForeignKey(\u0026#39;user.id\u0026#39;)) # 当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。 # 创建所有定义的表到数据库中 Base.metadata.create_all(engine)   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\sqlalchemy\\ext\\declarative\\clsregistry.py:129: SAWarning: This declarative base already contains a class with the same class name and module name as __main__.User, and will be replaced in the string-lookup table. % (item.__module__, item.__name__)  更多用法可参考：这篇文章https://www.jianshu.com/p/65903a69d61d\n","description":"","id":2,"section":"posts","tags":["python"],"title":"Python三种连接数据库的方式","uri":"https://eternidad33.github.io/zh/posts/python%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"content":"购买服务器 直接购买皆可以了\n有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器\n现在购买可以91.8一年\n学生购买是9.50一个月（参与云翼计划然后学生认证即可）\n 我是单买的一个月的，因为不经常用，想用的时候就买一个月的\n 安装镜像 从镜像市场选择宝塔控制面板安装\n 宝塔Linux面板（LAMP/LNMP/Tomcat/Node.js）\n功能强大且终身免费的Linux服务器管理软件，一键部署：LAMP/LNMP/Tomcat/Node.js、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。\n 镜像安装完要配置安全组打开相应端口\n面板配置 bt命令进行相关的操作\n可以更改掉默认的用户名和密码\n浏览器访问公网ip:8888进行环境的安装\n可以选择LNMP安装，大约5~6分钟安装完成\n配置mysql数据库相应的端口，默认3306，可以改为其他端口\n安装完成后可以数据库的root密码\n安装Tomcat 从左侧的软件商店安装Tomcat（不用单独安装Java，面板自动安装Java）\n安装完tomcat后要在面板中放行8080端口，前边的安全组也要放行8080端口\n浏览器成功访问公网ip:8080，即为成功安装\n部署项目 本文部署的是GitHub上的 一个基于SSM+Websocket的实时在线聊天室项目\n配置数据库信息并生成war包\n成功生成war包后的效果如下：\n在服务器的mysql运行本项目中的sql文件\n将生成的war文件上传到/www/server/tomcat/webapps目录下，tomcat会自动解压\n 上传文件方法有很多，可以通过命令行，也可以用工具，我知道的工具如下：\n xshell及xftp IDEA的阿里云部署插件(Alibaba Cloud Toolkit) 通过宝塔面板上传   浏览器访问公网IP:8080/网站应用名，出现下面的界面即为成功部署\n","description":"","id":3,"section":"posts","tags":["java"],"title":"阿里云宝塔面板配置及部署Java项目","uri":"https://eternidad33.github.io/zh/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE/"},{"content":" Scrapy is a fast high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.\n​\t\u0026mdash;\u0026mdash;\u0026mdash;来自官方文档的介绍\n  Engine从Spider处获得爬取请求(Request) Engine将爬取请求转发给Scheduler，用于调度 Engine从Scheduler处获得下一个要爬取的请求 Engine将爬取请求通过中间件发送给Downloader 爬取网页后，Downloader形成响应（Response）通过中间件发给Engine Engine将收到的响应通过中间件发送给Spider处理 Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine Engine将爬取项发送给Item Pipeline（框架出口） Engine将爬取请求发送给Scheduler  Engine控制各模块数据流，不间断从Scheduler处获得爬取请求，直至请求为空。\n数据流的出入口\n框架入口：Spider的初始爬取请求\n框架出口：Item Pipeline\n用户只需编写(配置)Spider和Item Pipeline\nEngine\n 控制所有模块之间的数据流 根据条件触发事件  不需要用户修改\nDownloader\n根据请求下载网页\n不需要用户修改\nScheduler\n对所有爬取请求进行调度管理\n不需要用户修改\nDownloader Middleware\n目的：实施Engine、Scheduler和Downloader之间进行用户可配置的控制\n功能：修改、丢弃、新增请求或响应\n用户可以编写配置代码\nSpider\n 解析Downloader返回的响应（Response） 产生爬取项（scraped item） 产生额外的爬取请求（Request）  需要用户编写配置代码\nItem Pipelines\n 以流水线方式处理Spider产生的爬取项 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库  需要用户编写配置代码\nSpider Middleware\n目的：对请求和爬取项的再处理\n功能：修改、丢弃、新增请求或爬取项\n用户可以编写配置代码\nrequests 和 Scrapy的异同\n相同点：\n 两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线 两者可用性都好，文档丰富，入门简单 两者都没有处理js、提交表单、应对验证码等功能（可扩展）  不同点：\n   requests Scrapy     页面级爬虫 网站级爬虫   功能库 框架   并发性考虑不足，性能较差 并发性好，性能较高   重点在于页面下载 重点在于爬虫结构   定制灵活 一般定制灵活，深度定制困难   上手十分简单 入门稍难    Scrapy常用命令\n   命令 说明 格式     startproject 创建一个新工程 scrapy startproject \u0026lt;name\u0026gt; [dir]   genspider 创建一个爬虫 scrapy genspider [options] \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt;   settings 获得爬虫配置信息 scrapy settings [options]   crawl 运行一个爬虫 scrapy crawl \u0026lt;spider\u0026gt;   list 列出工程中所有爬虫 scrapy list   shell 启动URL调试命令行 scrapy shell [url]    生成的工程目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  PS E:\\scrapyDemo\u0026gt; tree /f 卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r│ scrapy.cfg -------------------\u0026gt;\u0026gt;部署Scrapy爬虫的配置文件\r│\r└─scrapyDemo ------------\u0026gt;\u0026gt;Scrapy框架的用户自定义Python代码\r│ items.py --------------\u0026gt;\u0026gt;Items代码模板（继承类）\r│ middlewares.py -------\u0026gt;\u0026gt;Middlewares代码模板（继承类）\r│ pipelines.py ---------\u0026gt;\u0026gt;Pipelines代码模板（继承类）\r│ settings.py --------\u0026gt;\u0026gt;Scrapy爬虫的配置文件\r│ __init__.py ---------\u0026gt;\u0026gt;初始化脚本\r│\r├─spiders --------------\u0026gt;\u0026gt;Spiders代码模板目录（继承类）\r│ │ firstSpider.py ------\u0026gt;\u0026gt;生成的爬虫\r│ │ __init__.py ------\u0026gt;\u0026gt;初始文件，无需修改\r│ │\r│ └─__pycache__ --------\u0026gt;\u0026gt;缓存目录，无需修改\r│ firstSpider.cpython-37.pyc\r│ __init__.cpython-37.pyc\r│\r└─__pycache__ -----------\u0026gt;\u0026gt;缓存目录，无需修改\rsettings.cpython-37.pyc\r__init__.cpython-37.pyc\r  Scrapy爬虫的使用步骤\n步骤1：创建一个工程和Spider模板\n步骤2：编写Spider\n步骤3：编写Item Pipeline\n步骤4：优化配置策略\nScrapy爬虫的数据类型\n  Request类\nRequest对象表示一个HTTP请求，由Spider生成，由Downloader执行\n  Response类\nResponse对象表示一个HTTP响应，由Downloader生成，由Spider处理\n  Item类\nItem对象表示一个从HTML页面中提取的信息内容，由Spider生成，由Item Pipeline处理，Item类似字典类型，可以按照字典类型操作\n  Scrapy爬虫支持多种HTML信息提取方法：\n Beautiful Soup lxml re XPath Selector CSS Selector  ","description":"","id":4,"section":"posts","tags":["python"],"title":"Scrapy 框架笔记","uri":"https://eternidad33.github.io/zh/posts/scrapy/"},{"content":"基础页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;\r\u0026lt;h2\u0026gt;前端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;List1\u0026#34;\u0026gt;\r\u0026lt;li id=\u0026#34;li1\u0026#34;\u0026gt;HTML\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;h2\u0026gt;后端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;list2\u0026#34;\u0026gt;\r\u0026lt;li title=\u0026#34;C语言\u0026#34;\u0026gt;C\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;Java语言\u0026#34;\u0026gt;Java\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;我是Python\u0026#34;\u0026gt;Python\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;C Sharp\u0026#34;\u0026gt;C#\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r  运行结果\n通过ID获取元素 1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;list1\u0026#34;);\rvar c2 = document.getElementById(\u0026#34;li1\u0026#34;)\rdocument.write(\u0026#34;通过ID获取 ul 标签\u0026#34; + c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#34;通过ID获取 li 标签\u0026#34; + c2);\r\u0026lt;/script\u0026gt;\r  显示结果：\ninnerHTML用于获取或修改p标签内容\n1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\rc1.innerHTML = \u0026#39;我是修改后的p标签\u0026#39;;\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\r\u0026lt;/script\u0026gt;\r  显示结果：\n改变HTML样式 基本语法格式：Object.style.property=str;\n1 2 3 4 5 6 7  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.style.color = \u0026#39;red\u0026#39;\rc1.style.fontSize = \u0026#39;30px\u0026#39;\rc1.style.fontFamily = \u0026#39;隶书\u0026#39;\rc1.style.backgroundColor = \u0026#39;#cccccc\u0026#39;\r\u0026lt;/script\u0026gt;\r  显示效果：\n改变类选择器 格式object.className = classname\n1 2  var c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.className = \u0026#39;test\u0026#39;\r  显示结果：\n通过name属性获取元素 格式document.getElementsByName(str);\n1 2 3  var c1 = document.getElementsByName(\u0026#39;myname\u0026#39;);\rdocument.write(c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#39;数组的长度为\u0026#39; + c1.length);\r  显示结果：\n通过标签名字获取标签 格式：document.getElementsByTagName(str);\n1 2  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\r  显示结果：\nID是唯一的。\nName可以重复。\nTagName是某一标签类的集合。\n获取属性值 格式：elementNode.getAttribute(name)\n1 2 3 4 5 6 7 8  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  设置新属性 elementNode.setAttribute(name,value)\n1 2 3 4 5 6 7 8 9 10 11 12  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text == \u0026#34;C Sharp\u0026#34;) {\rc1[i].setAttribute(\u0026#39;title\u0026#39;, \u0026#39;C#\u0026#39;)\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;)\r}\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  节点对象属性 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：\n  nodeName : 节点的名称\n  nodeValue ：节点的值\n  nodeType ：节点的类型\n  1 2 3 4 5 6  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的名称:\u0026#34; + c1[i].nodeName)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的类型:\u0026#34; + c1[i].nodeType)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的值:\u0026#34; + c1[i].nodeValue)\r}\r  访问子节点 elementNode.childNodes用于访问子节点\nnode.firstChild用于访问第一个子节点\nnode.lastChild用于访问最后一个子节点\n访问父节点 elementNode.parentNode用于访问父节点\nelementNode.parentNode.parentNode用于访问祖节点\n访问兄弟节点   nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。nodeObject.nextSibling\n  previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。nodeObject.previousSibling \n   如果无兄弟节点，则该属性返回 null。\n 插入节点 appendChild(newnode)\n1 2 3 4  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.appendChild(newNode)\r  insertBefore() 方法可在已有的子节点前插入一个新的子节点。\ninsertBefore(newnode,node);\n1 2 3 4 5  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rvar lNode = document.getElementById(\u0026#39;List1\u0026#39;).firstChild\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.insertBefore(newNode, lNode)\r  删除节点 removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。\nnodeObject.removeChild(node)\n node ：必需，指定需要删除的节点。\n 替换元素节点 replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。\nnode.replaceChild (newnode,oldnew ) \n newnode : 必需，用于替换 oldnew 的对象。\noldnew : 必需，被 newnode 替换的对象。\n 创建元素节点 createElement()方法可创建元素节点。此方法可返回一个 Element 对象。\ndocument.createElement(tagName)\ntagName：字符串值，这个字符串用来指明创建元素的类型。\n 要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。\n 创建文本节点 createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。\ndocument.createTextNode(data)\ndata : 字符串值，可规定此节点的文本。\n","description":"目录 基础页面，通过ID获取元素，改变HTML样式，改变类选择器，通过name属性获取元素，通过标签名字获取标签，获取属性值，设置新属性节点，对象属性访问子节点，访问父节点，访问兄弟节点，插入节点，删除节点，替换元素节点，创建元素节点，创建文本节点","id":5,"section":"posts","tags":["javaScript","html"],"title":"JavaScript DOM 操作","uri":"https://eternidad33.github.io/zh/posts/javascript-dom%E6%93%8D%E4%BD%9C/"},{"content":"项目配置 @Value(“${变量名}”) 变量名：配置文件中的全局变量\n1 2 3 4  @Value(\u0026#34;${name}\u0026#34;)\rprivate String name;\r@Value(\u0026#34;${desc}\u0026#34;)\rprivate String desc;\r  yml配置文件中的配置\n1 2  name:维吉尔desc:你好，${name}！  @ConfigurationProperties(prefix = \u0026ldquo;对象名\u0026rdquo;) @ConfigurationProperties(prefix = \u0026ldquo;person\u0026rdquo;)注解要和@Component一起用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  @Component\r@ConfigurationProperties(prefix = \u0026#34;person\u0026#34;)\rpublic class Person {\rprivate String name;\rprivate int age;\rprivate String sex;\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\r@Override\rpublic String toString() {\rfinal StringBuffer sb = new StringBuffer(\u0026#34;Person{\u0026#34;);\rsb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#34;, age=\u0026#34;).append(age);\rsb.append(\u0026#34;, sex=\u0026#39;\u0026#34;).append(sex).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#39;}\u0026#39;);\rreturn sb.toString();\r}\r}\r  yml配置文件中的对象配置\n1 2 3 4  person:name:Vigilrage:23sex:男  调用方式，会用到@Autowired和@GetMapping(\u0026quot;/person\u0026quot;)\n1 2 3 4 5 6 7  @Autowired\rprivate Person person;\r@GetMapping(\u0026#34;/person\u0026#34;)\rpublic String printPerson() {\rreturn this.person.toString();\r}\r  请求方式    代码 说明 举例     @GetMapping(\u0026quot;/url\u0026quot;) get请求 @GetMapping(\u0026quot;/user/{id}\u0026quot;)   @PostMapping(\u0026quot;/url\u0026quot;) post请求 @PostMapping(\u0026quot;/user\u0026quot;)   @PutMapping(\u0026quot;/url\u0026quot;) put请求 @PutMapping(\u0026quot;/user/{id}\u0026quot;)    Controller相关注解 @Controller 1 2 3 4 5 6 7  @Controller\rpublic class HelloController {\r@GetMapping(\u0026#34;/index\u0026#34;)\rpublic String printIndex() {\rreturn \u0026#34;index\u0026#34;;\r}\r}\r  直接用可解析HTML\n@ResponseBody 与@Controller配合使用\n1 2 3 4 5 6 7 8  @Controller\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\r@ResponseBody\rpublic String sayHello() {\rreturn desc;\r}\r}\r  @RestController @RestController=@Controller+@ResponseBody\n1 2 3 4 5 6 7  @RestController\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\rpublic String sayHello() {\rreturn desc;\r}\r}\r  获取参数 @PathVariable(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4  @GetMapping(\u0026#34;/user/{id}\u0026#34;)\rpublic UserEntity findId(@PathVariable(\u0026#34;id\u0026#34;) Integer id) {\rreturn repository.findById(id).orElse(null);\r}\r  @RequestParam(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4 5 6 7 8 9  @PostMapping(\u0026#34;/user\u0026#34;)\rpublic UserEntity create(@RequestParam(\u0026#34;age\u0026#34;) Integer age,\r@RequestParam(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;sex\u0026#34;) String sex) {\rUserEntity userEntity = new UserEntity();\ruserEntity.setAge(age);\ruserEntity.setName(name);\ruserEntity.setSex(sex);\rreturn repository.save(userEntity);\r}\r  数据库相关 @Entity 表的定义\n@Id 设置主键\n@GeneratedValue 设置自增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  @Entity\rpublic class UserEntity {\r@Id\r@GeneratedValue\rprivate Integer id;\rprivate String name;\rprivate String sex;\rprivate Integer age;\rpublic UserEntity() {\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\rpublic Integer getAge() {\rreturn age;\r}\rpublic void setAge(Integer age) {\rthis.age = age;\r}\r}\r   在IDEA中声明@Entity后，左侧会有数据库的标志\n @Transactional 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Transactional\rpublic void createTwo() {\rUserEntity userEntity1 = new UserEntity();\ruserEntity1.setAge(12);\ruserEntity1.setName(\u0026#34;wasd\u0026#34;);\ruserEntity1.setSex(\u0026#34;sssss\u0026#34;);\rrepository.save(userEntity1);\rUserEntity userEntity2 = new UserEntity();\ruserEntity2.setAge(1314);\ruserEntity2.setName(\u0026#34;zxcvbnm\u0026#34;);\ruserEntity2.setSex(\u0026#34;ddddddd\u0026#34;);\rrepository.save(userEntity2);\r}\r  数据库表的引擎必须为INNODB才可进行事务管理\n","description":"Spring Boot常用注解项目配置@Value(“${变量名}”)变量名：配置文件中的全局变量","id":6,"section":"posts","tags":["java","springboot"],"title":"SpringBoot 必备注解","uri":"https://eternidad33.github.io/zh/posts/springboot%E5%BF%85%E5%A4%87%E6%B3%A8%E8%A7%A3/"},{"content":"[toc]\n简易的图书管理系统 项目简介 推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql\n用到的知识：Java，MySQL\n源码已上传至码云\n项目整体架构 源码目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  PS E:\\IdeaProjects\\BookManager\\src\u0026gt; tree /f\r卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r├─dao\r│ BookDao.java\r│ BookTypeDao.java\r│ UserDao.java\r│\r├─entity\r│ Book.java\r│ Booktype.java\r│ User.java\r│\r├─images\r│ book.png\r│ susu.jpg\r│\r├─META-INF\r│ MANIFEST.MF\r│\r├─util\r│ DbUtil.java\r│ StringUtil.java\r│\r└─view\rAbout.java\rAbout.jfd\rBookAddFrm.java\rBookAddFrm.jfd\rBookTypeAddFrm.java\rBookTypeAddFrm.jfd\rBookTypeManagerFrm.java\rBookTypeManagerFrm.jfd\rLogin.form\rLogin.java\rMainFrm.java\rMainFrm.jfd\r  由此可见，本项目也是采用的 MVC 架构，dao包用于操作数据库，entity包包含本项目的实体类，images包是本项目用到的图片，META-INF包是生成 Jar 包时产生的文件夹，util包包含本项目用到的工具类，view包是本项目的视图层，用于设计窗口显示。\n项目中各类的依赖关系如下图\n具体实现 util包 本项目的工具包，包含两个工具类\nDbUtil.java主要是设计了数据库的驱动，地址，用户名及密码，和控制数据库的连接与断开\nStringUtil.java只是用于判断字符串是否为空，只有空格也算为空\nentity包 此包包含了数据库表的实体对象，可以自己写，也可以通过 idea 的EasyCode插件进行代码生成，但是后边要用到的必要的构造方法要自己写。\n大多数情况下都是简单类包含 Getter 和 Setter 方法，如下是EasyCode插件生成的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  public class Booktype implements Serializable {\rprivate static final long serialVersionUID = -43707012852599825L;\rprivate Integer id;\rprivate String booktypename;\r@Override\rpublic String toString() {\rreturn this.booktypename;\r}\rprivate String booktypedesc;\rpublic Booktype(String booktypename, String booktypedesc) {\rthis.booktypename = booktypename;\rthis.booktypedesc = booktypedesc;\r}\rpublic Booktype() {\rsuper();\r}\rpublic Booktype(Integer id, String booktypename, String booktypedesc) {\rthis(booktypename, booktypedesc);\rthis.id = id;\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getBooktypename() {\rreturn booktypename;\r}\rpublic void setBooktypename(String booktypename) {\rthis.booktypename = booktypename;\r}\rpublic String getBooktypedesc() {\rreturn booktypedesc;\r}\rpublic void setBooktypedesc(String booktypedesc) {\rthis.booktypedesc = booktypedesc;\r}\r}\r  dao包 进行数据库的访问\n类中的方法定义形式基本为public 返回类型 方法名(Connection conn, 实体类 对象名) throws SQLException\n例如用户登录的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public User login(Connection connection, User user) throws SQLException {\rUser resultUser = null;\rString sql = \u0026#34;select * from table_user where userName=? and password=?\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, user.getUserName());\rpsmt.setString(2, user.getPassword());\rResultSet resultSet = psmt.executeQuery();\rif (resultSet.next()) {\rresultUser = new User();\rresultUser.setId(resultSet.getInt(\u0026#34;id\u0026#34;));\rresultUser.setUserName(resultSet.getString(\u0026#34;userName\u0026#34;));\rresultUser.setPassword(resultSet.getString(\u0026#34;password\u0026#34;));\r}\rreturn resultUser;\r}\r  步骤总结：\n  其中 SQL 语句中的要查找的值要用?代替，方便后面设置\nString sql = \u0026quot;select * from table_user where userName=? and password=?\u0026quot;;\n  然后创建 SQL 语句的游标对象\npsmt，PreparedStatement psmt = connection.prepareStatement(sql);\n  设置 SQL 语句中的变量值，第几个?为几，索引就是几，没有 0\npsmt.setString(1, user.getUserName());\n  执行查询语句，并返回ResultSet对象用于保存查询结果\nResultSet resultSet = psmt.executeQuery();\n  然后根据需求进行其他操作\n  BookDao类的设计如下，dao包下的其他类类似\n添加图书\n1 2 3 4 5 6 7 8 9 10 11  public static int add(Connection connection, Book book) throws SQLException {\rString sql = \u0026#34;insert into book values(null,?,?,?,?,?,?)\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setInt(4, book.getBooktypeid());\rpsmt.setString(5, book.getBookdesc());\rpsmt.setFloat(6, book.getPrice());\rreturn psmt.executeUpdate();\r}\r  添加成功返回 1，添加失败返回 0\n删除图书\n1 2 3 4 5 6  public static int delete(Connection conn, String id) throws SQLException {\rString sql = \u0026#34;delete from book where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, id);\rreturn psmt.executeUpdate();\r}\r  删除成功返回 1，删除失败返回 0\n修改图书\n1 2 3 4 5 6 7 8 9 10 11 12  public static int update(Connection conn, Book book) throws SQLException {\rString sql = \u0026#34;update book set bookName=?,author=?,sex=?,price=?,bookTypeid=?,bookDesc=? where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setFloat(4, book.getPrice());\rpsmt.setInt(5, book.getBooktypeid());\rpsmt.setString(6, book.getBookdesc());\rpsmt.setInt(7, book.getId());\rreturn psmt.executeUpdate();\r}\r  修改成功返回 1，修改失败返回 0\n查询图书\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static ResultSet list(Connection conn, Book book) throws SQLException {\rStringBuffer sb = new StringBuffer(\u0026#34;select * from book b,table_booktype bt where b.bookTypeId=bt.id\u0026#34;);\rif (!StringUtil.isEmpty(book.getBookname())) {\rsb.append(\u0026#34; and b.bookName like \u0026#39;%\u0026#34; + book.getBookname() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (!StringUtil.isEmpty(book.getAuthor())) {\rsb.append(\u0026#34; and b.author like \u0026#39;%\u0026#34; + book.getAuthor() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (book.getBooktypeid() != null \u0026amp;\u0026amp; book.getBooktypeid() != -1) {\rsb.append(\u0026#34; and b.bookTypeId=\u0026#34; + book.getBooktypeid());\r}\rPreparedStatement psmt = conn.prepareStatement(sb.toString());\rreturn psmt.executeQuery();\r}\r  返回查询结果\nview包 视图层是利用的 swing 组件设计，但这个不是本项目的重点，因为 Java 的 swing 已经很少有人用了，可以直接使用 idea 中的JFormDesigner插件进行拖拉控件，使用时一定要注意将框架的布局类型设为null Layout，大小设为Design size\n我们只需设计按钮和表格的触发事件\n例如图书添加事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  private void button1ActionPerformed(ActionEvent e) {\rString bookName = this.booknameTXT.getText();\rString author = this.bookAuthorTXT.getText();\rString price = this.bookPriceTXT.getText();\rString bookDesc = this.bookDescTXT.getText();\rif (StringUtil.isEmpty(bookName)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书名称不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(author)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书作者不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(price)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格不能为空\u0026#34;);\rreturn;\r}\rtry {\rfloat pricef = Float.parseFloat(price);\r} catch (NumberFormatException numberFormatException) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格应为数字\u0026#34;);\rreturn;\r}\rString sex = \u0026#34;\u0026#34;;\rif (this.man.isSelected()) {\rsex = \u0026#34;男\u0026#34;;\r} else {\rsex = \u0026#34;女\u0026#34;;\r}\rBooktype booktype = (Booktype) this.booktypecb.getSelectedItem();\rassert booktype != null;\rint booktypeId = booktype.getId();\rBook book = new Book(bookName, author, sex, Float.parseFloat(price), booktypeId, bookDesc);\rConnection conn = null;\rtry {\rconn = dbUtil.getConnection();\rint addNum = BookDao.add(conn, book);\rif (addNum == 1) {\rJOptionPane.showMessageDialog(null, \u0026#34;添加成功\u0026#34;);\rresetValue();\r} else {\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r}\r} catch (Exception ex) {\rex.printStackTrace();\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r} finally {\rtry {\rconn.close();\r} catch (SQLException ex) {\rex.printStackTrace();\r}\r}\r}\r  设计思想：\n 判断必需的输入框是否为空，以及类型是否一致 获取各输入框的数据 根据数据实例化对象 调用dao包中对应的方法进行操作  其他的删除，修改，查询的操作思想基本和添加的方法一样\n项目总结 项目中使用到了 Java 的 swing 技术，但是现在已经很少有人会用 Java 去写软件界面了，Java 不能像 C#那样拖拉控件设计界面，但是可以在 idea 中安装JFormDesigner插件实现 C#那样的效果了。\n MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。\n MVC 即围绕着数据库进行操作，本项目只是简单地实现了对数据库的增删改查，比较适合新手练习。\n","description":"推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql用到的知识：Java，MySQL工具：IDEA源码已上传至码云点击查看预览效果","id":7,"section":"posts","tags":["java","mysql"],"title":"简易的图书管理系统(Java+MySQL8.0)","uri":"https://eternidad33.github.io/zh/posts/%E7%AE%80%E6%98%93%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fjava+mysql8.0/"},{"content":"小程序基本架构 基本架构 利用 app.json文件对小程序进行全局配置\n利用同名.json文件对本页面窗口表现进行配置\n全局配置\n   属性 类型 必填 描述     pages string 是 页面路径列表   window Object 否 全局的默认窗口表现   tabBar Object 否 底部 tab 栏的表现   networkTimeout object 否 网络超时时间    Pages 配置\npages 用于指定小程序由哪些页面组成，每一项都对应一个页面的路径（含文件名）信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的.json，.js，.wxml，.wxss四个文件进行处理。数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。\nWindow 配置\n   属性 类型 描述     navigationBarBackground Color HexColor 导航栏背景颜色，如#000000   navigationBarTextStyle string 导航栏标题颜色，仅支持 black/ white   navigationBarTitleText string 导航栏标题文字内容   backgroundColor HexColor 窗口的背景色    tabBar 配置\n   属性 类型 描述     color HexColor tab 上的文字的默认颜色   selectedColor HexColor tab 上选中文字的颜色   backgroundColor HexColor tab 的背景色   borderStyle string tabbar 上边框的颜色，仅支持 black / white    list 配置\n   属性 类型 必填 说明     pagePath string 是 页面路径，必须在 pages 中先定义   text string 是 tab 上按钮文字   iconPath string 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px*81px，不支持网络图片   selectedIconPath string 否 选中时的图片路径    执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13  //app.js\rApp({\r//\r onLaunch: function() {\rconsole.log(\u0026#34;【app.js】小程序初始化\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【app.js】小程序显示\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【app.js】小程序隐藏\u0026#34;);\r}\r});\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //index.js\rPage({\ronLoad: function() {\rconsole.log(\u0026#34;【index.js】onLoad页面加载\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【index.js】onShow页面显示\u0026#34;);\r},\ronReady: function() {\rconsole.log(\u0026#34;【index.js】onRead页面渲染\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【index.js】onHide页面隐藏\u0026#34;);\r},\ronUnload: function() {\rconsole.log(\u0026#34;【index.js】onUnLoad页面卸载\u0026#34;);\r}\r});\r  显示效果：\n小程序整个生命周期的执行基本顺序是：\n","description":"小程序基本架构 基本架构 利用 `app.json`文件对小程序进行全局配置 利用同名`.json`文件对本页面窗口表现进行配置","id":8,"section":"posts","tags":null,"title":"小程序基本架构","uri":"https://eternidad33.github.io/zh/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"},{"content":"作为一个学习计算机相关知识的人，如果不经常写博客，就容易把刚学到的知识忘记，写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用 Markdown，这样可以很好地使我们的博客页面变得更加美观，这篇文章介绍的就是一些使用的 Markdown 使用技巧。\n推荐工具：Typora，VScode(插件Markdown-preview-enhanced)\n段落格式 字体设置 Markdown 代码\n1  \u0026lt;font size=10 face=\u0026#34;隶书\u0026#34; color=#ff0000\u0026gt;红色 10 号隶书\u0026lt;/font\u0026gt;   运行结果：\n红色 10 号隶书\n粗斜体   用*表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  用下划线表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  下划线 Markdown 代码：\n1  \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt;   显示结果为：\n带下划线文本\n删除线 Markdown 代码：\n1  ~~删除线~~   显示结果为：\n删除线\n脚注格式 Markdown 代码：\n1 2  创建脚注格式是这样的 [^lorem]。 [^lorem]: Lorem ipsum dolor.   显示结果为：\n创建脚注格式是这样的 1。\n引用格式 嵌套结构 Markdown 代码：\n1 2 3 4 5  \u0026gt; 最外层 \u0026gt; \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; 第二层嵌套   显示结果：\n 最外层\n 第一层嵌套\n 第二层嵌套\n   引用中使用列表 Markdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026gt; 引用中使用列表 \u0026gt; \u0026gt; 1. 有序列表第一项 \u0026gt; 2. 有序列表第二项 \u0026gt; 3. 有序列表第三项 \u0026gt; \u0026gt; - 无序列表第一项 \u0026gt; - 无序列表第二项 \u0026gt; - 无序列表第三项   显示结果：\n 引用中使用列表\n 有序列表第一项 有序列表第二项 有序列表第三项   无序列表第一项 无序列表第二项 无序列表第三项   列表项中的引用 Markdown 代码：\n1 2 3 4 5  1. 第一项 \u0026gt; 第一行引用 \u0026gt; 第二行引用 2. 第二项 3. 第三项   显示结果：\n 第一项  第一行引用\n第二行引用\n  第二项 第三项  代码格式 行内代码 Markdown 代码：\n1  Python 代码`print(\u0026#39;helloworld\u0026#39;)`，控制台打印 helloworld   显示结果：\nPython 代码print('helloworld')，控制台打印 helloworld\n代码块  按 Tab 键或四个空格 用```包括起来，第一个后面加上代码语言，可以高亮显示  图片样式  直接放置图片\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png)   显示结果：\n 鼠标悬浮时，显示名称\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png \u0026#34;戴帽子的犬夜叉\u0026#34;)   显示结果：\n 使用 img 标签定义图片的宽高\nMarkdown 代码： 1  \u0026lt;img src=\u0026#39;https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png\u0026#39; width=50% height=50%\u0026gt;   显示结果：\n  链接样式   直接写\nMarkdown 代码：\n1  [百度一下，你就知道](https://www.baidu.com)   显示结果：\n百度一下，你就知道\n  链接用 a 作为网址变量,然后为变量赋值\nMarkdown 代码：\n1 2  [百度一下，你就知道][a] [a]: https://www.baidu.com   显示结果：\n百度一下，你就知道\n  表格样式 Markdown 代码：\n1 2 3 4  | 左对齐 | 居中对齐 | 右对齐 | | :----- | :------: | -----: | | 1 | 2 | 3 | | 4 | 5 | 6 |   显示结果：\n| 左对齐 | 居中对齐 | 右对齐 |\n| :\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;: | \u0026mdash;\u0026ndash;: |\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n支持的 HTML 标签 Markdown 支持很多 HTML 标签,下面列举几个常用的标签\nMarkdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026lt;kbd\u0026gt;Win\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Prtsc\u0026lt;/kbd\u0026gt; 快速截图 \u0026lt;em\u0026gt;强调\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;加强强调\u0026lt;/strong\u0026gt; \u0026lt;b\u0026gt;加粗\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;倾斜\u0026lt;/i\u0026gt; 上标如，3\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; 下标，如 CO\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; 换行符\u0026lt;br\u0026gt; 分割线\u0026lt;hr\u0026gt;   显示结果：\nWin+Prtsc 快速截图\n强调\n加强强调\n加粗\n倾斜\n上标如，32\n下标，如 CO2\n换行符\n分割线\n转义字符 以下这些符号前面加上反斜杠\\来帮助插入普通的符号：\n\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号  特殊符号    符号 代码     © \u0026amp;copy;   ™ \u0026amp;trade;   \u0026amp; \u0026amp;amp;   \u0026lt; \u0026amp;lt;   \u0026gt; \u0026amp;gt;   £ \u0026amp;pound;   ¥ \u0026amp;yen;   € \u0026amp;euro;   ® \u0026amp;reg;   ± \u0026amp;plusmn;   § \u0026amp;sect;   X² X\u0026amp;sup2;   Y³ Y\u0026amp;sup3;   ¾ \u0026amp;frac34;   « \u0026amp;laquo;   » \u0026amp;raquo;   37ºC 37\u0026amp;ordm;C     Lorem ipsum dolor. \u0026#x21a9;\u0026#xfe0e;\n   ","description":"写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用Markdown","id":9,"section":"posts","tags":["markdown"],"title":"用Markdown代码写出好看的页面","uri":"https://eternidad33.github.io/zh/posts/%E7%94%A8markdown%E4%BB%A3%E7%A0%81%E5%86%99%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E9%A1%B5%E9%9D%A2/"},{"content":"开发工具 IDEA 从入门到爱不释手-课程笔记 1-1 代码生成 Generate  Alt+Insert,或者右键-Generate：生成 getter 或 setter  1-2 高效的代码编辑技能    快捷键 功能     Ctrl+Alt+L 格式化   Ctrl+D 复制光标所在行   Alt+Shift+上/下 移动所在行或所选行    1-3 Demo 项目介绍 分层结构\n Config：所有的配置 Controller：请求入口 Service：逻辑层 Mapper：持久层 Domain(Po)：表映射实体 Dto：数据传输对象  1-4 git 更多操作 顶部添加 git 提交选项\n1-5 快速查找和替换    快捷键 功能     Ctrl+F 查找   Ctrl+R 替换   Ctrl+Shift+F 全局查找   Ctrl+Shift+R 全局替换   Ctrl+Shift+N 查找文件   Ctrl+Shift+A 查找所有的菜单或操作   双击 shift 万能查找    2-1 代码模板  psvm：生成主函数 sout：System.out.println(); fori：for 循环 fore：foreach 循环 Live Templates postfix：先打变量或表达式，再打快捷键  2-2 代码重构 Refactor    快捷键 功能     Shift+F6 代码重命名   Ctrl+Alt+V 自动生成返回值   Alt+Delete 安全删除   F5 文件复制粘贴     一个方法只负责实现一个功能  2-3 快速跳转    快捷键 功能     Ctrl+左/右 跳过一个单词   Ctrl+G 快速跳转到指定行   Alt+左/右 左右切换 Tabs   Ctrl+E 查看最近浏览过的文件    3-1 更多实用技巧  Ctrl+Alt+Shift+J ：选中文件中所有和被选中的代码一样的代码  ","description":"推荐几个比较好用的插件 图片背景`Background Image Plus` 彩虹括号`Rainbow Brackets` 主题`Material Theme ul` 记录编码时长`wakatime` 统计项目代码行数`Statistic`","id":10,"section":"posts","tags":["idea"],"title":"idea使用技巧总结","uri":"https://eternidad33.github.io/zh/posts/idea%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"content":"m10c 主题配置 主题地址：GitHub 仓库地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  title = \u0026#34;Vigilr的博客\u0026#34;\r[params]\rdescription = \u0026#34;宁为玉碎，不为瓦全\u0026#34;\ravatar = \u0026#34;avatar.jpg\u0026#34;\r[[params.social]]\rname = \u0026#34;github\u0026#34;\rurl = \u0026#34;https://github.com/eternidad33\u0026#34;\r[[params.social]]\rname = \u0026#34;mail\u0026#34;\rurl = \u0026#34;mailto:3496655347@qq.com\u0026#34;\r[[params.social]]\rname = \u0026#34;link\u0026#34;\rurl = \u0026#34;https://blog.csdn.net/qq_42907802\u0026#34;\r  主题仓库要下载到站点目录/themes下\n文章目录为：站点目录/content/posts\n头像的路径：站点目录/static/avatar.jpg\n只是简单地设计了几个链接，链接的图标在主题目录/data/m10c/icons.json文件中定义\n博客启动：hugo server -t hugo-theme-m10c -D\n浏览器访问:http://localhost:1313/\n至此博客启动成功\n","description":"m10c是一款比较简洁的主题，而且容易配置","id":11,"section":"posts","tags":["hugo","theme"],"title":"m10c主题配置","uri":"https://eternidad33.github.io/zh/posts/m10c%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"content":"Hugo 博客搭建 本地部署 推荐视频：手把手教你从 0 开始搭建自己的个人博客 |第二种姿势 | hugo\n  下载 Hugo，下载地址：GitHub\n  配置环境变量\n  创建自己的站点文件夹hugo new site myHugoSite\n生成的目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  PS C:\\Users\\Administrator\\Desktop\\myHogoSite\u0026gt; tree /f\r文件夹 PATH 列表\r卷序列号为 2A8A-01A5\rC:.\r│ config.toml\r│\r├─archetypes\r│ default.md\r │\r├─content\r├─data\r├─layouts\r├─static\r└─themes\r    新建文章\n在 content 目录下生成博客hugo new 我的第一篇博客.md\n在 content/posts 目录下生成博客hugo new posts/我的第二篇博客.md\n  下载m10c 主题并配置\n  部署到 GitHub  创建远程仓库,仓库名必须为用户名.github.io 生成 public 文件夹hugo -t 主题名 -b https://用户名.github.io -D 然后就是一系列 git 操作 进入 public，初始化 git 仓库 添加到暂存区 提交仓库 连接远程仓库 推送到远程仓库  不清楚的命令可以通过hugo help查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  $ hugo help\rhugo is the main command, used to build your Hugo site.\rHugo is a Fast and Flexible Static Site Generator\rbuilt with love by spf13 and friends in Go.\rComplete documentation is available at http://gohugo.io/.\rUsage:\rhugo [flags]\rhugo [command]\rAvailable Commands:\rconfig Print the site configuration\rconvert Convert your content to different formats\rdeploy Deploy your site to a Cloud provider.\renv Print Hugo version and environment info\rgen A collection of several useful generators.\rhelp Help about any command\rimport Import your site from others.\rlist Listing out various types of content\rmod Various Hugo Modules helpers.\rnew Create new content for your site\rserver A high performance webserver\rversion Print the version number of Hugo\rFlags:\r-b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/\r--templateMetrics display metrics about template executions\r--templateMetricsHints calculate some improvement hints when combined with --templateMetrics\r-t, --theme strings themes to use (located in /themes/THEMENAME/)\r--themesDir string filesystem path to themes directory\r--trace file write trace to file (not useful in general)\r-v, --verbose verbose output\r--verboseLog verbose logging\r-w, --watch watch filesystem for changes and recreate as needed\rAdditional help topics:\rhugo check Contains some verification checks\rUse \u0026#34;hugo [command] --help\u0026#34; for more information about a command.\r  ","description":"本文介绍如何搭建Hugo个人博客","id":12,"section":"posts","tags":["hugo"],"title":"Hugo博客搭建","uri":"https://eternidad33.github.io/zh/posts/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"推荐书籍：\n 《Java 编程的逻辑》 《疯狂 Java 讲义精粹》  Java 基础 从当前所在路径加载类SET ClASSPATH=.\nPATH：是操作系统提供的路径配置，定义所有可执行程序的路径\nCLASSPATH：是由 JRE 提供的，用于定义 Java 程序解释时类加载路径CLASSPATH=路径的命令形式来进行定义；\nJava 1.9 之后才有的Jshell\nint的取值范围为-2147483648 到 2147483647\n大写字母范围：A(65)~Z(90)\n小写字母范围：a(97)~z(122)\n数值范围：\u0026lsquo;0\u0026rsquo;(48)~'9\u0026rsquo;(57)\nthis关键字\nthis():调用无参的构造函数\nthis(name):调用参数为 name 的构造函数\nthis(\u0026hellip;):必须放在首行\nStatic 属性由类名直接调用\nstatic 方法只允许调用 static 属性或 static 方法\n非 static 方法允许调用 static 属性或 static 方法\nstatic 的定义的方法或属性都不是代码编写之初所需要考虑的内容，只有在回避实例化对象描述公共属性的情况下才会考虑 static 定义的属性或者是方法\n静态代码块最先执行，而且只会执行一次，用于对静态属性的初始化，构造块会优于构造方法先执行\n数组 int数组初始化默认为 0\n必须实例化数组才能使用数组下标\nforeach循环可以避免使用下标，\nforeach遍历二维数组\n返回数组的方法\n将数组封装成一个组件\n数组快速排序\n数组逆序\n数组相关的类库\n数组排序可以这样写java.util.Arrays.sort(data);\n系统自带的数组拷贝System.arraycopy(dataA,5,dataB,5,3);是将数组dataA中从索引为 5，长度为 3 的一段数组复制到dataB中索引位置为 5 的地方，并替换掉相应长度\n可变参数\n在方法参数列表中...表示可变参数\n可变参数的作用在于，在以后进行一些程序设计或者开发者调用的时候，利用此种形式可以避免数组的传递操作\n对象数组定义格式如下：\n 动态初始化：类 对象数组名称[]=new 类[长度]，每一个元素的内容都是 null 静态初始化：类 对象数组名称[]=new 类[]{实例化对象，实例化对象，实例化对象\u0026hellip;}  String java 源代码目录:C:\\Program Files (x86)\\Java\\jdk-9\\lib\\src.zip\nJDK 1.8 及以前的 String 支持类\nJDK 1.9 的 String 支持类\nJDK 1.8 及以前 String 类保存的是字符数组\nJDK 1.9 及以后 String 类保存的是字节数组\nString 对象的比较\n直接为字符串赋值会是字符串变量指向字符串池中的内存地址\nnew String()会开辟新的内存\n将所有小写字母转换成大写\n先将字符串转换成字符数组，然后每个字符的编码-32\n判断是否全为数字\n先将字符串转换成字符数组，if (result[i] \u0026lt; '0' || result[i] \u0026gt; '9')\n然后挨个判断每个字符\n字符串的比较\nstr.equals(str1)区分大小写比较\nstr.equalsIgnoreCase(str1)不区分大小写比较\nstr.compareTo(str1)字符串的大小的比较\nstr.compareToIgnoreCase(str1)忽略大小写的字符串大小比较\n字符串的查找\nstr.contains(\u0026quot;hello\u0026quot;)判断字符串中是否含有 hello\nstr.indexOf(\u0026quot;Java\u0026quot;)查询 Java 是否存在于 str 中，存在返回首字母索引位置，不存在返回-1\nstr.lastIndexOf(\u0026quot;Java\u0026quot;)从后向前查询\nstr2.endsWith(\u0026quot;com\u0026quot;)判断是否以 com 结尾\nstr2.startsWith(\u0026quot;www\u0026quot;)判断是否以 www 开头\n字符串的替换\nstr.replaceAll(\u0026quot;Java\u0026quot;, \u0026quot;Python\u0026quot;)将全部的 Java 替换成 Python\nstr.replaceFirst(\u0026quot;Java\u0026quot;, \u0026quot;Python\u0026quot;)将第一个 Java 替换成 Python\n字符串的拆分\nstr.split(\u0026quot; \u0026quot;)以空格全部拆分，返回字符串数组\nstr.split(\u0026quot; \u0026quot;,2)以空格拆分成 2 个，返回字符串数组\nstr1.split(\u0026quot;\\\\.\u0026quot;)拆不开的情况要用\u0026rdquo;\\\u0026ldquo;进行转义\n字符串的截取\nstr.substring(startIndex,endIndex)截取str从startIndex到endIndex的字符串片段\n字符串的格式化\nformat 是一个静态方法,直接通过String 类调用String.format(\u0026quot;姓名：%s，年龄：%d，分数：%5.2f\u0026quot;,name,age,score)\n其他字符串相关的方法\nstr.concat(str2)字符串的连接\nstr.isEmpty()判断字符串内容是否为空\nstr.trim()去掉字符串中所有空格\nstr.toUpperCase()全部转换成大写\n(str.toLowerCase()全部转换成小写\n面向对象 继承 public class object.Student extends object.PersonStudent 类继承 Person 所有共有的属性和方法\n子类被实例化时先调用父类的构造方法\nsuper(...)必须放在首行，this(...)也必须放在首行，所以两者不可同时出现\n多层继承\n理论上层数最多不能超过三层\n 父类的私有方法不存在覆写 子类调用有父类覆写的方法要加 super     Overloading Override     重载 覆写   方法名称相同，参数的类型及个数不同 方法名称，参数类型及个数，返回值相同   没有权限限制 被覆写方法不能拥有更严格的控制权限   发生在一个类中 发生在继承关系类中     在程序类中使用 this 表示先从本类查找所需要的的属性或方法，如果本类中不存在则查找父类定义，如果使用 super 则不查找子类，直接查找父类\n fanal 代表不能被覆写的方法，常量\nAnnotation 注解\n@Override准确覆写\n@Deprecated 代表过时的类或方法\n@SuppressWarnings 压制警告\n多态 向上转型base f = new son()可以调用父类的方法和子类中重写父类的方法\n向下转型son1 s=(son)f不安全\ninstanceof\ninstanceof为了保证向下转型的正确性，用于在转型之前进行判断，判断某个实例是否是某个类的对象\nObject 类 Object 类是所有类型的父类，所以 Object 类可以接收所有子类的对象\ntoString()是 Object 自带的方法，所有继承类都可以使用\n 对象比较 equals() 判断对象是否为 null 判断是不是同一地址 判断 obj 是否转换为 person 判断内容是否相同  抽象类 抽象方法所在的类必须为抽象类，抽象类必须用abstract关键字来定义\n抽象类就是在普通类上追加了抽象方法\n抽象类是无法被实例化的\n 抽象类必须提供子类 抽象类的子类（非抽象类）一定要覆写抽象类中的全部抽象方法 抽象类的对象实例化可以通过子类向上转型的方式完成   抽象类自己无法直接实例化\n final不允许有子类，abstract必须有子类\n 抽象类中可以使用普通方法调用抽象方法\n 包装类 Int temp = new Int(10);装箱，将基本数据类型保存在包装类中\nint x = temp.intValue();拆箱，从包装类中获取基本数据类型\n 对象型的包装类，Boolen,Character 数值型的包装类,Byte,Short,Integer,Long,Float,Double  基本的装箱与拆箱操作\njdk1.5 之后可以实现自动装箱与拆箱操作，包装类可以直接参与数学运算\n接口 接口的组成以抽象方法和全局常量为主，使用关键字interface定义，接口的名称通常首字母加上I\n 接口需要被子类实现，关键字implements，一个子类可以实现多个接口 子类（非抽象类）必须覆写接口中的全部抽象方法 接口对象可以通过子类对象的向上转型实例化  接口的主要目的是一个子类可以实现多个接口\n接口不允许继承父类\n Object 类对象可以接收所有的数据类型，包括基本数据类型，类对象，接口对象，数组…\n方法不写访问权限也是public，不是default\n 接口可以通过extends集成多个父接口\n接口的使用：\n 进行标准设置 表示一种操作的能力 暴露远程方法视图  JDK1.8 之前，在进行设计时，一般子类不直接继承接口，中间加一个过渡抽象类\n接口的方法加上public default代表普通方法\n设计模式 代理设计模式\n一个接口提供两个子类，其中一个是真实业务操作类，另一个是代理业务操作类\n接口与抽象类的比较\n   接口 抽象类     interface 接口名称{} abstract class 抽象类名称{}   抽象方法，全局常量，普通方法，静态方法 构造，普通方法，静态方法，全局变量，成员   只有 public 权限 可以使用各类权限   子类通过implements关键字可以继承多个接口 子类通过extends关键字继承一个抽象类   接口不允许结成抽象类，可以继承多个父接口 抽象类可以实现若干个接口    使用时的共同点\n 抽象类或接口必须定义子类 子类必须覆写抽象类或接口的全部抽象方法 通过子类的向上转型实现抽象类或接口的对象实例化  单例设计\n懒汉式\n在第一次使用时进行实例化处理\n饿汉式\n在系统加载类时，实例化对象\n多例设计\n单例设计是指只保留一个实例化对象，多例设计是指保留多个实例化对象\n单例设计和多例设计的本质是相同的，一定都会在内部提供有static方法以返回实例化对象。都要进行构造方法私有化\n泛型 基本数据类型 → 包装类型 →Object类\n向上转型成Object类，容易出现ClassCastException异常\n  泛型之中只允许设置引用类型，如果要操作基本类型必须使用包装类 泛型对象实例化对象可以简化为Point\u0026lt;Integer\u0026gt; p1=new Point\u0026lt;\u0026gt;();   通配符\u0026lt;?\u0026gt;可以使泛型对象在方法中不被改变\n\u0026lt;T extends 类\u0026gt;:设置泛型的上限\n\u0026lt;T super 类\u0026gt;:设置泛型的下限\n泛型接口\n子类实现泛型接口两种方式：\n  在子类之中继续设置泛型定义\n  子类实现父接口是直接定义泛型类型\n  泛型方法\n泛型方法不一定出现在泛型类之中\n工厂模式中使用泛型方法\n包 同一个目录下不能有同名的程序文件，要创建不同的目录，不同的的目录就是不同的包\njavac -d . hello.java\n-d:表示要生成目录，目录为package定义的结构\n.:表示从当前目录开始生成\n类的名称：包.类名称\nimport util.Message;导入其他包的类\n当导入的几个包中出现重名的类时，定义类要用完整的类名称Message msg=new util.Message();。\n静态导入\nimport static util.Math.*;静态导入后可以直接使用util.Math中的方法\nJar\n想用javac编译，然后用jar打包\njar -cvf \u0026quot;名称.jar\u0026quot; 文件夹\n-c创建一个新的jar文件\n-v得到一个详细输出\n-f设置生成的Jar文件名称\n系统常见包\njava.lang包括 String，Number，Object 等\njava.lang.reflect反射机制处理包\njava.util工具类的定义，包括数据结构的定义\njava.io进行输入与输出流操作的包\njava.net网络程序开发的程序包\njava.sql进行数据库编程的开发包\njava.awt和java.swingJava 的图形界面开发包，awt 是重量级的组件，swing 是轻量级的组件\n访问控制权限\n面向对象的三个主要特点：封装，继承，多态\n   访问范围 private default protected public     同一包中的同一类 √ √ √ √   同一包中的不同类  √ √ √   不同包的子类   √ √   不同包的所有类    √    UML UML 是统一的建模语言，本质是利用图形化的形式来实现程序类关系的描述\n类图\n类一般用三层结构来显示\n   类名称     属性   方法    抽象类一般用斜体表示，也可以加上abstract\n属性的格式为访问权限 属性名称：属性类型\n访问权限的表示符为 public(+),private(-),protected(#)\n方法的格式为访问权限 方法名称():返回值结构\n子类实现接口用\u0026quot;三角和虚线\u0026rdquo;,类的继承用\u0026quot;三角和实线\u0026rdquo;,由子类指向父类\n时序图\n时序图用于描述代码的执行流程\n用例图\n用例图用于描述程序的执行分配\n枚举 枚举主要作用于定义有限个数对象的一种结构（多例设计），通过enum定义枚举类\n遍历枚举\nc.ordinal():c 在枚举类中的序号\nc.name():c 的值\n enum:是从 JDK1.5 之后提供的一个关键字，用来定义枚举类 Enum：是一个抽象类，所有使用enum关键字定义的类，默认继承此类  异常 处理异常的三种组合：try...catch，try...catch...finally，try...finally\n通过e.printStackTrace();获取完整的异常信息\n异常处理流程\n 产生异常，自动产生异常的实例化对象 如果不处理异常，JVM 默认打印异常信息，然后退出程序 如果存在异常处理，异常实例化对象将会被try语句捕获 catch匹配异常 执行finally  处理异常最大的类型是Throwable，有两个子类\n Error:此时程序还未执行出现的错误，开发者无法处理 Exception:程序中出现的异常  在多个异常处理的时候要将捕获范围大的异常放在捕获范围小的异常后面\n通过throws抛出异常\nthrow手动抛出异常\nthrow和throws的区别\n throw是在代码块中使用的，主要是手工对异常对象的抛出 throws是在方法定义上使用的，表示将此方法中可能产生的异常明确告诉给调用处，由调用处进行处理  RuntimeException是Exception的子类\n常见的RuntimeException： NullPointerException，ClassCastException，IndexOutOfBoundsException\n内部类 内部类的优点是可以轻松地访问外部类的私有属性，缺陷是破坏了类的结构\n内部类和外部类之间的操作不需要setter和getter，内部类实例化对象的格式外部类.内部类 内部类对象=new 外部类().new 内部类;\n如果Inner类加上private属性，则Inner无法在外部进行使用\nstatic的类和方法只能访问外部类的static的属性或方法.\nstatic定义的内部类并不常用，static定义内部接口更常用\n在方法中定义内部类\n方法中的内部类既能访问方法中的参数，又能访问外部类的私有成员属性。对于方法中参数的访问是从 JDK1.8 开始支持的。\n匿名内部类的使用\n 往往使用静态方法做一个内部的匿名内部类\n 匿名内部类只是一个没有名字的只能够使用一次的，并且结构固定的一个子类\n函数式编程 从 JDK1.8 开始提供有Lambda表达式的支持\nLambda表达式使用时有一个重要的实现要求就是 SAM(Single Abstract Method)只有一个抽象方法,该接口被称为函数式接口\nLambda 表达式的三种格式：\n 没有参数：()-\u0026gt;{}; 有参数：(参数,参数)-\u0026gt;{}; 只有一条返回语句(参数,参数)-\u0026gt;语句;  对方法的引用\n  引用静态方法：类名称::static 方法名称;\nIFunction\u0026lt;String, Integer\u0026gt; fun = String::valueOf;\n  引用某个实例对象的方法：实例化对象::普通方法;\nIFunction fun=\u0026quot;hellojava\u0026quot;::toUpperCase;\n  引用特定类型的方法：特定类::普通方法;\nIFunction\u0026lt;String\u0026gt; fun=String::compareTo;\n  引用构造方法：类名称::new\nIFunction\u0026lt;Person\u0026gt; fun=Person::new;\n  在java.util.funtion包中可以直接使用函数式接口\n  功能性函数式接口\n1 2  Function\u0026lt;String,Boolean\u0026gt; fun=\u0026#34;hellojava\u0026#34;::startsWith;\rSystem.out.println(fun.apply(\u0026#34;hello\u0026#34;));\r    消费型函数式接口:只能进行数据的处理，没有任何的返回\n1 2  Consumer\u0026lt;String\u0026gt; fun=System.out::println;\rfun.accept(\u0026#34;HelloJava\u0026#34;);\r    供给型函数式接口\n1 2  Supplier\u0026lt;String\u0026gt; fun=\u0026#34;hellojava\u0026#34;::toUpperCase;\rSystem.out.println(fun.get());\r    断言型函数式接口\n1 2  Predicate\u0026lt;String\u0026gt; fun=\u0026#34;hello\u0026#34;::equals;\rSystem.out.println(fun.test(\u0026#34;hello\u0026#34;));\r    链表 由于数组的长度是固定的，所以要引入链表\n链表节点的增加\n 判断增加的节点是否为空 判断根节点是否为空 添加节点  Link 类只负责数据的操作与根节点的处理而所有后续节点的处理全部都是有 Node 类负责。\n获取链表元素的个数\n  在ILink接口中增加size()方法\n  在LinkImpl中重写size()方法\n  在LinkImpl中增加私有属性count,然后在add(E e)加上this.count++;语句\n  判断链表是否为空\n既可以判断根节点是否为空，也可以判断长度是否为 0\n返回链表数据\n  在ILink接口中追加public Object[] toArray();方法\n  在LinkImpl中加上两个属性\n  在Node中递归获取数据\n  在LinkImpl中重写public Object[] toArray();方法\n  链表数据的返回是以数组的形式返回\n根据索引获取数据\n  ILink加上public E get(int index);\n  在Node中定义public E getNode(int index)\n  在LinkImpl中重写public E get(int index)\n  修改指定索引的数据\n 在ILink加上public void set(int index,E value); 在Node中定义public void setNode(int index,E value) 在LinkImpl中重写public void set(int index, E value)  判断指定数据是否存在\n 在ILink加上public boolean contains(E data) 在Node中定义public boolean containsNode(E data) 在LinkImpl中重写public boolean contains(E data)  数据删除\n 在ILink中加上public void remove(E data) 在LinkImpl中判断要删除的元素是否为根节点 如果不是根节点，在Node中定义删除节点 在LinkImpl中完善public void remove(E data)方法  数据清除\n 在ILink中追加public void clean();方法 在LinkImpl中重写public void clean()  AWT   AWT 界面组件：包括窗口、对话框、基本组件、菜单组件。 AWT 布局管理器：包括流式布局 FlowLayout、区域布局 BorderLayout、网格布局 GridLayout、卡片布局 CardLayout。 AWT 事件处理：事件授权模型、事件类型，监听器和适配器的使用。   AWT 的组件包括两大类：Component 和 MenuComponent，即组件与菜单栏\n类 java.awt.Component 是许多组件类的父类，Component 类中封装了组件通用的方法和属性，如图形的组件对象、大小、显示位置、前景色和背景色、边界、可见性等。\n一般我们要生成一个窗口，通常是用 Window 的子类 Frame 来进行实例化，而不是直接用到 Window 类\nPanel是一个容器，放在 Frame 组件内，可以用于包装一组组件。\n idea 中中文乱码设置VM option: -Dfile.encoding=GB18030\n 对话框Dialog\n创建文本对话框FileDialog\n基本组件\n 文本Label 按钮Button 复选框Checkbox 复选框组CheckboxGroup 下拉列表Choice 文本框TextField 文本区域TextArea 列表List 画布CAnvas  菜单组件\n 菜单栏MenuBar 菜单Menu 菜单选项MenuItem  AWT 布局管理器\n Frame 是一个顶级窗口。Frame 的默认布局管理器为BorderLayout。\nPanel 无法单独显示，必须添加到某个容器中。Panel 的默认布局管理器为 FlowLayout。\n当把 Panel 作为一个组件添加到某个容器中后，该 Panel 仍然可以有自己的布局管理器。因此，可以利用 Panel 使得BorderLayout中某个区域显示多个组件，达到设计复杂用户界面的目的。\n如果采用无布局管理器setLayout(null)，则必须使用setLocation()、setSize()、setBounds()等方法手工设置组件的大小和位置，此方法会导致平台相关，不鼓励使用。\n 流式布局 FlowLayout\nFlowLayout 是 Panel、Applet 的默认布局管理器。其组件的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个组件先添加到容器中第一行的最左边，后续的组件依次添加到上一个组件的右边，如果当前行已放置不下该组件，则放置到下一行的最左边。\nFlowLayout(FlowLayout.RIGHT,20,40);：第一个参数表示组件的对齐方式，指组件在这一行中的位置是居中对齐、居右对齐还是居左对齐，第二个参数是组件之间的横向间隔，第三个参数是组件之间的纵向间隔，单位是像素。\n区域布局 BorderLayout\nBorderLayout 是 Window、Frame 和 Dialog 的默认布局管理器。BorderLayout 布局管理器把容器分成 5 个区域：North、South、East、West 和 Center，每个区域只能放置一个组件。\n 不一定所有的区域都有组件，如果四周的区域（West、East、North、South 区域）没有组件，则由 Center 区域去补充，但是如果 Center 区域没有组件，则保持空白\n 网格布局 GridLayout\nGridLayout 使容器中各个组件呈网格状布局，平均占据容器的空间，创建该布局时需要指定网格的行数和列数，然后依次添加各个组件时，会按照先行后列的顺序依次添加。\n卡片布局 CardLayout\nCardLayout 卡片布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件，当然每层都可以利用 Panel 来实现复杂的用户界面。\nAWT 事件处理\n使用授权处理模型进行事件处理的一般方法归纳如下。\n  对于某种类型的事件 XXXEvent，要想接收并处理这类事件，必须定义相应的事件监听器类，该类需要实现与该事件相对应的接口 XXXListener。\n  事件源实例化以后，必须进行授权，注册该类事件的监听器，使用 addXXXListener(XXXListener )方法来注册监听器。\n  AWT 事件共有 10 类，可以归为两大类：低级事件和高级事件。\n低级事件是指基于组件和容器的事件，当一个组件上发生事件，如：鼠标的进入、单击、拖放等，或组件的窗口开关等，触发了组件事件。\n高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类，如在 TextField 中按 Enter 键会触发 ActionEvent 事件，滑动滚动条会触发 AdjustmentEvent 事件，或是选中项目列表的某一条就会触发 ItemEvent 事件。\n事件监听器\n每类事件都有对应的事件监听器，监听器是接口，根据动作来定义方法\n使用事件监听器：实现监听器接口、使用内部类和匿名类。\n使用事件适配器。\n多媒体处理\n 图像处理——java.awt.image 二维图像绘制——Java2D。 音频录制与播放——JavaSound。 视频拍照与播放——JMF。  正则表达式 基本语法\n 八进制表示的字符，以\\0开头，后跟 1 ～ 3 位数字 十六进制表示的字符，以\\x开头，后跟两位字符 Unicode 编号表示的字符，以\\u开头，后跟 4 位字符 点号字符.是一个元字符，默认模式下，它匹配除了换行符以外的任意字符 以(? s)开头，s 表示 single line，即单行匹配模式 为方便表示连续的多个字符，字符组中可以使用连字符\u0026rsquo;-\u0026rsquo; 字符组支持排除的概念，在[后紧跟一个字符^,只有在字符组的开头才是元字符，如果不在开头，就是普通字符，匹配它自身 \\d: d 表示 digit，匹配一个数字字符 \\w: w 表示 word，匹配一个单词字符 \\s: s 表示 space，匹配一个空白字符 \\D：匹配一个非数字字符 \\W：匹配一个非单词字符 \\S：匹配一个非空白字符  量词指的是指定出现次数的元字符：\n +：表示前面字符的一次或多次出现 \\*：表示前面字符的零次或多次出现 ? ：表示前面字符可能出现，也可能不出现 更为通用的表示出现次数的语法是{m, n}，出现次数从 m 到 n，包括 m 和 n，如果 n 没有限制，可以省略，如果 m 和 n 一样，可以写为{m} 使用懒惰量词，在量词的后面加一个符号? 表达式可以用括号()括起来，表示一个分组  特殊边界匹配\n 默认情况下，^匹配整个字符串的开始 默认情况下，$匹配整个字符串的结束 \\A与^类似，但不管什么模式，它匹配的总是整个字符串的开始边界。 \\Z和\\z与$类似，但不管什么模式，它们匹配的总是整个字符串的结束边界。 \\b匹配的是单词边界  环视边界匹配\n环视的字面意思就是左右看看，需要左右符合一些条件，本质上，它也是匹配边界，对边界有一些要求，这个要求是针对左边或右边的字符串的。\n 肯定顺序环视，语法是(? =...)，要求右边的字符串匹配指定的表达式。 否定顺序环视，语法是(? ! ...)，要求右边的字符串不能匹配指定的表达式。 肯定逆序环视，语法是(? \u0026lt;=...)，要求左边的字符串匹配指定的表达式。 否定逆序环视，语法是(? \u0026lt;! ...)，要求左边的字符串不能匹配指定的表达式。  这些环视结构也被称为断言，断言的对象是边界，边界不占用字符，没有宽度，所以也被称为零宽度断言。\nJava API\n正则表达式相关的类位于包 java.util.regex 下，有两个主要的类，一个是 Pattern，另一个是 Matcher\n  表示正则表达式\n在 Java 中，没有什么特殊的语法能直接表示正则表达式，需要用字符串表示，而在字符串中，''也是一个元字符，为了在字符串中表示正则表达式的\u0026rsquo;'，就需要使用两个\u0026rsquo;'，即\u0026rsquo;\\'，而要匹配\u0026rsquo;'本身，就需要 4 个\u0026rsquo;'，即\u0026rsquo;\\\\\u0026rsquo;\n三种匹配模式：单行模式（点号模式）、多行模式和大小写无关模式，它们对应的常量分别为：Pattern.DOTALL、Pattern.MULTILINE 和 Pattern.CASE_INSENSI-TIVE，多个模式可以一起使用，通过'|'连起来即可\n  切分\n  验证\n  查找\n  替换\n  List 集合 集合操作最常用的两种方法：add()，iterator()\npublic interface List\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt;\nCollection 的继承关系，如图：\nList 的三个常用子类：\n ArrayList LinkedList Vector  ArrayList\n继承关系\n1 2 3  public class ArrayList\u0026lt;E\u0026gt;\rextends AbstractList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, Serializable\r  LinkedList\n继承关系\n1 2 3  public class LinkedList\u0026lt;E\u0026gt;\rextends AbstractSequentialList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, Serializable\r  Vector\nVector 是一个古老的集合（从 JDK 1.0 就有了）\n继承关系\n1 2 3  public class Vector\u0026lt;E\u0026gt;\rextends AbstractList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, Serializable\r  Set 集合 Set 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add 方法返回 false，且新元素不会被加入。\nSet 判断两个对象相同不是使用==运算符，而是根据 equals 方法\nHashSet\nHashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。\nHashSet 不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或者两个以上线程同时修改了 HashSet 集合时，则必须通过代码来保证其同步。\nLinkedHashSet\nHashSet 还有一个子类 LinkedHashSet，LinkedHashSet 集合也是根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。\nTreeSet\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。\nTreeSet 并不是根据元素的插入顺序进行排序的，而是根据元素实际值的大小来进行排序的。\nEnumSet\nEnumSet 是一个专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式地指定。EnumSet 的集合元素也是有序的，EnumSet 以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。\nMap 集合 Map 用于保存具有映射关系的数据，因此 Map 集合里保存着两组值，一组值用于保存 Map 里的 key，另外一组值用于保存 Map 里的 value，key 和 value 都可以是任何引用类型的数据。\nMap 的继承关系，如图：\nHashMap和Hashtable都是 Map 接口的典型实现类，它们之间的关系完全类似于ArrayList和Vector的关系\n Hashtable 是一个线程安全的 Map 实现，但 HashMap 是线程不安全的实现\nHashtable 不允许使用 null 作为 key 和 value\n HashMap、Hashtable也不能保证其中 key-value 对的顺序。\nProperties类是Hashtable类的子类，正如它的名字所暗示的，该对象在处理属性文件时特别方便（Windows 操作平台上的 ini 文件就是一种属性文件）。\nTreeMap就是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap存储 key-value 对（节点）时，需要根据 key 对节点进行排序。\n ArrayList 和 Vector 的显著区别：ArrayList 是线程不安全的，当多个线程访问同一个 ArrayList 集合时，如果有超过一个线程修改了 ArrayList 集合，则程序必须手动保证该集合的同步性；但 Vector 集合则是线程安全的，无须程序保证该集合的同步性。\n Java 多线程编程 Java 是多线程的编程语言，有利于并发访问处理。\n继承Thread 类实现多线程\n多线程的执行的方法在run()中定义，\nstart()方法是并发执行\n每一个线程类对象只允许启动一次，如果重复启动，就会抛出异常\nRunnable接口的使用\n1 2  Thread th=new Thread(new MyThread(\u0026#34;线程1启动\u0026#34;));\rth.start();\r  Thread 与 Runnable 关系 Thread 用于实现 Runnable，如图所示：\n多线程的设计之中，使用了代理设计模式的结构，用户设计的线程主体负责项目核心功能，其他辅助功能由 Thread 类实现\n多线程开发的本质实质上是在于多个线程可以进行统一资源的抢占\nCallable 实现多线程\nCallable的定义\n1 2 3 4  @FunctionalInterface\rpublic interface Callable\u0026lt;V\u0026gt; {\rV call() throws Exception;\r}\r  如图 Callable 的继承关系：\n   Runnable Callable     JDK1.0 JDK1.5   只有 void run()，无返回值 V call()，有返回值    线程常用操作方法 构造方法public Thread(Runnable target, String name)\n设置名字public final synchronized void setName(String name)\n取得名字public final String getName()\n使用 Java 命令就会启动一个 JVM 的进程，一台电脑可以同时启动若干个 JVM 进程\n主线程可以创建若干个子线程，主线程负责处理整体流程，而子线程负责处理耗时操作\n线程休眠\n两种休眠处理方式\n一个参数，毫秒：public static native void sleep(long millis) throws InterruptedException;\n两个参数，毫秒纳秒public static void sleep(long millis, int nanos)throws InterruptedException\n休眠的主要特点是自动实现线程的唤醒，以继续进行后续的处理，多个线程休眠是有顺序的\n线程中断\n所有的线程都能被中断，线程中断必须进行异常处理\n线程的强制执行\n正常情况下主线程和子线程交替执行\n强制执行public final void join() throws InterruptedException\n线程礼让\n礼让方法：public static native void yield();\n线程优先级\n设置优先级public final void setPriority(int newPriority)\n获取优先级public final int getPriority()\n三个优先级常量\n1 2 3  public final static int MIN_PRIORITY = 1;\rpublic final static int NORM_PRIORITY = 5;\rpublic final static int MAX_PRIORITY = 10;\r  优先级高的最有可能先执行，并不是绝对先执行\n线程的同步与死锁 同步问题的引出\n系统休眠或网络延迟会产生数据不同步问题\n线程同步\n解决同步问题的关键是锁\n关键字synchronized\n同步实际上会使系统的性能降低\n解决同步问题的两种方法：同步代码块和同步方法\n线程死锁\n线程死锁就是若干个线程互相等待的状态\n死锁是开发中不确定的状态\n若干个线程访问同一资源时一定要进行同步处理，而过多的同步则会造成死锁\n基础类库 StringBuffer 类\n构造方法：public StringBuffer()\n构造方法：public StringBuffer(String str)\n基本操作方法：\n1 2 3 4 5 6 7  public static void main(String[] args) {\rStringBuffer sb=new StringBuffer(\u0026#34;baidu\u0026#34;);\rsb.append(\u0026#34;.com\u0026#34;).insert(0,\u0026#34;www.\u0026#34;);\rSystem.out.println(sb);\rsb.delete(0,4);\rSystem.out.println(sb);\r}\r  字符串反转：sb.reverse()\nStringBuffer属于线程安全的全部使用synchronized，StringBuilder是非线程安全的。\nCharSequence 接口\nCharSequence 是描述字符串结构的接口\n   String StringBuffer StringBuilder     public final class Stringextends Objectimplements Serializable, Comparable, CharSequence public final class StringBufferextends Objectimplements Serializable, CharSequence public final class StringBuilderextends Objectimplements Serializable, CharSequence    Runtime 类\n在每一个 JVM 只允许提供有一个 Runtime 类的对象，所以这个类的构造方法被默认私有化了\nSystem 类\n  数组拷贝：public static native void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);\n  获取当前日期时间数值：public static native long currentTimeMillis();\n  进行垃圾回收：public static void gc()\n  Math 类\nMath 类的全部方法:\n1 2 3 4 5 6 7 8  /**\r* 指定小数位数四舍五入\r* @param: [num, scale]\r* @return: double\r*/\rpublic static double round(double num,int scale){\rreturn Math.round(num*Math.pow(10,scale))/Math.pow(10,scale);\r}\r  Random 类\n生成不包含边界的随机正整数：public int nextInt(int bound)\nUUID 类\nUUID 是一种生成无重复字符串的一种程序类，这种程序类的主要功能是根据时间戳实现一个自动的无重复字符串定义。\n随机获取 UUID:public static UUID randomUUID()\n根据字符串获取 UUID 内容:public static UUID fromString(String name)\nOption 类\nOption 类的主要功能是进行 null 的相关处理\n返回空数据：public static\u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; empty()\n获取数据：public T get()\n保存数据，但是不许出现 null：public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; of(T value)\n保存数据，允许出现 null：public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value)\n空的时候返回其他数据:public T orElse(T other)\nThreadLocal 类\n构造方法：public ThreadLocal()\n设置数据：public void set(T value)\n取出数据：public T get()\n删除数据：public void remove()\nBase64 类\nBase64 可以实现加密与解密的处理，包含的内部类和方法如下图：\n比较器 Arrays 类\n数组的排序：public static void sort(int[] a)\n数组的输出：public static String toString(int[] a)\nComparable 比较器\n接口定义：public interface Comparable\u0026lt;T\u0026gt;\n实现比较的方法：int compareTo(T o)\nComparator 比较器\nComparator 属于一种挽救的比较器支持，其主要目的是解决一些没有使用 Comparable 排序的类的对象的数组排序操作\n红黑树原理  红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。\n红黑树是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。\n红黑树是一种特化的 AVL 树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。\n它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在 O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目。\n 红黑树的特点：\n 每个节点不是黑色就是红色 根节点必须是黑色 叶子节点是黑色  Java 实现的红黑树使用 null 代表空节点，因此遍历红黑树时将看不到黑丝的叶子节点，反而看到每个叶子节点都是红色的   红色节点的子节点必须是黑色的 一个节点到该节点的所有子孙节点的所有路径上包含相同数目的黑色节点  利用红色节点与黑色节点实现均衡的控制\n文件操作 File 类\n构造方法：public File(String pathname)\n构造方法：public File(String parent, String child)\n创建文件：public boolean createNewFile() throws IOException\n判断文件是否存在：public boolean exists()\n删除文件：public boolean delete()\nWindows 的路径分隔符是\\,Linux 的路径分隔符是/，\nFile 类中的路径分隔符常量separator\n获取父路径：public File getParentFile()\n创建单级目录：public boolean mkdir()\n创建多级目录：public boolean mkdirs()\n是否可读：public boolean canRead()\n是否可写：public boolean canWrite()\n获取文件长度：public long length()\n最后得到修改时间：public long lastModified()\n判断是否为目录：public boolean isFile()\n判断是否为文件：public boolean isDirectory()\n列出目录：public File[] listFiles()\n字节流与字符流 File 类只能够操作文件本身，而不能操作文件的内容\n字节处理流：OutputStream（输出字节流）,InputStream（输入字节流）\n字符处理流：Writer（输出字符流）,Reader（输入字符流）\n流的操作属于资源操作，资源操作必须进行关闭处理\nOutputStream字节输出流\n定义：public abstract class OutputStream implements Closeable, Flushable\nOutputStream的继承关系如图:\nOutputStream是一个公共的输出操作标准\nFileOutputStream是OutputStream的实现子类\n【覆盖】构造方法：public FileOutputStream(File file) throws FileNotFoundException\n【追加】构造方法：public FileOutputStream(File file, boolean append) throws FileNotFoundException\nInputStream字节输入流\nInputStream的继承关系与方法\n使用 read()方法读取的时候只能够以字节数组为主进行接收\nWriter字符输出流\nWriter 的继承关系及方法：\nWriter是字符流，字符处理的优势在于中文数据。\nReader字符输入流\nReader 的构造：\n字节流与字符流的区别\nOutputStream不关闭可以正常保存\nWriter不关闭不能正常保存\n因为Writer使用了缓冲区\n涉及中文信息的都采用字符流\n转换流\n   OutputStreamWriter InputStreamReader     public class OutputStreamWriter extends Writer public class InputStreamReader extends Reader   public OutputStreamWriter(OutputStream out) public InputStreamReader(InputStream in)    转换流可以使字节流转换为字符流\nFileWriter继承结构\nFileReader继承结构\nIO 操作深入 字符编码\n GBK/GB2312：国际编码，可以描述中文信息，GB2312 只描述简体中文 ISO8859-1：国际通用编码，可以用于描述所有字母信息 UNICODE 编码：采用十六进制方式存储，可用于描述所有的文字信息 UTF 编码：象形文字采用十六进制编码，字母采用 ISO8859-1 编码，有利于数据传输，节省带宽 项目中一般都统一使用 UTF-8 编码  列出系统信息System.getProperties().list(System.out);\n内存操作流\nJava 有两类内存操作流：\n  字节内存操作流\n  字符内存操作流\n  管道流\n 字节管道流 字符管道流  输入与输出支持 打印流\n   PrintStream PrintWriter     public class PrintStream extends FilterOutputStream implements Appendable, Closeable public class PrintWriter extends Writer   public PrintStream(OutputStream out) public PrintWriter (Writer out),public PrintWriter(OutputStream out)    对文件进行操作时通常使用打印流\nSystem 类对 IO 的支持\n 标准输出（显示器）：public final static PrintStream out = null; 错误输出：public final static PrintStream err = null; 标准输入（键盘）：public final static InputStream in = null;  1 2  System.out.println(\u0026#34;我是System.out\u0026#34;);\rSystem.err.println(\u0026#34;我是System.err\u0026#34;);\r  System.out输出黑色字体\nSystem.err输出红色字体\nSystem.in并不常用\nBufferedReader缓冲输入流\n读取一行数据public String readLine() throws IOException\nScanner 扫描流\n构造：public Scanner(InputStream source)\n判断是否有数据：public boolean hasNext()\n取出数据：public String next()\n设置分隔符：public Scanner useDelimiter(Pattern pattern)\n对象序列化  序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n Person 类产生的每一个对象都可以实现二进制的数据传输，属于可以被序列化的程序类\n序列化与反序列化\n   序列化 反序列化     ObjectOutputStream ObjectInputStream   public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants   public ObjectOutputStream(OutputStream out) throws IOException public ObjectInputStream(InputStream in) throws IOException   public final void writeObject(Object obj) throws IOException public final Object readObject() throws IOException, ClassNotFoundException    在 Java 中的序列化与反序列化必须使用内部提供的对象操作流，如果要实现一组对象的序列化，则可以使用对象数组完成\ntransient 关键字\n默认情况下当执行了对象序列化的时候会将类中的全部属性的内容进行全部的序列化操作，但是很多情况下有一些属性可能并不需要进行序列化的处理。\nprivate transient String name;\n进行序列化处理的时候，name属性的内容是不会被保存下来的，换言之，读取的数据name将是其对应数据类型的默认值null\n反射机制  所有的技术实现的目标只有一点：重用性\n 根据实例化对象反推出其类型\n 获取 Class 对象信息：public final Class\u0026lt;?\u0026gt; getClass()  class 类定义：public final class Class\u0026lt;T\u0026gt; implements java.io.Serializable,GenericDeclaration,Type,AnnotatedElement   JVM 直接支持采用“类.class”的形式实例化 Class.forName().public static Class\u0026lt;?\u0026gt; forName(String className) throws ClassNotFoundException  反射实例化对象\n通过public T newInstance()实例化对象\n相当于“类名 对象名 = new 类()”，但是该方法只能调用无参构造，JDK9 之后被废弃\n集合工具类 Stack 类\n入栈public E push(E item)\n出栈public synchronized E pop()\nStack 的继承结构如下：\n空栈时出栈会出现Exception in thread \u0026quot;main\u0026quot; java.util.EmptyStackException\nQueue 接口\n追加数据：boolean add(E e);或boolean offer(E e);\n通过队列获取数据：E poll();弹出后删除数据\n优先级队列PriorityQueue\nProperties 属性操作\nProperties 类只能操作 String\n使用 Properties 类型的最大特点是可以进行资源内容的输入与输出的处理操作\nCollections 类\n解释 Collection 与 Collections 的区别\n Collection 是集合接口，允许保存单值对象 Collections 是集合操作的工具类。  Stream 数据流 Stream 基础操作\nStream 主要功能是进行数据的分析处理，主要是针对于集合中的数据进行分析操作\n可以通过函数式编程进行数据的流式处理\n数据采集\n\u0026lt;R, A\u0026gt; R collect(Collector\u0026lt;? super T, A, R\u0026gt; collector);\n分页处理方法\n  设置取出的最大数据量：Stream\u0026lt;T\u0026gt; limit(long maxSize);\n  跳过指定数据量：Stream\u0026lt;T\u0026gt; skip(long n);\n  MapReduce 基础模型\nall.stream()用于初始化 Stream 对象\n.filter((ele)-\u0026gt;ele.getName().contains(\u0026quot;小米\u0026quot;))过滤出商品名称中含有小米的数据。\n.mapToDouble((olderObject)-\u0026gt;olderObject.getPrice()*olderObject.getCount()).summaryStatistics();计算出单种商品的总价，然后返回DoubleSummaryStatistics类型的对象。\nDoubleSummaryStatistics一些常用的方法\n网络编程 针对网络程序的开发有两种模型：\n C/S（Client/Server，客户端与服务器端） B/S（Browser/Server，浏览器与服务器端）  TCP（可靠的数据连接）\nUDP（不可靠的数据连接）\nTCP\nTCP 的程序开发是网络程序最基本的开发模型，其核心的特点是使用两个类实现数据的交互处理：ServerSocket（服务器端），Socket（客户端）\n简要工作流程如图：\nServerSocket 的主要目的是设置服务器监听的端口，Socket 要指明要连接的服务器地址与端口\nUDP\nUDP 程序是基于数据报的网络编程实现，如果想实现 UDP 程序需要两个类：DatagramSocket和DatagramPacket\nJDBC 对于 JDBC 的程序数据库的访问分为如下四种形式：\n  JDBC-ODBC 桥连接\n处理流程：程序 →JDBC→ODBC→ 数据库\n  JDBC 连接：直接通过 JDBC 进行数据库的连接\n处理流程：程序 →JDBC→ 数据库\n  JDBC 网络连接：通过特定的网络协议连接指定的数据库服务\n处理流程：程序 →JDBC→ 网络数据库(IP 地址，端口号)\n  JDBC 协议连接\n  Java 访问 MySQL 过程；\n  设置驱动\n1  `static final String JDBC_DRIVER = \u0026#34;com.mysql.jdbc.Driver\u0026#34;;\r    设置数据库地址\n1  static final String DB_URL = \u0026#34;jdbc:mysql://localhost:3308/test\u0026#34;;\r    设置用户名和密码\n1 2  static final String USER = \u0026#34;root\u0026#34;;\rstatic final String PASS = \u0026#34;123456\u0026#34;;\r    初始化连接对象和游标对象\n1 2  Connection conn = null;\rStatement stmt = null;\r    注册 JDBC 驱动\n1  Class.forName(JDBC_DRIVER);\r    打开连接\n1  conn = DriverManager.getConnection(DB_URL, USER, PASS);\r    执行查询语句\n1 2 3 4 5  System.out.println(\u0026#34; 实例化Statement对象...\u0026#34;);\rstmt = conn.createStatement();\rString sql;\rsql = \u0026#34;SELECT id, name, url FROM websites\u0026#34;;\rResultSet rs = stmt.executeQuery(sql);\r    用ResultSet对象接收返回结果\n1  ResultSet rs = stmt.executeQuery(sql);\r    遍历ResultSet对象\n1 2 3 4 5 6 7 8 9 10 11  while (rs.next()) {\r// 通过字段检索\r int id = rs.getInt(\u0026#34;id\u0026#34;);\rString name = rs.getString(\u0026#34;name\u0026#34;);\rString url = rs.getString(\u0026#34;url\u0026#34;);\r// 输出数据\r System.out.print(\u0026#34;ID: \u0026#34; + id);\rSystem.out.print(\u0026#34;, 站点名称: \u0026#34; + name);\rSystem.out.print(\u0026#34;, 站点 URL: \u0026#34; + url);\rSystem.out.print(\u0026#34;\\n\u0026#34;);\r}\r    关闭资源\n  1 2 3  rs.close();\rstmt.close();\rconn.close();\r  运行结果：\n1 2 3 4 5 6 7 8  Thu Apr 09 18:03:44 CST 2020 WARN: Establishing SSL connection without server\u0026#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn\u0026#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to \u0026#39;false\u0026#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\r实例化Statement对象...\rID: 1, 站点名称: Google, 站点 URL: https://www.google.cm/\rID: 2, 站点名称: 淘宝, 站点 URL: https://www.taobao.com/\rID: 3, 站点名称: 菜鸟教程, 站点 URL: http://www.runoob.com\rID: 4, 站点名称: 微博, 站点 URL: http://weibo.com/\rID: 5, 站点名称: Facebook, 站点 URL: https://www.facebook.com/\rGoodbye!\r   MySQL 8.0 以上版本需设置 JDBC 为static final String JDBC_DRIVER = \u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;;\n ","description":"本文系统的记录学习JavaSE的笔记，按照阿里云上的 Java 学习路线自学的，代码的解释可以访问我的简书个人主页","id":13,"section":"posts","tags":["java"],"title":"JavaSE 学习笔记","uri":"https://eternidad33.github.io/zh/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"码云上搭建 Hexo 静态博客   下载 Node.js\n  下载并配置 Git\n  安装 Hexo\n 设置 cnpm，设置为国内的淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 Hexo， cnpm install -g hexo-cli 查看是否安装成功 hexo -v    建立博客文件夹\n  执行hexo init\n  Hexo 常用的几个命令\n hexo s运行 Hexo hexo n 文件名.md创建博客文章，也可以直接在\\source\\_posts文件夹中创建 hexo g生成博客文件 hexo clean清理缓存 hexo d推送到远端服务器    创建远程仓库，仓库名要与自己的用户名相同\n  安装 Git 依赖，cnpm install --save hexo-deployer-git\n  修改配置文件\n1 2 3 4  deploy:type:gitrepo:https://gitee.com/eternidad33/eternidad33.gitbranch:master    开启Gitee Pages服务\n  推荐 B 站 Up 主：CodeSheep\n参考的是他的视频手把手教你从 0 开始搭建自己的个人博客 |无坑版视频教程| hexo\n","description":"","id":14,"section":"posts","tags":["hexo"],"title":"码云上搭建Hexo博客","uri":"https://eternidad33.github.io/zh/posts/%E7%A0%81%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"content":"学习类 中国大学 MOOC（涵盖各个行业的课程）\n慕课网（计算机互联网行业学习的网站）\n哔哩哔哩（各个领域的 UP 主）\nw3cSchool（学习编程）\n廖雪峰的官方网站（学习编程）\n菜鸟教程（学习编程）\n实验楼（学习编程）\n数据酷客（学习 Python，大数据）\n阿里云大学(提供编程各个方向的学习路线)\nhow2j（学习 Java）\n素材类 微信读书（只要有无限卡，全场免费读）\n鸠摩搜书（基本上想搜的书都能搜到）\nGreasy Fork（配合油猴插件下载脚本）\nMSDN，我告诉你（免费下载纯净的 Windows 系统镜像）\n我的 MSDN（免费下载纯净的 Windows 系统镜像）\n电脑壁纸（免费好看的桌面壁纸）\n阿里巴巴矢量图标库（下载各种格式的图标）\n第一 PPT（免费 PPT 模板）\n优品 PPT（免费 PPT 模板）\n站长素材（下载图标，字体，PSD，矢量图，jQuery 等）\n编程相关 ProcessOn（在线作图）\nGitHub（ 世界上最大的软件项目的托管平台 ）\n码云（相当于国内的 GitHub）\n牛客（刷题）\nLeetCode（刷题）\n洛谷（刷题）\nwakatime（记录编码时间）\nSM.MS（图床工具）\nShields.IO（生成展示在 Markdown 文档中的徽章）\nSimple Icons（下载 SVG 图标）\n","description":"大学期间收集的网站，主要分为学习类，素材类，和编程相关","id":15,"section":"posts","tags":null,"title":"网站推荐","uri":"https://eternidad33.github.io/zh/posts/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"},{"content":"1. Alibaba Cloud Tookit  Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；并且还内置了 Arthas 诊断、Dubbo 工具、Terminal 终端、文件上传、函数计算 和 MySQL 执行器等工具。（产品官网：https://www.aliyun.com/product/cloudtoolkit）\n 通过该插件就可以直接在 VScode 上直接控制自己的远程服务器了，可以很方便地上传本机的文件到服务器上。\n需要配置的就是服务器的 ip,AccessKeyId,AccessKeySecret,用户名和密码\n2. Auto Import  Automatically finds, parses and provides code actions and code completion for all available imports. Works with Typescript and TSX.\n 该插件用于在编写代码时，自动导入文件中忘记写的需要的包，配置里的钩根据自己的需求打就行了\n3. Auto Rename Tag  Automatically rename paired HTML/XML tag, same as Visual Studio IDE does.\n 顾名思义就是 html，xml 的起始标签改变时，结束标签也会跟随改变\n4. Code Runner  Run code snippet or code file for multiple languages: C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, and custom command\n 如果用 VScode 编写 Java 可以用该插件编译，调试，和运行，其他语言可能也行，配置信息根据自身需求设置\n 如果是编写 Java，VScode 会提示安装许多 Java 的插件，例如：Debugger for Java，Java Dependency Viewer，Java Extension Pack，Java Test Runner，Language support for Java ™ for Visual Studio Code，Maven for Java，自动安装上即可\n 5. Color Info 该插件是在编写 CSS 需要设置颜色时用的，可以快速从调色板中选取颜色，设置透明度等。即装即用，无需配置。\n6. GitLens — Git supercharged  GitLens supercharges the Git capabilities built into Visual Studio Code. It helps you to visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more.\n 这个 Git 插件配合 VScode 自带的源代码管理工具，可以很好的管理自己的本地仓库和远程仓库。\n这个需要先把快捷键配置上,将 commit 的快捷键设置为 Alt+/\n7. Indent-Rainbow 不同缩进会显示不同的颜色，编写 Python 必装的插件，因为 Python 对缩进的要求很严格，即装即用，无需配置\n显示效果：\n8. LeetCode 刷 LeetCode 上的题必备的插件，可以查看自己刷过的题，支持查看，测试，提交，看自己的运行结果等\n配置时先把 user-account 设为 leetcode-cn，然后登陆自己的账户即可，然后配置上自己习惯用的语言\n9. wakatime 记录自己的编码时间，在wakatime 官网上直接查看自己每天的编码时间，免费版最多可以保存最近 14 天的。\n如果使用其他的 IDE 也可以安装该插件，然后在官网上查看自己编写各种语言的时间，和使用各个 IDE 的时间，每周会给自己邮箱发一个周报\n只需配置上自己在官网上注册的账号的 api key 即可。\n10. PicGo 图床工具，支持的图床有 qiniu, tcyun, upyun, github, aliyun, imgur 和 SM.MS，默认是 SM.MS。但是 SM.MS 经常上传失败，我也不太清楚怎么解决。介绍一下 GitHub 图床的配置\n PicBed 设为GitHub branch 设为master Custom Url：https://cdn.jsdelivr.net/gh/user/repo@master采用 cdn 访问，因为国内访问 GitHub 相对较慢  gh表示 github user填写自己的用户名 repo填写自己图床的仓库 例如https://cdn.jsdelivr.net/gh/eternidad33/picbed@master   Path:images/图片上传到仓库中的 images 文件夹中 Repo：user/repo填写自己的仓库即可 Token：自己在 GitHub 上创建一个拥有 repo 权限的 Token，填上即可  上传本机图片的快捷键是 Ctrl+Alt+E\n11. Markdown Preview Enhanced with litvis 全面支持 Markdown 的预览，默认的 Markdown 预览显示的不太好看，[Toc]生成的目录是显示不出的，还有一些 HTML 的标签支持的也不是很好，而该插件就可以很好地显示，同时还可以将 Markdown 文件导出为 HTML，PDF 等格式的文件\nWallpaper 每日壁纸分享 标题：Fantasy World\n创作者：Mrs.Venus\n","description":"Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；","id":16,"section":"posts","tags":null,"title":"VSCode插件推荐","uri":"https://eternidad33.github.io/zh/posts/vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"content":"个人主页 代码：码云，Github\n博客：简书，CSDN，博客园\n刷题：牛客，LeetCode\n社交：今日头条，哔哩哔哩，steam，知乎，百度贴吧，微博\n欢迎大家关注我的动态\n","description":"个人动态","id":17,"section":"","tags":null,"title":"关于","uri":"https://eternidad33.github.io/zh/about/"}]