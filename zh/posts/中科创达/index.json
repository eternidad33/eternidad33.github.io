[{"content":"一面 2021-03-10\n今天是我的第一次面试，面试的时候好紧张，当时说话语无伦次，好多问题感觉都非常基础了，但就是脑子里想的毫无逻辑，用语言也表达不清楚。这次表现的不太好，不过也挺有纪念意义的，本文总结了这次面试的问题，希望下次会有一个更好的面试结果。\n一开始先是自我介绍环节\n 额、嗯、然后、等词太多，方言味太重，自我介绍内容太少\n 自我介绍模板：\n向面试官问好。\n我叫xxxx，来自xxxx，是 xxxxx 大学 xxxxx 学院 xxxxx 专业的一名21级应届生，衷心感谢您能给这次我面试的机会。\n在四年的大学生活中，学了\u0026hellip;\u0026hellip;.课程，参加过\u0026hellip;\u0026hellip;.比赛，获得过\u0026hellip;\u0026hellip;.证书，目前熟悉的编程语言是 Java 和 Python，希望通过这次面试能学到一些相关的专业知识。\n业余爱好，跑步（成就）、看书（看过哪些书）、听书（谁的什么书）\n然后就到了面试官提问环节\n  面向对象的三大特征\n 答成了抽象、封装继承、多态\n   继承\n继承就是让一个类型对象获得另一个类型对象的属性的方法，并且支持多级继承\n  封装\n封装就是把客观事物封装起来变成抽象的类，这个类可以把自己的属性和方法提供给可信的类或对象操作使用，并对不可行的类进行信息隐藏\n  多态\n多态就是指一个类实例对象的相同方法在不同情形下被调用所展现的不同形式\n    抽象类和接口区别\n 回答不全，不熟练\n 使用时的共同点\n 抽象类或接口必须定义子类 子类必须覆写抽象类或接口的全部抽象方法 通过子类的向上转型实现抽象类或接口的对象实例化    抽象类能不能用final修饰\n不能，抽象类是被用于继承的，final修饰代表不可修改、不可继承的。\n  重载和重写区别\n “那个那个\u0026hellip;..”说话不流畅\n 重载规则：必须具有不同的参数列表； 可以有不同的返回类型；可以有不同的访问修饰符；可以抛出不同的异常。\n重写规则：参数列表必须完全与被重写的方法相同，否则不能称其为重写；返回类型必须一直与被重写的方法相同，否则不能称其为重写；访问修饰符的限制一定要大于等于被重写方法的访问修饰符；重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常，譬如父类方法声明了一个检查异常 IOException，在重写这个方法时就不能抛出 Exception，只能抛出 IOException 的子类异常，可以抛出非检查异常。\n重载与重写是 Java 多态性的不同表现\n 重写是父类与子类之间多态性的表现，在运行时起作用（动态多态性，譬如实现动态绑定）     而重载是一个类中多态性的表现，在编译时起作用（静态多态性，譬如实现静态绑定）。   StringBuffer、StringBuilder、String的区别\nString 字符串常量\nStringBuffer 字符串变量（线程安全）\nStringBuilder 字符串变量（非线程安全）\nString提供了数值不可变的字符串，StringBuffer 、StringBuilder中的字符串可以进行修改\n  HashMap的底层实现\n 不全\n   底层是哈希表\n  数组+单向链表\n  源码\n1 2 3 4 5 6 7 8 9 10 11  public class HashMap\u0026lt;K,V\u0026gt;{\r//数组\r transient Node\u0026lt;K,V\u0026gt;[] table;\r//链表\r static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; {\rfinal int hash;\rfinal K key;\rV value;\rNode\u0026lt;K,V\u0026gt; next;\r}\r}\r    同一个链表的hash值相等\n  放在HashMap中的元素需要重写equals和hashCode方法\n  map.put(k,v)\n 封装node对象 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，直接将Node添加到这个位置 有元素，在链表每个节点进行euquals()比较，如果全为false，在末尾添加，如果有True，更新Value    map.get(k)\n 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，返回None 下标有链表，对链表元素的Key比较equals，有true返回value，全为false，代表没有元素，返回null    扩容是原来长度的2倍\n  允许key值为null\n    链表上元素个数超过8个会怎么样\n 不全\n 推荐文章HashMap底层实现原理解析\n当hash表的单一链表长度超过 8 个的时候，链表结构就会转为红黑树结构。其访问性能近似于折半查找，时间复杂度 O(logn)，增加查询效率。\n  什么情况下红黑树又会变回链表\n 不会\n TreeNodes(红黑树)占用空间是普通Nodes(链表)的两倍，为了时间和空间的权衡。\n节点的分布频率会遵循泊松分布，链表长度达到8个元素的概率为0.00000006，几乎是不可能事件\n为什么转化为红黑树的阈值8和转化为链表的阈值6不一样？是为了避免频繁来回转化。\n  红黑树原理\n 不会\n  每个节点要么是红色，要么是黑色，但根节点永远是黑色的 每个红色节点的两个子节点一定都是黑色 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色） 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）    线程和进程的区别\n  线程是进程划分成的更小的运行单位，一个进程在其执行过程中可以产生多个线程。多个线程共享进程的堆和方法区，每个线程有独立的程序计数器、栈。\n 线程的实现方式\n参考文章Java实现多线程的四种方式\n 继承Thread类的方式 实现Runnable接口的方式 实现Callable接口 使用线程池    start 和 run方法 的区别\n “那个那个\u0026hellip;\u0026hellip;”太多\n  start()方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码 run()方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码    thread调用start和runable调用run的区别\n 不会\n Thread的start()：\n启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行\nRunnable的run()：\n线程的线程体方法。所有线程类都必须实现的run()方法\n  sleep 和 wait 的区别\n 回答的应该不对\n  wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁 sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；    ArrayList 中存储的student 对象，把它取出来后，对其中的变量进行修改后，集合里原本存储的对象会改变吗，有什么方法防止这种改变吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Student{\rprivate int id;\rpublic Student(int id) {\rthis.id = id;\r}\rpublic int getId() {\rreturn id;\r}\rpublic void setId(int id) {\rthis.id = id;\r}\r}\rpublic class Test {\rpublic static void main(String[] args) {\rArrayList\u0026lt;Student\u0026gt; students=new ArrayList\u0026lt;\u0026gt;();\rstudents.add(new Student(1));\rstudents.add(new Student(2));\rstudents.add(new Student(3));\rStudent student=students.get(0);\rstudent.setId(50);\rfor(Student stu:students){\rSystem.out.println(stu.getId());\r}\r}\r}\r    TCP 和 UDP 的区别\n 不全，面试官有提示\n   TCP连接需要三次握手，为什么必须进行三次握手\n 回答错了，回答成了三次握手的过程\n TCP 为什么需要三次握手？\n  防止重复连接   同步初始化序列化     HTTPS加密，对称和非对称加密\n 没有了解\n 推荐文章：彻底搞懂HTTPS的加密机制\n因为http是通过明文传输的，明文数据中间需要经过中间代理服务器、路由器、WiFi热点、通信服务运营商等多个物理节点，如果信息在中间过程中被劫持，传输的内容就完全暴露了，而且它还可以篡改传输的信息且不被双方察觉，这种方式称为中间人攻击。\n对称加密，有一个密钥，它可以对一段内容加密，加密后只有用它才能解密看到原来的内容\n非对称加密，有一个公钥，有一个私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。\n非对称加密+对称加密\n既然非对称加密耗时，非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，而且非对称加密、解密各只需用一次即可。\n请看一下这个过程：\n 某网站拥有用于非对称加密的公钥A、私钥A’。 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。 服务器拿到后用私钥A’解密得到密钥X。 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。    代码控制主要用的是git\n  问面试官问题\n 方言太重\n   二面 2021-03-10\n感觉凉凉，全程一点自信都没有，好多问题都没有准备，在知乎的这篇回答《面试的时候，如何自我介绍？》中提到的问题几乎都犯了。\n  自我介绍\n 方言太重，没有感情，直接读的自我介绍\n   为什么想来南京工作\n如果老家在远方，自己有意向在这个城市工作，并且在未来一段时间准备安家落户，可以大大方方的告诉面试官，自己将会在这里长久的工作下去。这样的话，对于自己留在这个城市里面还是很有帮助的。\n  对自己的未来的职业规划是怎么样的\n对方不希望招到一个来混日子的人，而是有职业抱负的人，有抱负的人才有干劲；要表明你的工作态度就可以了。当然也可以说自己希望能够通过职业5年有啥梦想，毕竟没有工作经验，说一下梦想例如给爸妈买房子什么的还是满好的。\n  你知道我们公司是做什么的吗\n 不知道，感觉自己的进不去，直接表达出自己的不自信。\n面试官说：从面试官的角度来看，听人说自己进不去，还真不知道接下来会问什么\n 面试前应该提前了解公司的具体信息，具体是做什么的。\n中科创达软件股份有限公司是全球领先的智能平台技术提供商。自2008年成立以来,公司致力于提供卓越的智能终端操作系统平台技术及解决方案，助力并加速智能手机、智能物联网、智能汽车等领域的产品化与技术创新。作为一家技术驱动型企业，中科创达不但坚持自我创新，也注重扶持创新。一方面与高通、英特尔、微软等分别运营了多个联合实验室，为元器件适配和终端测试提供先进的资源和技术支持；同时与ARM、高通分别成立合资公司——安创空间加速器、重庆创通联达，为智能硬件企业及创新创业者提供产业平台,推动智能硬件技术发展;并与临空投、天使基金、北极光共同成立产业投资基金，整合资源助力创新。目前,中科创达拥有一支对操作系统技术有深入理解的国际化专业团队。公司总部位于北京,分子公司及研发中心分布于全球19个地区。包括深圳、上海、南京、成都、重庆、武汉、西安、沈阳、大连、台北、香港、美国硅谷、圣地亚哥、日本东京、韩国首尔、芬兰赫尔辛基、印度海得拉巴、马来西亚槟城、保加利亚索菲亚。可以为全球客户提供便捷、高效的技术服务和本地支持。公司链接及简介：http://www.thundersoft.com/\n  你对未来的职业规划会做哪种语言呢\n面试哪种语言，就说哪种语言\n  你了解过安卓语言吗\n知道多少就说多少\n  不知道你是否对基于Java对安卓开发感兴趣\n感兴趣\n  在校期间参加过的社团\n应该说与专业相关的社团\n  学习过程中遇到过什么困难\n先看自己能不能解决，然后请教他人\n  基本上在校期间都是自己去做的是吧\n 表现出自闭，不自信\n   比如你进入到我们公司了，领导交给了你10个bug，你只能完成5个，你会怎么解决这个问题\n 无能为力，直接放弃，不自信\n   提问面试官问题\n  ","description":"","id":0,"section":"posts","tags":["java"],"title":"【中科创达】Java方向","uri":"https://eternidad33.github.io/zh/posts/%E4%B8%AD%E7%A7%91%E5%88%9B%E8%BE%BE/"},{"content":"本篇文章接上篇文章《看懂女人心理》笔记上，经过这几天的学习，对于搞对象我总结了以下三点，读书提升内在，健身提升外在，带脑子地和女生聊天。\n 音频名称：看懂女人心理（恋爱脱单技巧）\n主播：明日恋爱\n音频链接：https://www.ximalaya.com/qinggan/36414100/\n 她想要分手的6个征兆  看不到未来 不够重视，双方重视的程度不一样 三观不同 负能量满满，老是抱怨生活 缺少沟通 无视矛盾  男生要谨记这3点，才能跟女生长久发展  分寸感拿捏不对 付出和回报不对等 懂得打扮和保养自己，每天保持爱自己  女生眼里实打实的4大备胎型男人  第一次聊天，查户口，夺命连环问 强迫对方 不分情况，无条件服从 黏人从早聊到晚  聊天的8个雷区，千万别踩  你吃了吗 你怎么不回我 去哪玩的这么晚（闲聊就闲聊，少瞎扯淡） 刚认识就立刻邀约 聊性话题，讲黄段子 在干嘛（以笑话、段子作为开场白） 查户口式聊天 没聊几天就表白   聊错不如不聊，做错不如不做\n你前期犯的错误越多，后期弥补的成本就会越高\n 如何知道女生对自己是否有兴趣 聊天时发出的无兴趣信号\n 常常一整天不回你 每次都是你开启和结束话题 女生不提供话题 只在需要你帮助的时候找你（女生不会在工具人中选对象） 很少在你面前掩饰 邀约的时候说很忙  约会的无兴趣信号\n 肢体不愿意靠近你 注意力不在你身上 见你的时候不注意形象  原因\n 个人吸引力不足 情感经验段位差很远 自身价值比对方高很多 对方原本就有喜欢的人 突发事件  女人内心深处想从男人身上得到什么 安全感\n 身材高大，身份，社会地位，经济条件，资源丰富\n 上进心，事业心\n责任心\n在女生无助的时候，你会在她身边，温柔又具有霸气\n润物细无声，不要让她知道你在追她\n高情商的男人，不会犯这5个错误   认真不代表傻，一步一步攻进女生的内心，不可着急想得到她\n感情是需要时间沉淀的\n  感动自己，她喜欢苹果，你送她一车香蕉\n  过度自信\n  不解释产生的误会\n  过早地玩起了暧昧\n  不想做备胎的男人，一定要看这3点  改变付出型人格（感动的只有自己，对方会纹丝不动） 成为驾驭她的男人，在她眼里你是全能高手 保持足够的自信，让女生有危机感  多久联系一次女生，会让她更在乎你  偶尔找她聊聊天，从朋友圈聊起（初识阶段） 从有事到聊你们之间的事，网红打卡地（朋友阶段） 女生只是不想太主动（暧昧阶段） 联系少了女生会缺乏安全感，及时回复，女朋友心情不好，主动安慰，她和闺蜜出去不要缠着她（情侣阶段）  欲擒故纵，最容易让你撩到妹子  引导女生跟你互动\n不要过早暴露需求，隐藏欲望，循序渐进\n平时多跟女生接触，多跟女生聊天\n高逼格的男生会让女生感觉到我可以喜欢你，也可以不喜欢你\n归根结底，就是你要有吸引力\n 怎么去提高邀约女生的成功率 保持线上聊天状态，频率\n心态，有一个良好的心态\n时间点，3点到5点约晚上，晚上约第二天，不能提前太久\n模糊邀约，有时间可以一起吃个饭，有时间可以一起看个电影\n其实99%的女生，只需要你这一样东西 相爱的四个阶段\n 相遇 吸引 交往 维持  让对方喜欢上你，就是要吸引。\n 神秘感，好奇心，自信，安全感，良好的情绪体验，良好的人品，可得性，高情商，会聊天，高标准\u0026hellip;\u0026hellip;\n 专注于发展吸引力，自我，自恋\n不懂就要学，不会就要问\n如何维护你们的长期关系   保持自己的个性\n  要有自己的品味\n 独特的爱好，并且长期保持下去\n   多读书（健身提升外在，读书提升内在）\n  保持适度的空间和距离\n  女生问这个问题时，99%是想让你表白 你为什么喜欢我，你喜欢我哪一点\n回答要具有价值判断的论据\n 我曾经问过我自己为什么喜欢你，我没有答案，我只知道在我快乐的时候想要和你一起分享快乐，我在伤心的时候想要得到你的拥抱和安慰，在夜深人静的时候，我想你想得无法入眠，我却为了不打扰你的睡眠，到天亮才给你发一个简单而温馨的早安。\n 比“我喜欢你”好100倍的表白方式 升高关系的声明：扰乱对方的心思，让对方感觉到你的心意，却不会感到有压力，告白的话中没有涉及对对方的要求，比如，我喜欢你给我带来的这种感觉。\n和女生聊天   对对方的需求感不能暴露太强\n  无需聊天秒回\n  不应有求必应\n 这样会造成给他的感觉你的生活非她不可，而她还有其他选择\n   一周2~3次聊天\n  适当地否定她\n  提升个人魅力和价值\n  男生注意！这个时期的女生最难追 15-18岁，高中不搞对象\n18-22岁，大学\n 单纯梦想型（长相，身高） 社会磨炼过的（完美） 校花（自信，善于倾听） 既漂亮，又有能力  22岁-26岁，大学毕业\n 女生的黄金时期（外在条件，现实）  26岁-30岁，工作经验\n 有时间压力（经济能力） 男人30岁之前比身高比长相，30岁之后比学历，比财力  男生努力的两个方向\n 自我层面，累积自信 不断跟自己欣赏的异性不断营销自己，千万不要想等你拥有一切之后再去追求女生   只有在这两方面同时努力，才能够让你在不同的时期吸引到不同的女生，从而获得真正的快乐\n 为什么你每次邀约都被拒绝 是不是邀约太着急了\n判断女生是否对你邀约的事情感兴趣\n你只是有她联系方式的陌生人\n怎么防止约会被女生放鸽子   约会时间的选择，白天约晚上，晚上约第二天\n  索要电话，记下后马上打过去\n  确认号码是否正确 闲聊，你明天约会的时候不要打扮得太漂亮，我怕所有人的目光都在我们的身上 约会的前两个小时确定她会不会出门     （渣男法）增加一个约会的备选对象，当天同时约两个\n  给男生的9个忠告 不要做好好先生\n 风趣又轻松的人胜过假装强悍又深沉的人，可以多看脱口秀节目 对女人要有挑战性。你并不是一个容易得到的男人，你是一个高价值的男人 两个人不能太熟悉 打开视野，多参加社交活动，培养一门兴趣爱好 拓展你的社交圈，多交一些优质的朋友 要有开放的态度，不要背后说人坏话 不要凡事都表现郑重其事，要显得成熟稳重 不要抱怨 如果她疏远了你，你不能去再提这件事  和刚认识的女生聊天，到底怎么开场   用陈述句代替疑问句，我觉得你应该是南方人\n  学会用冷读的方式延续话题，星座性格分析，共性\n  不要问只有是或否两个答案的问题\n  不要说越级的话\n 女生感冒的时候\n男生：你对着手机吹一下\n女生：为什么\n男生：这样你就能把感冒传染给我了\n   你有真命天女症吗？良药自取 自我欲望实现的精神禁锢，具有以下症状：\n 你认为你追的女生是你理想的样子 经常幻想她的样子 觉得你能追到手 控制不住自己去找她，和她聊天 只对她感兴趣，忽视其他女性  如何治愈？\n 客观评价你身边的每一个女人 扩大自己的异性资源 理性地认知感情 不要为一段失败的感情倾尽努力 回归到你自己的生活中去  用对这3招，让你跟女生有聊不完的话题  关注朋友圈动态，找切入点 聊你们的学生时代的事，产生共性 旅行见闻 休息时间的娱乐 自己每天的趣事和见闻  ","description":"","id":1,"section":"posts","tags":null,"title":"《看懂女人心理》笔记下","uri":"https://eternidad33.github.io/zh/posts/%E7%9C%8B%E6%87%82%E5%A5%B3%E4%BA%BA%E5%BF%83%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%8B/"},{"content":"前两天在家学习实在无聊，每天就是看论文、写论文，真的是无聊的要死，所以在喜马拉雅上面找了一个谈恋爱的课程，主播的声音很有磁性，推荐读者可以听一下，虽然现在的我还是一条平平无奇的单身狗，但听得津津有味，感觉应该对找对象会有很大的帮助吧，好后悔大一的时候没有想到找对象，大四要毕业了，终于感受到了前所未有的孤独感。\n本文整理了音频中的笔记，希望能够帮助到读者，祝愿看到这篇文章的读者都能找到心仪的对象。\n 音频名称：看懂女人心理（恋爱脱单技巧）\n主播：明日恋爱\n音频链接：https://www.ximalaya.com/qinggan/36414100/\n 找对象阶段 要找的对象类型 不是所有的感情都可以培养的\n 高压力会让人退却 差点感觉 尊重自己的内心，是不是迫于道德，迫于压力，迫于责任  自身应要具备的条件 给追求女生的男孩子一些忠告\n 好看？心动？想照顾她？ 单身寂寞？内心是不是喜欢她 找到心仪的女生不难，（先把自己假设成女生，会不会喜欢自己这样的人） 别因为自己太懒惰，而掩盖住更好的自己，学会穿搭 清爽简单的发型，拥有一张干净的脸，走路挺直腰板 形象稍微改造 不要自卑！不要自卑！不要自卑！ 什么样的人就能吸引什么样的人 偶尔撒娇， 判断女生是个什么样的人  浪漫型：悄悄给她惊喜\n实在型：直接转账，让她自己买东西，免得你挑错还要浪费钱\n  不是所有的女生都希望你送花 讨女孩子欢心 不要忘了现实的残酷 脱贫比脱单更重要 付出多不一定越幸福 让她能独立，不要天天送早餐 多动脑子分析现象背后的原因 不可过度宠爱 不要相信毒鸡汤 做正确的事情，正确的恋爱  普通男生如何秒胜“渣男”\n不能去做渣男，要做一个骚而不渣， 好而不傻，让女生欲罢不能的男人\n  有节奏的提供价值\n 不要平时爱理不理，突然送大礼\n如果你不找她聊天，她永远不会主动找你，她肯定对你没兴趣\n   大胆表达自己的情绪感受\n 错误的说法：你对我真好，你太聪明了\n正确示范：每次和你在一起，我都能感觉没有包袱，特别开心，被自己喜欢的女生崇拜的感觉真好\n   投资并且让对方也投资\n 男人投资，女人不投资，叫备胎\n男人不投资，女人投资，叫渣男\n男人投资，女人也投资，叫感情\n   书中学不到的两种社交能力\n  影响你在他人眼中期望值的能力\n 快乐 = 现实 - 期望值\n期望值不能过高，会产生落差感\n   主观情绪自控的能力\n 控制情绪，转移注意力，时刻保持理性\n运动\n   如何增加女生对你的好感\n  不吝啬的夸奖，支持\n  主动表达你的喜欢和爱\n  从我到我们，不要定义为她，尊重双方的意见\n  有各自的空间\n  爱屋及乌，帮助他的家人和朋友\n  真心希望对方开心\n 让你开心起来，对方才能开心，如果你是一张苦瓜脸，对方也开心不起来\n   先做好自己\n  她无法拒绝的，其实是男人这四个特质\n 恶魔的诱惑，直觉上喜欢坏\n刺激感\n  会打扮自己 有情趣，会说甜言蜜语（宝贝~~） 心态洒脱（不跪舔，不死缠烂打，多提升自己） 情商高（会聆听，不直接劝）  判断女生的感觉 一个女生喜欢男生会做哪些行为\n喜欢你的女生\n 不会对你忽冷忽热 聊天不会只回嗯啊 会经常分享他的趣事 不经意间会问你的状态 委婉的问你的前任（想了解你的感情生活） 会边忙边和你聊天 不拒绝你的邀约 乐意为你提供价值，而不是一味索取  （如果这样你都不知道她喜欢你，那你单身这么多年是有原因的）\n如何判断对方是不是喜欢你\n 意见相似吗 想了解你更多吗 会不会回复你聊天内容 在你面前吃的多吗，喜欢你在你面前吃的比较少 言行不一的时候，以行为为主（你很好，但现在不想谈恋爱，就是不喜欢）  女生有这7种表现说明真的不喜欢你\n  聊天毫无感情（好，哦，嗯）\n 没有人是真正高冷的，只是她暖的人不是你而已\n   聊得非常吃力\n  朋友关系变淡\n  朋友从来不会给你们起哄\n  拒绝只有你和她的单独约会\n  在你面前说她喜欢的男生类型，和你没有相似的方面\n  说晚安后，她又发了朋友圈\n  表白 喜欢上一个人，到底要不要告诉ta\n 双方相互喜欢，男生要主动，不到万不得已别让女生先开口 一方当真，一方装傻。知道对方不喜欢，就不表白 不确定对方是否喜欢，影响到了自己的学习工作生活，那就直接去表白  先学会爱自己，再去爱别人\n一个女生不会拒绝的表白方式\n普通的表白方式：暗恋，关注，感情加深，直接表白。。。。。（容易被拒绝）\n表白是有最佳时机的，女人准备好了就去表白，表白是在吸引之后做的事情\n 正确的表白方式：\n通过我喜欢表现为相应的行为，让她产生感觉，这个行为就是吸引，当吸引对方之后再去表白\n表白的最高境界：让女人主动表白\n 恋爱阶段 恋爱初期不能太热情 付出越多，越害怕失去\n 控制热情，把热恋期延长 注意聊天频率和情绪  什么时候才可以见双方父母呢 刚开始谈恋爱，不宜过早见家长\n最好女方先提出见家长，最好先见男方父母\n日常情况 女朋友生气了应该怎么哄\n她跟你说需要静一静，她根本不需要静一静，需要和你聊天，要抱抱\n她走的时候要追上去\n安静了之后找她道歉，“和你吵架，看着你生气的样子我也好心疼，我们以后不要吵了，好不好”\n不在身边，微信道歉，不回你，也要自言自语，让她知道你很关心她\n总是不接电话，就用微信，实在不理你就动身去找她\n女生口中说的“没事”都是什么意思\n男女思维差异\n 倾听 支持，开放宽容的心态  3个赞美方法，女生会很喜欢\n  赞美要具体，细节\n  赞美她期待的方面（找出她特别的点，不要）\n  幽默的方式\n 夸你哥们：你长得这么好看身材又这么好，和你站在一块，女生都被你吸引走了，看来跟你在一起是很难找到女朋友了\n夸一个美女特别有才华：按照国际惯例，长得好看的一般都是花瓶，你这么好看还这么聪明，你这让其他女孩怎么混那\n   冷战？打破恋爱僵局\n 男士先放下姿态 冷静下来 避免大吼大叫 主动拥抱对方 寻找共同目标 相互欣赏，欣赏你的伴侣  如果女生约会带“闺蜜”，请注意这些坑\n男生有僚机，女生有闺蜜\n 本人和照片不符，闺蜜说身体不舒服，两个人就离开了 帮忙打配合 问你“我和她谁更美”，闺蜜找你加微信，这是在试探，直接拒绝  撩女生时，她到底在想些什么\n 不要企图说服女生（男女思维方式不同，看女生做了什么而不是说了什么） 刺激女生的情绪波动，更多的情感刺激，而不是干巴巴的对话 绝对不要冷淡，不要做拉低自己形象的行为 直觉胜过分析  如何辨别TA是不是在说谎\n微表情，肢体语言\n 开放式提问，不要给对方是非题 使用倒叙 我为什么要去相信你 细节 不要急于拆穿破绽，再去寻找更多的漏洞  情况分析 异地恋保持长久稳定的10个秘密\n 定一些原则和规则，让她知道这只是暂时性的 每天保持联络，最好视频通话 共同规划美好未来 双方都要有自己的生活 两个人同时过节日 不要冷战 矛盾不过夜 规划定期见面（一个月至少见一次以上） 分享激情，不要负面情绪，（先发泄情绪，情绪好了在和女生联系） 偶尔制造一些小惊喜  懂这4个真理，才明白如何去爱\n  拿得起，放得下（接受爱情的开始与结束）\n  爱一个人，先爱自己，\n 爱总是有条件的，可以什么也不要，只要她爱你\n   义无反顾的爱情，不要想天长地久、执子之手，要享受过程\n  放手也是爱，当相爱是痛苦的时候，可以选择放弃\n  在女朋友眼中这4个行为最减分\n 对女生太好，患得患失，无微不至，不会拒绝 情绪化的言语 不了解女生的需求点 不重视对她的承诺  缺爱的人会有什么表现\n 慢热，掌握不好和别人相处的平衡度 一旦投入感情，就无法控制自己 过渡黏人 感情和了解程度不成正比 患得患失，自我感动而已  如何处理？\n 降低期望值 学会对抗恐惧，要有自己的生活，营造更好的自己 不要压抑自己，不敢去表达  异性之间的误解是怎么产生的\n沟通障碍\n争吵越来越严重\n透明度错觉，对方不明白你讲的什么意思，你以为你讲明白了\n无意识的处理信息，最容易出现误解\n深思熟虑的处理事情\n感情，不是你付出就会有回报的\n没有直接关系\n真爱是想付出而付出，而不是以回报为目的，抱着想得到回报而付出，费力不讨好\n维系感情就是维系自我，不能迷失自我\n如何度过恋爱中的磨合期（瓶颈期） 因为小事争吵，总是吵架，磨合期最考验爱情\n女朋友如果不是依赖性特别强的，不要成天黏着她\n珍惜每一次矛盾，达成共识，可以促进感情\n一起去旅行\n 在无数枯燥的生活细节里，我们终于无法分离\n 和女朋友应该怎么安排约会 成熟、稳重、阅历丰富\n宅男，性格孤僻的人缺乏社交经验，不会来事儿，一定要懂得提前踩点\n第一次约会非常重要，安全舒适，正常聊天，满足她的虚荣心\n大型商场，星巴克，提前预定位置，以互动为主\n 约会地点的选择：\n 可以肢体接触的地方 能量较高的地方 可以搞暧昧的地方  比如：游乐场，电玩城，制定两个方案让他选择\n 跟情商低的人谈恋爱是一种什么体验  情商不是一朝一夕可以提升的\n经历越多，情商提升的越多，管理好自己的情绪，能察言观色\n情商高的人能够观察和体会到对方的需求，并在不影响自己利益的情况下，满足对方所要的需求\n  不会说话 不会控制情绪 情商低，本来关系好但被你搞砸了  在爱情中，情商主要包括以下几方面的内容：\n 正确的识别和表达自己的情绪 快速识别她的情绪 通过行为，沟通调节另外一半的情绪  这样送礼物,女人会很喜欢 幸福感，认同感，虚荣心，寻求刺激。。。\n感动不是爱，宁可孤独，也不将就\n先吸引再送礼物，女生对你有兴趣后才可送礼物\n提高自己的社交直觉\n 实惠、用心的礼物（不能太贵，可能不会收下） 需要的东西（避免被闲置） 实用的（手链、项链等）  一个已婚男人分享找老婆的经验  相信爱情，有保质期的不是爱情，是激情\n 激情的表现：\n 老想见到她，和她玩 每天电话、短信多的没完 为了生日，费尽心思想浪漫的点子  爱情的表现：\n 在一起的时候考虑规划实实在在的未来 争吵的时候，也不忍心说一句伤她的话 有分歧的时候，总是能理解她是怎么想的  热恋有的是甜蜜浪漫，婚姻则是更多的责任平淡\n 高质量幸福的婚姻，婚姻是没有回头路的，别以为大不了还可以离婚\n不要因为发生了关系就结婚，结婚对男人是一种责任，结婚的对象一定要是自己爱的\n  双方沟通的方式是否都能接受 两个人结婚压力是否可控，肯陪自己奋斗的女人 双否是否是自己的助力，家是港湾 离过婚的人更不相信爱情  分手后 为什么她选择和你分手\n破坏吸引的行为，控制\n过于放低自己的位置\n什么是都寻求肯定，缺乏自信\n黏人，钻石值钱是因为稀少\n减少破坏吸引力的行为，增加吸引力\n导致分手的10个原因，千万不能有\n 长期累积出来的结果，想要挽回对方，先意识到自身的问题\n恋爱是单纯的\n  没有共同话题，用感性思维 没有上进心 不懂为人处世，要会来事，能巧妙化解尴尬 不守承诺，不要随便承诺 不够成熟，做事容易冲动，把握分寸，勇于承担责任 经常花天酒地，狐朋狗友 悲观 占有欲太强，大男子主义 不尊重不理解 不懂得哄女人  前任想要复合的7种迹象，如果还爱，别错过\n 分开之后与你联系，不想失去你这个朋友 回忆往事 关心你的近况（单身？） 承认之前的错误，道歉 从未公开你们分手的事 不想停止和你说话 她向你询问建议  该怎么去挽回一段结束了的感情\n假分手和真分手\n 假分手：可相互联系，接受邀约\n真分手：不再联系\n 如果是真分手，那就提升自己\n","description":"","id":2,"section":"posts","tags":null,"title":"《看懂女人心理》笔记上","uri":"https://eternidad33.github.io/zh/posts/%E7%9C%8B%E6%87%82%E5%A5%B3%E4%BA%BA%E5%BF%83%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%8A/"},{"content":" 本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。\n 数据结构 对n个记录的文件进行快速排序，所需要的辅助存储空间大致为\n正确答案: C 你的答案: C\rA、O（1）\rB、O（n）\rC、O（1og2n）\rD、O（n2）\r辅助存储空间 = 时间复杂度 额外存储空间 = 空间复杂度\n快速排序对待排序序列得划分大约是log2n次，因为快速排序是通过递归算法来实现的，递归深度大约是log2n，所以所需得辅助空间为log2n\n基于比较的排序算法是（ ）\n正确答案: B D 你的答案: B D\rA、基数排序\rB、冒泡排序\rC、桶排序\rD、希尔排序\r1、基于比较的排序算法有：（1）直接插入排序；（2）冒泡排序；（3）简单选择排序；（4）希尔排序；（5）快速排序；（6）堆排序；（7）归并排序。\n2、基数排序、桶排序都属于分配式排序，且都是稳定排序算法。\n待排序元素规模较小时，宜选取哪种排序算法效率最高（ ）\n正确答案: C 你的答案: C\rA、堆排序\rB、归并排序\rC、冒泡排序\rD、希尔排序\r笔记：递归时间可能长于比较时间\n下面有关P问题，NP问题和NPC问题，说法错误的是\n正确答案: D 你的答案: D\rA、如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题\rB、NP问题是指可以在多项式的时间里验证一个解的问题\rC、所有的P类问题都是NP问题\rD、NPC问题不一定是个NP问题，只要保证所有的NP问题都可以约化到它即可\rP: 能在多项式时间内解决的问题\nNP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题\nNPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。\nNP hard:NP难问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。\nint main(){fork()||fork();}共创建几个进程：\n正确答案: C 你的答案: C\rA、1\rB、2\rC、3\rD、4\rE、5\rF、6\rfork()给子进程返回一个零值，而给父进程返回一个非零值；\n在main这个主进程中，首先执行 fork()|| fork(), 左边的fork()返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程，由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中，fork()||fork()这条语句左边表达式的返回值是0, 所以||右边的表达式要执行，这时在子进程中又创建了一个进程，即main进程-\u0026gt;子进程-\u0026gt;子进程，一共创建了3个进程。\n操作系统 以下哪个命令用于查看tar（backup.tar）文件的内容而不提取它?（）\n正确答案: B 你的答案: B\rA、tar -xvf backup.tar\rB、tar -tvf backup.tar\rC、tar -svf backup.tar\rD、none of these\rlinux中tar命令用法\n *.tar 用 tar –xvf 解压 *.gz 用 gzip -d或者gunzip 解压 *.tar.gz和*.tgz 用 tar –xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar –xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar –xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压  下列说法中，错误的是（）\n正确答案: D 你的答案: D\rA、指令就是命令，它用来规定CPU执行什么操作\rB、指令是构成程序的基本单位，程序是由一连串指令组成的\rC、指令采用二进位表示\rD、指令一般由4个部分组成\r 指令一般由两部分组成：\n操作码：该指令完成操作的类型或性质 地址码：操作对象的地址\n 有作业控制块JCB连成一串而形成的排队队列称为（）。\n正确答案: D 你的答案: D\rA、挂起队列\rB、阻塞队列\rC、就绪队列\rD、后备队列\r高级调度：从后备作业队列（作业控制块）中将作业调入进就绪进程队列，所以作业控制块中存放的是后背作业队列。\n中级调度：是为了提高内存的使用率，将一些暂时不能运行的进程从内存移动到外存上去，即内存外出不断交换，所以中级调度会涉及到虚拟存储器。暂时不能运行的进程，由就绪挂起队列，阻塞挂起队列。而阻塞队列里的进程会由于等待时间过长自动调入到阻塞挂起队列里面去。\n低级调度（短程调度）分两类，非抢占式调度和抢占式调度，从就绪进程队列中选取合适进程送到CPU上运行。\n死锁的预防方法中，不太可能的一种方法是（ ）。\n正确答案: A 你的答案: A\rA、摒弃互斥条件\rB、摒弃请求和保持条件\rC、摒弃不剥夺条件\rD、摒弃环路等待条件\r  互斥条件：一个资源每次只能被一个进程使用。不可破坏\n  请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。一次性分配：要么全给，要么啥也不给。\n  不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 设置优先级，高优先级可要求低优先级让出资源。\n  循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。对资源进行编号，按照编号顺序申请访问\n  下列性质中，哪一个不是分时系统的特征（）。\n正确答案: C 你的答案: C\rA、交互性\rB、多路性\rC、成批性\rD、独占性\r分时系统具有多路性、交互性、独占性和及时性的特征。\n多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。\n交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。\n独占性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。\n及时性指，系统对用户提出的请求及时响应。\n实时操作系统基本特征：及时性，可靠性\n关于总线的说法中正确的是( )\n正确答案: A 你的答案: A\rA、总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路\rB、I/O总线是用于连接CPU和内存的总线\rC、CPU总线是连接内存和I/O设备（包括外存）的总线\rD、计算机总线中只包含CPU总线\r总线按功能和规范可分为五大类型:\n 数据总线(Data Bus):在CPU与RAM之间来回传送需要处理或是需要储存的数据。 地址总线(Address Bus):用来指定在RAM(Random Access Memory)之中储存的数据的地址。 控制总线(Control Bus):将微处理器控制单元(Control Unit)的信号，传送到周边设备，一般常见的为USB Bus和1394 Bus。 扩展总线(Expansion Bus):可连接扩展槽和电脑。 局部总线(Local Bus):取代更高速数据传输的扩展总线。  数据库 在mysql中，以下哪种方式可以开启一个事务？\n正确答案: A C 你的答案: A C\rA、START TRANSACTION\rB、START\rC、BEGIN\rD、BEIGN TRANSACTION\r BEGIN或START TRANSACTION；显示地开启一个事务 COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的 ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改 SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常 ROLLBACK TO identifier；把事务回滚到标记点 SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。  下列四项中，不属于数据库系统的主要特点的是（ ）。\n正确答案: D 你的答案: D\rA、数据结构化\rB、数据的冗余度小\rC、较高的数据独立性\rD、程序的标准化\r 数据库系统的特点 数据结构化 数据共享性高,冗余度低,易扩充 数据独立性高\n 下面有关sql 语句中 delete truncate的说法正确的是？（）\n正确答案: A C 你的答案: A C\rA、论清理表数据的速度，truncate一般比delete更快\rB、truncate命令可以用来删除部分数据。\rC、truncate只删除表的数据不删除表的结构\rD、delete能够回收高水位\r 处理效率：drop\u0026gt;trustcate\u0026gt;delete drop删除整个表；trustcate删除全部记录，但不删除表；delete删除部分记录 delete不影响所用extent，高水线保持原位置不动；trustcate会将高水线复位。  计算机网络 下面对http状态码描述正确的是？（）\n正确答案: A D 你的答案: A D\rA、1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\rB、3**：表示服务端无法响应\rC、4**：表示服务端错误\rD、5**：表示服务器端错误\r1XX（信息状态码）接受请求正在处理\n2XX（成功状态码） 请求正常处理完毕\n3XX（重定向状态码） 需要附加操作已完成请求\n4XX（客户端错误状态码） 服务器无法处理请求\n5XX（服务器错误状态码） 服务器处理请求出错\nRPC、SQL、NFS属于OSI的哪一层？\n正确答案: C 你的答案: C\rA、应用层\rB、表示层\rC、会话层\rD、传输层\r 第一层：物理层\n第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY 第三层：网络层 IP、IPX、APPLETALK、ICMP 第四层：传输层 TCP、UDP、SPX 第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP\n第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG 第七层：应用层 HTTP、FTP、SNMP等\n Java 下列代码输出结果为（）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Animal{\rpublic void move(){\rSystem.out.println(\u0026#34;动物可以移动\u0026#34;);\r}\r}\rclass Dog extends Animal{\rpublic void move(){\rSystem.out.println(\u0026#34;狗可以跑和走\u0026#34;);\r}\rpublic void bark(){\rSystem.out.println(\u0026#34;狗可以吠叫\u0026#34;);\r}\r}\rpublic class TestDog{\rpublic static void main(String args[]){\rAnimal a = new Animal();\rAnimal b = new Dog(); a.move();\rb.move();\rb.bark();\r}\r}\r正确答案: D 你的答案: D\rA、 动物可以移动\r狗可以跑和走\r狗可以吠叫\rB、 动物可以移动\r动物可以移动\r狗可以吠叫\rC、 运行错误\rD、 编译错误\r  编译看左边，运行看右边。 父类型引用指向子类型对象，无法调用只在子类型里定义的方法\n下面关于垃圾收集的说法正确的是\n正确答案: D 你的答案: D\rA、一旦一个对象成为垃圾，就立刻被收集掉。\rB、对象空间被收集掉之后，会执行该对象的finalize方法\rC、finalize方法和C++的析构函数是完全一回事情\rD、一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此\r 以前我是堆，你是栈\n你总是能精准的找到我，给我指明出路\n后来有一天我明白了\n我变成了栈，你却隐身堆海\n我却找不到你了，空指针了\n我不愿意如此，在下一轮full gc前\n我找到了object家的finalize\n又找到了你，这次我不会放手\n在世界重启前，一边躲着full gc一边老去\n 1、在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行。\n2、一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法， 并且在下一次垃圾回收动作发生时，才会真正的回收对象占用的内存（《java 编程思想》）\n3、在C++中，对象的内存在哪个时刻被回收，是可以确定的，在C++中，析构函数和资源的释放息息相关，能不能正确处理析构函数，关乎能否正确回收对象内存资源。\n在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行，在java中，所有的对象，包括对象中包含的其他对象，它们所占的内存的回收都依靠垃圾回收器，因此不需要一个函数如C++析构函数那样来做必要的垃圾回收工作。当然存在本地方法时需要finalize()方法来清理本地对象。在《java编程思想》中提及，finalize()方法的一个作用是用来回收“本地方法”中的本地对象\n4、“但是线程并非如此”不理解，希望大佬补充\n下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：\n1 2 3 4 5 6 7 8  byte[] src,dst;\r正确答案: B 你的答案: B\rA、dst=String.fromBytes(src，\u0026#34;GBK\u0026#34;).getBytes(\u0026#34;UTF-8\u0026#34;)\rB、dst=new String(src，\u0026#34;GBK\u0026#34;).getBytes(\u0026#34;UTF-8\u0026#34;)\rC、dst=new String(\u0026#34;GBK\u0026#34;，src).getBytes()\rD、dst=String.encode(String.decode(src，\u0026#34;GBK\u0026#34;))，\u0026#34;UTF-8\u0026#34; )\r   选B，先通过GBK编码还原字符串，在该字符串正确的基础上得到“UTF-8”所对应的字节串。\n socket编程中，以下哪个socket的操作是不属于服务端操作的（）\n正确答案: C 你的答案: C\rA、accept\rB、listen\rC、connect\rD、close\rTCP客户端：\n 建立连接套接字，设置Ip和端口监听，socket() 建立连接 connect write() 获取网络流对象 发送数据 read()获取网络流对象 接收数据 关闭套接字  TCP服务器端\n 建立端口监听 socket() 绑定指定端口 bind() listen 进行端口监听 accept() 阻塞式 直到有客户端访问 read()获取客户端发送数据 write()发送返回数据 close关闭端口监听  下面关于volatile的功能说法正确的是哪个\n正确答案: B C 你的答案: B C\rA、原子性\rB、有序性\rC、可见性\rD、持久性\r synchronized保证三大性，原子性，有序性，可见性，volatile保证有序性，可见性，不能保证原子性\n 以下哪些jvm的垃圾回收方式采用的是复制算法回收\n正确答案: A D 你的答案: A D\rA、新生代串行收集器\rB、老年代串行收集器\rC、并行收集器\rD、新生代并行回收收集器\rE、老年代并行回收收集器\rF、cms收集器\r两个最基本的java回收算法：复制算法和标记清理算法\n复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法\n标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出\n标记整理算法：多了碎片整理，整理出更大的内存放更大的对象\n两个概念：新生代和老年代\n新生代：初始对象，生命周期短的\n老年代：长时间存在的对象\n整个java的垃圾回收是新生代和老年代的协作，这种叫做分代回收。\n Serial New收集器是针对新生代的收集器，采用的是复制算法\nParallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理\nParallel Scavenge（并行）收集器，针对新生代，采用复制收集算法\nSerial Old（串行）收集器，新生代采用复制，老年代采用标记整理\nParallel Old（并行）收集器，针对老年代，标记整理\nCMS收集器，基于标记清理\nG1收集器：整体上是基于标记 整理 ，局部采用复制\n综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。\n 假如某个JAVA进程的JVM参数配置如下：-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3 请问eden区最终分配的大小是多少？\n正确答案: C 你的答案: C\rA、64M\rB、500M\rC、300M\rD、100M\rXms 起始内存\nXmx 最大内存\nXmn 新生代内存\nXss 栈大小。 就是创建线程后，分配给每一个线程的内存大小\n-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-XX:MaxPermSize=n:设置持久代大小\n收集器设置\n-XX:+UseSerialGC:设置串行收集器\n-XX:+UseParallelGC:设置并行收集器\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n-XX:+UseConcMarkSweepGC:设置并发收集器\n垃圾回收统计信息\n-XX:+PrintGC\n-XX:+PrintGCDetails\n-XX:+PrintGCTimeStamps\n-Xloggc:filename\n并行收集器设置\n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。\n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间\n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n并发收集器设置\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以( )\n正确答案: A 你的答案: A\rA、让该类不使用任何关键字\rB、使用private关键字\rC、使用protected关键字\rD、使用void关键字\r default和protected的区别是： 前者只要是外部包，就不允许访问。 后者只要是子类就允许访问，即使子类位于外部包。\n总结：default拒绝一切包外访问；protected接受包外的子类访问\n jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些\n正确答案: C D E 你的答案: C D E\rA、栈空间满\rB、年轻代空间满\rC、老年代满\rD、持久代满\rE、System.gc()\r垃圾收集机制：新生代、老年代、持久代  新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。 老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。 持久代：持久代如果满了，将触发Full GC。  关于java集合下列说法不正确的有哪些（）\n正确答案: A B D 你的答案: A B D\rA、HashSet 它是线程安全的，不允许存储相同的对象\rB、ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复\rC、Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用\rD、ArrayList线程安全的，允许存放重复对象\r线程安全(Thread-safe)的集合对象：\n Vector HashTable StringBuffer  非线程安全的集合对象：\n ArrayList LinkedList HashMap HashSet TreeMap TreeSet StringBulider  若有定义语句： int a=10 ; double b=3.14 ; 则表达式 \u0026lsquo;A'+a+b 值的类型是（）\n正确答案: C 你的答案: C\rA、char\rB、int\rC、double\rD、float\r char \u0026lt; short \u0026lt; int \u0026lt; float \u0026lt; double 不同类型运算结果类型向右边靠齐。\n JVM内存不包含如下哪个部分( )\n正确答案: D 你的答案: D\rA、Stacks\rB、PC寄存器\rC、Heap\rD、Heap Frame\rJVM内存五大区域\n关于下列程序段的输出结果，说法正确的是：（ ）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class MyClass{\rstatic int i;\rpublic static void main(String argv[]){\rSystem.out.println(i);\r}\r}\r正确答案: D 你的答案: D\rA、有错误，变量i没有初始化。\rB、null\rC、1\rD、0\r   类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值。\n 以下程序执行的结果是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class X{\rY y=new Y();\rpublic X(){\rSystem.out.print(\u0026#34;X\u0026#34;);\r}\r}\rclass Y{\rpublic Y(){\rSystem.out.print(\u0026#34;Y\u0026#34;);\r}\r}\rpublic class Z extends X{\rY y=new Y();\rpublic Z(){\rSystem.out.print(\u0026#34;Z\u0026#34;);\r}\rpublic static void main(String[] args) {\rnew Z();\r}\r}\r正确答案: C 你的答案: C\rA、ZYXX\rB、ZYXY\rC、YXYZ\rD、XYZX\r  初始化过程：\n 初始化父类中的静态成员变量和静态代码块 ； 初始化子类中的静态成员变量和静态代码块 ； 初始化父类的普通成员变量和代码块，再执行父类的构造方法； 初始化子类的普通成员变量和代码块，再执行子类的构造方法；  执行过程：\n（1）初始化父类的普通成员变量和代码块，执行Y y=new Y();输出Y （2）再执行父类的构造方法；输出X\n（3）初始化子类的普通成员变量和代码块，执行Y y=new Y();输出Y\n（4）再执行子类的构造方法；输出Z\n（5）所以输出YXYZ\n笔记 UNIX操作系统是著名的（）\n正确答案: B 你的答案: B\rA、多道批处理系统\rB、分时系统\rC、实时系统\rD、分布式系统\r操作系统分类\n批处理操作系统 （Batch Processing Operating System）它的特点是：多道和成批处理。\n分时操作系统(Time Sharing Operating System，简称TSOS) 分时系统具有多路性、交互性、“独占”性和及时性的特征。多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。“独占”性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。及时性指，系统对用户提出的请求及时响应。\n实时操作系统(Real Time Operating System，简称RTOS) 实时操作系统要追求的目标是：对外部请求在严格时间范围内做出反应，有高可靠性和完整性。其主要特点是资源的分配和调度首先要考虑实时性然后才是效率。此外，实时操作系统应有较强的容错能力。\n网络操作系统（Network Operating System，简称NOS）通常运行在服务器上的操作系统，是基于计算机网络的，其目标是相互通信及资源共享。\n分布式操作系统 (Distributed Software Systems)是为分布计算系统配置的操作系统。大量的计算机通过网络被连结在一起，可以获得极高的运算能力及广泛的数据共享。\n分布式操作系统是网络操作系统的更高形式，它保持了网络操作系统的全部功能，而且还具有透明性、可靠性和高性能等。网络操作系统和分布式操作系统虽然都用于管理分布在不同地理位置的计算机，但最大的差别是：网络操作系统知道确切的网址，而分布式系统则不知道计算机的确切地址；分布式操作系统负责整个的资源分配，能很好地隐藏系统内部的实现细节，如对象的物理位置等。这些都是对用户透明的。\n计算机内的传输是 （）传输，而通信线路上的传输是（）传输。\n正确答案: A 你的答案: A\rA、并行，串行\rB、串行，并行\rC、并行，并行\rD、串行，串行\r并行数据传输: 是在传输中有多个数据位同时在设备之间进行的传输.一个编了码的字符通常是由若干位二进制数表示,如用ASCII码编码的符号是由8位二进制数表示的,则并行传输ASCII编码符号就需要8个传输信道,使表示一个符号的所有数据位能同时沿着各自的信道并排的传输.。\n串行数据传输:是在传输中只有1个数据位在设备之间进行的传输.对任何一个由若干位二进制表示的字符,串行传输都是用一个传输信道,按位有序的对字符进行传输。\n区别: 串行传输的速度比并行传输的速度要慢得多,但费用低.并行传输适用距离短,而串行传输适用远距离传输\n下面哪项技术可以用在WEB开发中实现会话跟踪实现？\n正确答案: A B C D 你的答案: A B C D\rA、session\rB、Cookie\rC、地址重写\rD、隐藏域\r会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。\nHTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。\n有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。\n 隐藏表单域：，非常适合步需要大量数据存储的会话应用。 URL重写:URL可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 Cookie:一个Cookie是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为HTTP响应的一部分传送到客户端，客户端被请求保存Cookie值，在对同一服务器的后续请求使用一个Cookie头标将之返回到服务器。与其它技术比较，Cookie的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值 Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话  Windows 操作系统中，文件组织采用（）目录结构。\n正确答案: C 你的答案: C\rA、分区\rB、关系型\rC、树型\rD、网状\r windows操作系统的目录结构是树形结构。就像一棵树，它的树干就是根目录，然后第一个分枝之后是第一层目录\n 目录在linux文件系统中是以怎样的形式存在的？\n正确答案: B 你的答案: B\rA、文件夹\rB、文件\rC、inode\rD、软链接\r Linux系统下，一切都是文件，硬件设备也是文件\n 下列进程通信机制中， UNIX 系统中没有采用的机制是（ ）\n正确答案: B 你的答案: B\rA、信号量集\rB、管程机制\rC、软中断信号\rD、套接字\rLinux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)\nLinux线程间通信：互斥量（mutex），信号量，条件变量\nWindows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket)\nWindows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）\n IPv4地址32位\nMAC地址48位\nIPv6地址128位\n 网络状态码\n   状态码 英文 解释     100 Continue 继续。客户端应继续其请求   101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议   200 OK 请求成功。一般用于GET与POST请求   201 Created 已创建。成功请求并创建了新的资源   202 Accepted 已接受。已经接受请求，但未处理完成   203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   206 Partial Content 部分内容。服务器成功处理了部分GET请求   300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替   302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   303 See Other 查看其它地址。与301类似。使用GET和POST请求查看   304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源   305 Use Proxy 使用***。所请求的资源必须通过***访问   306 Unused 已经被废弃的HTTP状态码   307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向   400 Bad Request 客户端请求的语法错误，服务器无法理解   401 Unauthorized 请求要求用户的身份认证   402 Payment Required 保留，将来使用   403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求   404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\u0026quot;您所请求的资源无法找到\u0026quot;的个性页面   405 Method Not Allowed 客户端请求中的方法被禁止   406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求   407 Proxy Authentication Required 请求要求***的身份认证，与401类似，但请求者应当使用***进行授权   408 Request Time-out 服务器等待客户端发送的请求时间过长，超时   409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突   410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   412 Precondition Failed 客户端请求信息的先决条件错误   413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理   415 Unsupported Media Type 服务器无法处理请求附带的媒体格式   416 Requested range not satisfiable 客户端请求的范围无效   417 Expectation Failed 服务器无法满足Expect的请求头信息   500 Internal Server Error 服务器内部错误，无法完成请求   501 Not Implemented 服务器不支持请求的功能，无法完成请求   502 Bad Gateway 作为网关或者***工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应   503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   504 Gateway Time-out 充当网关或***的服务器，未及时从远端服务器获取请求   505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理    设计模式分类\n一、创建型模式\n工厂模式（Factory Pattern）\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton Pattern）\n建造者模式（Builder Pattern）\n原型模式（Prototype Pattern）\n二、结构型模式\n适配器模式（Adapter Pattern）\n桥接模式（Bridge Pattern）\n过滤器模式（Filter、Criteria Pattern）\n组合模式（Composite Pattern）\n装饰器模式（Decorator Pattern）\n外观模式（Facade Pattern）\n享元模式（Flyweight Pattern）\n代理模式（Proxy Pattern）\n三、行为型模式\n责任链模式（Chain of Responsibility Pattern）\n命令模式（Command Pattern）\n解释器模式（Interpreter Pattern）\n迭代器模式（Iterator Pattern）\n中介者模式（Mediator Pattern）\n备忘录模式（Memento Pattern）\n观察者模式（Observer Pattern）\n状态模式（State Pattern）\n空对象模式（Null Object Pattern）\n策略模式（Strategy Pattern）\n模板模式（Template Pattern）\n访问者模式（Visitor Pattern）\n 常用 ASCII 码值\n空格为 32\n数字0为 48\n“A”为 65\n“a”值为 97\n JVM常用命令\n jps：查看本机java进程信息。 jstack：打印线程的栈信息，制作线程dump文件。 jmap：打印内存映射，制作堆dump文件 jstat：性能监控工具 jhat：内存分析工具 jconsole：简易的可视化控制台 jvisualvm：功能强大的控制台  数据库系统的三级模式结构\n数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成.\n为了能够在系统内部实现这 3 个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：\n外模式/模式映像（映像定义通常包含在各自外模式的描述中，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性，应用程序是依据外模式编写的）\n模式/内模式映像（包含在模式描述中，此映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系，它保证了数据与程序的物理独立性，所以称为数据的物理独立性）\n1NF,2NF,3NF\n1NF : 属性是原子性的，即不可拆分的；例如姓名这个属性是一般不可拆分的；而社会保险号如果是由出生年月日与姓名缩写构成的话，就是可拆分的：包含可拆分的含义：出生年月日，姓名； 是否可拆分取决于对含义的解释；\n2NF：解决了非主键属性对主键属性的部分依赖；如表（A, B, C, D），其中ABCD代表属性，假设（A, B）是主键，若C只依赖于B，则这个表是不符合2NF的，可拆分为（A, B, D）与 （B, C）两张表；很明显，如果主键只有一个属性，那么肯定是2NF\n3NF：解决了非主键属性对主键属性的传递依赖；如表（A,B,C,D），如果主键是A, 而B依赖于A，C依赖于B，则这个表有传递依赖，是不符合3NF的；\n范式的目的是为了减少/消除冗余\n共享锁/排他锁\n共享锁【S锁】，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。\n排他锁【X锁】，又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。\n事务的特性\n原子性（Atomicity）：是事务执行的最小单位。不允许分割。事务的原子性确保动作要么全部成功，要么全部失败\n一致性（Consistency）：执行事务的前后，数据保持不变\n隔离性（Isolation）：并发访问事务时，一个用户的事务数据不能被其他事务所干扰。各并发事务之间的数据库是独立的\n持久性（Durability）：一个事物被提交后，他对数据库的数据改变时持久的。即使数据库发生故障，也不应该对数据有影响\n","description":"本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。数据结构 对n个记录的文件进行快速排序，所需要的辅助存储空间大致为 正确答案: C 你的答案: C A、O（1）B、O（n）C、O（1og2n）D、O（n2）","id":3,"section":"posts","tags":null,"title":"牛客高赞评论整理","uri":"https://eternidad33.github.io/zh/posts/%E7%89%9B%E5%AE%A2%E9%AB%98%E8%B5%9E%E8%AF%84%E8%AE%BA/"},{"content":"入门 简介  简化spring应用开发的一个框架\n整个spring技术栈的一个大集合\nJ2EE开发的一站式解决方案\n 微服务 一个应用就是一个小型服务\n开发，测试，部署简单\n微服务是架构形式，分布式是部署方式\n配置 配置文件 application.yml或application.properties\n作用：修改springboot自动配置的默认值\nyaml：以数据为中心，比json，xml更适合做配置文件\nyaml基本语法 key:（空格）value，空格不能省略\n字面量：普通的值（数字，字符串，布尔）\n\u0026ldquo;\u0026quot;：双引号会转义\n\u0026lsquo;'：单引号不会转义\n数组的写法\n1 2 3 4  pets:- cat- dog- pig  行内写法：pets: [cat,dog,pig]\npom.xml导入配置文件处理器依赖，会有在配置文件中提示\n1 2 3 4 5  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt;\r\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  配置文件写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13  person:name:zhangsanage:14boss:truebirth:2006/12/12maps:{k1: v1,k2:v2}lists:- l1- l2- l3dog:name:小狗age:5  javaBean写法：\n1 2 3 4 5 6 7 8 9 10 11 12  @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;)\r@Component\rpublic class Person {\rprivate String name;\rprivate String age;\rprivate boolean boss;\rprivate Date birth;\rprivate Map\u0026lt;String,Object\u0026gt; maps;\rprivate List\u0026lt;Object\u0026gt; lists;\rprivate Dog dog;\r}\r  @ConfigurationProperties和@Value的区别\n    @ConfigurationProperties @Value     功能 批量注入 单个   松散语法绑定 支持 不支持   spel 不支持 支持   jsr303数据校验 支持 不支持    配置类 写法\n1 2 3 4 5 6 7 8 9  @Configuration\rpublic class MyConfig {\r//将方法的返回值添加到容器中\r @Bean\rpublic HelloService helloService() {\rSystem.out.println(\u0026#34;helloService组件添加成功\u0026#34;);\rreturn new HelloService();\r}\r}\r  测试是否在ioc容器\n1 2 3 4 5 6 7 8  @Autowired\rApplicationContext ioc;\r@Test\rpublic void testHelloService() {\rboolean b = ioc.containsBean(\u0026#34;helloService\u0026#34;);\rSystem.out.println(b);\r}\r  Profile 1.在配置文件中指定profile\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  server:port:8088spring:profiles:active:dev---server:port:8083spring:profiles:dev---server:port:8084spring:profiles:prod  2.命令行\njava -jar wasd.jar --spring.profiles.active=dev\n3.虚拟机参数\n-Dspring.profiles.active=dev\n配置文件加载位置 SpringBoot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n  -file:./config/\n  -file:./\n  -classpath:/config/\n  -classpath:/\n  springboot会从这四个位置全部加载主配置文件\n自动配置原理 视频讲解：https://www.bilibili.com/video/BV1gW411W76m?p=19\n精随:\n1）SpringBoot启动会加载大量的自动配置类\n2）我们看我们需要的功能有没有SpringBoot默认写好的自动配置类;\n3）我们再来看这个自动配置类中到底配置了哪些组件;(只要我们要用的组件有，我们就不需要再来配置了)\n4）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值;\n自动配置类在一定条件下才能生效\napplication.yml 加上 debug: true，让控制台打印自动配置报告\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  ============================\rCONDITIONS EVALUATION REPORT\r============================\rPositive matches:\t（自动配置类启用的）\r-----------------\rAopAutoConfiguration matched:\r- @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)\rAopAutoConfiguration.ClassProxyingConfiguration matched:\r- @ConditionalOnMissingClass did not find unwanted class \u0026#39;org.aspectj.weaver.Advice\u0026#39; (OnClassCondition)\r- @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)\rDispatcherServletAutoConfiguration matched:\r- @ConditionalOnClass found required class \u0026#39;org.springframework.web.servlet.DispatcherServlet\u0026#39; (OnClassCondition)\r- found \u0026#39;session\u0026#39; scope (OnWebApplicationCondition)\rNegative matches:\t（自动配置类没有启用的）\r-----------------\rActiveMQAutoConfiguration:\rDid not match:\r- @ConditionalOnClass did not find required class \u0026#39;javax.jms.ConnectionFactory\u0026#39; (OnClassCondition)\rAopAutoConfiguration.AspectJAutoProxyingConfiguration:\rDid not match:\r- @ConditionalOnClass did not find required class \u0026#39;org.aspectj.weaver.Advice\u0026#39; (OnClassCondition)\rArtemisAutoConfiguration:\rDid not match:\r- @ConditionalOnClass did not find required class \u0026#39;javax.jms.ConnectionFactory\u0026#39; (OnClassCondition)\rBatchAutoConfiguration:\rDid not match:\r- @ConditionalOnClass did not find required class \u0026#39;org.springframework.batch.core.launch.JobLauncher\u0026#39; (OnClassCondition)\rCacheAutoConfiguration:\rDid not match:\r- @ConditionalOnBean (types: org.springframework.cache.interceptor.CacheAspectSupport; SearchStrategy: all) did not find any beans of type org.springframework.cache.interceptor.CacheAspectSupport (OnBeanCondition)\rMatched:\r- @ConditionalOnClass found required class \u0026#39;org.springframework.cache.CacheManager\u0026#39; (OnClassCondition)\r  日志    日志门面（日志的抽象层) 日志实现     JCL ( Jakarta Commons Logging ) ，SLF4j ( Simple LoggingFacade for Java ) ，jboss-logging Log4j，JUL ( java.util.logging )，Log4j2，Logback    SLF4j 和 Logback 的使用 日志记录方法的调用不应该直接调用日志的实现类，而是调用日志抽象层里的方法\n1 2 3 4 5 6 7 8 9  import org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rpublic class HelloWorld {\rpublic static void main(String[] args) {\rLogger logger = LoggerFactory.getLogger(HelloWorld.class);\rlogger.info(\u0026#34;Hello World\u0026#34;);\r}\r}\r   每一个日志的实现框架都有自己的配置文件，使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件\n 遗留问题\n( slf4j+logback ) : Spring ( commons-logging )、Hibernate ( jboss-logging ) 、MyBatis、xxxx\n统一日志记录，即使是别的框架和我一起统一使用 slf4j 进行输出?\n如何让系统中所有的日志都统一到 slf4j ？\n 将系统中其他日志框架先排除出去 用中间包来替换原有的日志框架 我们导入 slf4j 其他的实现  springboot 底层也是使用 slf4j 和 logback 的方式进行日志记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\r@SpringBootTest\rclass DemoApplicationTests {\r//记录器\r Logger logger = LoggerFactory.getLogger(getClass());\r@Test\rpublic void contextLoad(){\r//日志的级别\r // 由低到高：trace \u0026lt; debug \u0026lt; info \u0026lt; warn \u0026lt; error\r //可以调整输出日志的级别，日志在这个及以后的高级别生效\r logger.trace(\u0026#34;这是trace日志。。。\u0026#34;);\rlogger.debug(\u0026#34;这是debug日志。。。\u0026#34;);\rlogger.info(\u0026#34;这是info日志。。。\u0026#34;);\rlogger.warn(\u0026#34;这是warn日志。。。\u0026#34;);\rlogger.error(\u0026#34;这是error日志。。。\u0026#34;);\r}\r}   日志的相关配置\n1 2 3 4 5 6 7 8 9 10 11 12  logging:# 日志打印级别\rlevel:com.hbu.demo:trace# 日志文件保存路径\rfile:path:e:/spring/logpattern:# 指定控制台输出的日志格式\rconsole:\u0026#39;%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n\u0026#39;# 指定文件输出的日志格式\rfile:\u0026#39;%d{yyyy-MM-dd}====[%thread]======%-5level====%logger{50}======%msg%n\u0026#39;  输出结果：\nweb开发 使用SpringBoot\n 创建SpringBoot应用，选中我们需要的模块 SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 自己编写业务代码  自动配置原理?\n这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？\nxxxAutoConfiguration：帮我们给容器中自动配置组件\rxxxProperties：配置类来封装配置文件的内容|\r  所有/webjars/**，都去classpath:/META-INF/resources/webjars/找资源，webjars： 以jar包的方式引入静态资源，webjars网站：https://www.webjars.org/，访问路径：http://localhost:8080/webjars/jquery/3.1.0/jquery.js\n  /**访问当前项目的任何资源（静态资源的文件夹）\n\u0026quot;classpath :/NETA-INF/resources/\u0026quot;,\r\u0026quot;classpath :/resources/\u0026quot;,\r\u0026quot;classpath: /static/\u0026quot;,\r\u0026quot;classpath: /public/\u0026quot;,\r\u0026quot;/\u0026quot;:当前项目的根路径\r  欢迎页;静态资源文件夹下的所有index.html页面;被/**映射\n  所有的**/favicon.ico都是在静态资源文件下找\u0026rsquo;\n  模板引擎 常见模板引擎：JSP、Velocity、Freemarker、Thymeleaf\nspringboot 推荐 Thymeleaf\n引入thymeleaf\n1 2 3 4  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r  thymeleaf 语法 1 2 3 4 5 6 7 8 9 10  //Thymeleaf 配置类\rpublic class ThymeleafProperties {\rprivate static final Charset DEFAULT_ENCODING;\rpublic static final String DEFAULT_PREFIX = \u0026#34;classpath:/templates/\u0026#34;;\rpublic static final String DEFAULT_SUFFIX = \u0026#34;.html\u0026#34;;\rprivate boolean checkTemplate = true;\rprivate boolean checkTemplateLocation = true;\rprivate String prefix = \u0026#34;classpath:/templates/\u0026#34;;\rprivate String suffix = \u0026#34;.html\u0026#34;;\rprivate String mode = \u0026#34;HTML\u0026#34;;\r  只要把html文件放在classpath:/templates/路径下就会自动渲染\n使用：\n  导入 themeleaf 的名称空间\u0026lt;html lang=\u0026quot;en\u0026quot; xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\n  使用 thyleaf 语法\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;成功！\u0026lt;/h1\u0026gt;\r\u0026lt;p th:text=\u0026#34;${hello}\u0026#34;\u0026gt;这里显示文本信息\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r    语法规则\nSimple expressions: （表达式语法）\rVariable Expressions: ${...} Selection Variable Expressions: *{...} Message Expressions: #{...} Link URL Expressions: @{...} Fragment Expressions: ~{...} Literals: （字面量）\rText literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations: （文本操作）\rString concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations: （数学运算）\rBinary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations: （布尔运算）\rBinary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality: （比较运算）\rComparators: \u0026gt; , \u0026lt; , \u0026gt;= , \u0026lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators: （条件运算）\rIf-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _\r","description":"简化spring应用开发的一个框架 整个spring技术栈的一个大集合 J2EE开发的一站式解决方案","id":4,"section":"posts","tags":["java","springboot"],"title":"SpringBoot笔记","uri":"https://eternidad33.github.io/zh/posts/springboot%E7%AC%94%E8%AE%B0/"},{"content":"Collection结构图 Map结构图 总结 推荐视频：Java零基础教程视频（适合Java 0基础，Java初学入门）\nArrayList：底层是数组\nLinkedList：底层是双向链表\nVector：底层是数组，线程安全的，效率较低，使用较少\nHashSet：底层是 HashMap，放到 HashSet集合中的元素等同于放到HashMap集合 key部分\nTreeSet：底层是TreeMap，放到TreeSet.集合中的元素等同于放到TreeMap集合key部分\nHashMap：底层是哈希表\nHashTable：底层是哈希表，线程安全，效率较低，使用较少\nProperties：线程安全的，key和value只能存储字符串\nTreeMap：底层是二叉树，它的key可以自动按照大小排序\nList集合存储元素的特点：\n 有序：存进去和取出来的顺序相同，每个元素都有下标 可重复  Set集合存储元素的特点：\n 无序：存进去和取出来的顺序不相同，Set集合中元素没有有下标 不可重复  SortedSet（SortedMap）集合存储元素的特点\n 无序不可重复 SortedSet集合中元素是可排序的 可排序：可以按照大小顺序排列  Map集合的key就是一个Set集合，往Set集合放数据实际上放到了Map集合的key部分。\nArrayList  默认初始化容量为10 底层是object数组 扩容1.5倍 建议给定一个预估的初始化容量，减少数组的扩容次数 优点：随机增删元素效率低 缺点：末尾增删元素效率高  LinkedList  底层也是有下标的，双向链表 检索、查询的时候只能从头结点开始 优点：随机增删元素效率高 缺点：查询效率低  Vector  线程安全 初始化容量为10 2倍扩容 底层是数组  HashSet  底层HashMap 无序，不可重复 无序是指没有下标  TreeSet  底层TreeMap 无序，不可重复 元素会自动排序存储 要实现Comparable\u0026lt;T\u0026gt;的 compareTo(T o)方法  HashMap   底层是哈希表\n  数组+单向链表\n  源码\n1 2 3 4 5 6 7 8 9 10 11  public class HashMap\u0026lt;K,V\u0026gt;{\r//数组\r transient Node\u0026lt;K,V\u0026gt;[] table;\r//链表\r static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; {\rfinal int hash;\rfinal K key;\rV value;\rNode\u0026lt;K,V\u0026gt; next;\r}\r}\r    同一个链表的hash值相等\n  放在HashMap中的元素需要重写equals和hashCode方法\n  map.put(k,v)\n 封装node对象 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，直接将Node添加到这个位置 有元素，在链表每个节点进行euquals()比较，如果全为false，在末尾添加，如果有True，更新Value    map.get(k)\n 调用hashCode()方法获取哈希值 通过哈希函数转化成数组下标 下标处没有元素，返回None 下标有链表，对链表元素的Key比较equals，有true返回value，全为false，代表没有元素，返回null    扩容是原来长度的2倍\n  允许key值为null\n  HashTable  key和value都不能为null 线程安全 初始化容量11 扩容2倍+1  Properties  继承HashTable，线程安全的 key和value只能存储字符串  TreeMap  放到TreeMap集合中的元素的key部分进行排序有两种实现方式  实现java.lang.Comparable的compareTo方法 构造TreeSet或TreeMap集合的时候传一个比较器对象Comparator   比较规则不会发生改变或者比较规则只有一个的时候使用Comparable 比较规则多个，并且比较规则需要频繁切换Comparator  ","description":"","id":5,"section":"posts","tags":["java"],"title":"Java集合","uri":"https://eternidad33.github.io/zh/posts/java%E9%9B%86%E5%90%88/"},{"content":"欢迎大家访问我的github\n创建以用户名为名称的仓库\n自定义自己的README文件即可在自己的github显示了\n我这个上边显示的编码时长，是添加了一个action每天更新自己的编码时长\n具体设计步骤可参考 github上的athul/waka-readme项目\n总结一下简要的步骤\n 注册wakatime账号 在自己常用的IDE上下载wakatime插件，配置上自己的API key 将自己的API key存到自己GitHub仓库的secrets 在README文件上加上  1 2  \u0026lt;!--START_SECTION:waka--\u0026gt;\r\u0026lt;!--END_SECTION:waka--\u0026gt;\r  配置GitHub仓库的Action，这样就能每天自动运行了  ","description":"","id":6,"section":"posts","tags":["github"],"title":"自定义GitHub主页","uri":"https://eternidad33.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89github%E4%B8%BB%E9%A1%B5/"},{"content":"连接SQLite 要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；\n连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。\nPython定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。\n由于SQLite的驱动内置在Python标准库中，可以直接来操作SQLite数据库。\n1 2  # 导入SQLite驱动: import sqlite3   1 2 3 4  # 连接到SQLite数据库 # 数据库文件是test.db # 如果文件不存在，会自动在当前目录创建: conn = sqlite3.connect(\u0026#39;test.db\u0026#39;)   1 2  # 创建一个Cursor: cursor = conn.cursor()   1 2  # 执行一条SQL语句，创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 继续执行一条SQL语句，插入一条记录: cursor.execute(\u0026#39;insert into user (id, name) values (\u0026#34;1\u0026#34;, \u0026#34;vigilr\u0026#34;)\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 通过rowcount获得插入的行数: cursor.rowcount   1  1 2 3 4 5 6  # 关闭Cursor: cursor.close() # 提交事务: conn.commit() # 关闭Connection: conn.close()   1 2 3 4  conn = sqlite3.connect(\u0026#39;test.db\u0026#39;) cursor = conn.cursor() # 执行查询语句: cursor.execute(\u0026#39;select * from user where id=?\u0026#39;,(\u0026#39;1\u0026#39;,))   \u0026lt;sqlite3.Cursor at 0x2040e224810\u0026gt;  1 2 3  # 获得查询结果集: values = cursor.fetchall() values   [('1', 'vigilr')]  1 2  cursor.close() conn.close()   使用Python的DB-API时，只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用。\n使用Cursor对象执行insert，update，delete语句时，执行结果由rowcount返回影响的行数，就可以拿到执行结果。\n使用Cursor对象执行select语句时，通过featchall()可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。\n如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，例如：\n1  cursor.execute(\u0026#39;select * from user where name=? and pwd=?\u0026#39;, (\u0026#39;abc\u0026#39;, \u0026#39;password\u0026#39;))   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # -*- coding: utf-8 -*- import sqlite3 # 初始数据: conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;create table user(id varchar(20) primary key, name varchar(20), score int)\u0026#39;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-001\u0026#39;, \u0026#39;Adam\u0026#39;, 95)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-002\u0026#39;, \u0026#39;Bart\u0026#39;, 62)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-003\u0026#39;, \u0026#39;Lisa\u0026#39;, 78)\u0026#34;) cursor.close() conn.commit() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13  def get_score_in(low, high): \u0026#39;\u0026#39;\u0026#39;返回指定分数区间的名字，按分数从低到高排序\u0026#39;\u0026#39;\u0026#39; conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;select name from user where score\u0026gt;=? and score\u0026lt;=? ORDER BY score\u0026#39;,(low,high)) temp=cursor.fetchall() result=[] for t in temp: for i in t: result.append(i) cursor.close() conn.close() return result   1 2 3 4 5 6 7  # 测试: assert get_score_in(80, 95) == [\u0026#39;Adam\u0026#39;], get_score_in(80, 95) assert get_score_in(60, 80) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;], get_score_in(60, 80) assert get_score_in(60, 100) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;, \u0026#39;Adam\u0026#39;], get_score_in(60, 100) print(\u0026#39;Pass\u0026#39;)   Pass  连接MySQL 安装MySQL驱动\n由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。\nMySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数--allow-external：\npip install mysql-connector-python --allow-external mysql-connector-python\n如果上面的命令安装失败，可以试试另一个驱动：\npip install mysql-connector\n除了使用mysql.connector还可以使用pymysql\n1 2  # 导入pymysql模块 import pymysql   1 2 3 4 5 6 7 8 9 10 11 12  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;) cursor.close() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 插入一行记录，注意MySQL的占位符是%s: cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;1\u0026#39;, \u0026#39;wasd\u0026#39;]) cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;2\u0026#39;, \u0026#39;zxc\u0026#39;]) print(\u0026#39;受影响行数：\u0026#39;,cursor.rowcount) # 提交事务: conn.commit() cursor.close() conn.close()   受影响行数： 1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) # 运行查询: cursor = conn.cursor() cursor.execute(\u0026#39;select * from user\u0026#39;) values = cursor.fetchall() print(values) # 关闭Cursor和Connection: cursor.close() conn.close()   (('1', 'wasd'), ('2', 'zxc'))  使用SQLAlchemy ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。\n在Python中，最有名的ORM框架是SQLAlchemy。\n首先通过pip安装SQLAlchemy：pip install sqlalchemy\n1 2 3 4 5 6  # 第一步，导入SQLAlchemy，并初始化DBSession： # 导入: from sqlalchemy import Column, String, create_engine,ForeignKey from sqlalchemy.orm import sessionmaker,relationship from sqlalchemy.ext.declarative import declarative_base   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 创建对象的基类: Base = declarative_base() # 定义User对象: class User(Base): # 表的名字: __tablename__ = \u0026#39;users\u0026#39; # 表的结构: id = Column(String(20), primary_key=True) name = Column(String(20)) # 以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如Scho class School(Base): __tablename__ = \u0026#39;school\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # 初始化数据库连接:mysqlconnector和pymysql都可以用 # engine = create_engine(\u0026#39;mysql+mysqlconnector://root:123456@localhost:3308/test\u0026#39;) engine = create_engine(\u0026#39;mysql+pymysql://root:123456@localhost:3308/test\u0026#39;) # 创建DBSession类型: DBSession = sessionmaker(bind=engine)   create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：\n数据库类型+数据库驱动名称://用户名:密码@数据库地址:端口号/数据库名\n由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 创建所有定义的表到数据库中 Base.metadata.create_all(engine) # 创建session对象: session = DBSession() # 创建新User对象: user1 = User(id=\u0026#39;1\u0026#39;, name=\u0026#39;wasd\u0026#39;) user2 = User(id=\u0026#39;2\u0026#39;, name=\u0026#39;zxc\u0026#39;) user3 = User(id=\u0026#39;3\u0026#39;, name=\u0026#39;qwe\u0026#39;) user4 = User(id=\u0026#39;4\u0026#39;, name=\u0026#39;rty\u0026#39;) user5 = User(id=\u0026#39;5\u0026#39;, name=\u0026#39;vbn\u0026#39;) user6 = User(id=\u0026#39;6\u0026#39;, name=\u0026#39;fgh\u0026#39;) # 添加到session: session.add(user1) session.add(user2) session.add(user3) session.add(user4) session.add(user5) session.add(user6) # 提交即保存到数据库: session.commit() # 关闭session: session.close() # 关键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接。   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\pymysql\\cursors.py:170: Warning: (1366, \u0026quot;Incorrect string value: '\\\\xD6\\\\xD0\\\\xB9\\\\xFA\\\\xB1\\\\xEA...' for column 'VARIABLE_VALUE' at row 489\u0026quot;) result = self._query(query)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 查询数据 # 创建Session: session = DBSession() # 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行: user = session.query(User).filter(User.id==\u0026#39;1\u0026#39;).one() users = session.query(User).filter(User.id!=\u0026#39;1\u0026#39;).all() # 打印类型和对象的name属性: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) for user in users: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) # 关闭Session: session.close()   type: \u0026lt;class '__main__.User'\u0026gt; name: wasd type: \u0026lt;class '__main__.User'\u0026gt; name: zxc type: \u0026lt;class '__main__.User'\u0026gt; name: qwe type: \u0026lt;class '__main__.User'\u0026gt; name: rty type: \u0026lt;class '__main__.User'\u0026gt; name: vbn type: \u0026lt;class '__main__.User'\u0026gt; name: fgh  ORM就是把数据库表的行与相应的对象建立关联，互相转换。\n由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。\n例如，如果一个User拥有多个Book，就可以定义一对多关系如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class User(Base): __tablename__ = \u0026#39;user\u0026#39; __table_args__ = {\u0026#39;extend_existing\u0026#39;: True} id = Column(String(20), primary_key=True) name = Column(String(20)) # 一对多: books = relationship(\u0026#39;Book\u0026#39;) class Book(Base): __tablename__ = \u0026#39;book\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # “多”的一方的book表是通过外键关联到user表的: user_id = Column(String(20), ForeignKey(\u0026#39;user.id\u0026#39;)) # 当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。 # 创建所有定义的表到数据库中 Base.metadata.create_all(engine)   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\sqlalchemy\\ext\\declarative\\clsregistry.py:129: SAWarning: This declarative base already contains a class with the same class name and module name as __main__.User, and will be replaced in the string-lookup table. % (item.__module__, item.__name__)  更多用法可参考：这篇文章https://www.jianshu.com/p/65903a69d61d\n","description":"","id":7,"section":"posts","tags":["python"],"title":"Python三种连接数据库的方式","uri":"https://eternidad33.github.io/zh/posts/python%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"content":"购买服务器 直接购买皆可以了\n有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器\n现在购买可以91.8一年\n学生购买是9.50一个月（参与云翼计划然后学生认证即可）\n 我是单买的一个月的，因为不经常用，想用的时候就买一个月的\n 安装镜像 从镜像市场选择宝塔控制面板安装\n 宝塔Linux面板（LAMP/LNMP/Tomcat/Node.js）\n功能强大且终身免费的Linux服务器管理软件，一键部署：LAMP/LNMP/Tomcat/Node.js、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。\n 镜像安装完要配置安全组打开相应端口\n面板配置 bt命令进行相关的操作\n可以更改掉默认的用户名和密码\n浏览器访问公网ip:8888进行环境的安装\n可以选择LNMP安装，大约5~6分钟安装完成\n配置mysql数据库相应的端口，默认3306，可以改为其他端口\n安装完成后可以数据库的root密码\n安装Tomcat 从左侧的软件商店安装Tomcat（不用单独安装Java，面板自动安装Java）\n安装完tomcat后要在面板中放行8080端口，前边的安全组也要放行8080端口\n浏览器成功访问公网ip:8080，即为成功安装\n部署项目 本文部署的是GitHub上的 一个基于SSM+Websocket的实时在线聊天室项目\n配置数据库信息并生成war包\n成功生成war包后的效果如下：\n在服务器的mysql运行本项目中的sql文件\n将生成的war文件上传到/www/server/tomcat/webapps目录下，tomcat会自动解压\n 上传文件方法有很多，可以通过命令行，也可以用工具，我知道的工具如下：\n xshell及xftp IDEA的阿里云部署插件(Alibaba Cloud Toolkit) 通过宝塔面板上传   浏览器访问公网IP:8080/网站应用名，出现下面的界面即为成功部署\n","description":"","id":8,"section":"posts","tags":["java"],"title":"阿里云宝塔面板配置及部署Java项目","uri":"https://eternidad33.github.io/zh/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE/"},{"content":" Scrapy is a fast high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.\n​\t\u0026mdash;\u0026mdash;\u0026mdash;来自官方文档的介绍\n  Engine从Spider处获得爬取请求(Request) Engine将爬取请求转发给Scheduler，用于调度 Engine从Scheduler处获得下一个要爬取的请求 Engine将爬取请求通过中间件发送给Downloader 爬取网页后，Downloader形成响应（Response）通过中间件发给Engine Engine将收到的响应通过中间件发送给Spider处理 Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine Engine将爬取项发送给Item Pipeline（框架出口） Engine将爬取请求发送给Scheduler  Engine控制各模块数据流，不间断从Scheduler处获得爬取请求，直至请求为空。\n数据流的出入口\n框架入口：Spider的初始爬取请求\n框架出口：Item Pipeline\n用户只需编写(配置)Spider和Item Pipeline\nEngine\n 控制所有模块之间的数据流 根据条件触发事件  不需要用户修改\nDownloader\n根据请求下载网页\n不需要用户修改\nScheduler\n对所有爬取请求进行调度管理\n不需要用户修改\nDownloader Middleware\n目的：实施Engine、Scheduler和Downloader之间进行用户可配置的控制\n功能：修改、丢弃、新增请求或响应\n用户可以编写配置代码\nSpider\n 解析Downloader返回的响应（Response） 产生爬取项（scraped item） 产生额外的爬取请求（Request）  需要用户编写配置代码\nItem Pipelines\n 以流水线方式处理Spider产生的爬取项 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库  需要用户编写配置代码\nSpider Middleware\n目的：对请求和爬取项的再处理\n功能：修改、丢弃、新增请求或爬取项\n用户可以编写配置代码\nrequests 和 Scrapy的异同\n相同点：\n 两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线 两者可用性都好，文档丰富，入门简单 两者都没有处理js、提交表单、应对验证码等功能（可扩展）  不同点：\n   requests Scrapy     页面级爬虫 网站级爬虫   功能库 框架   并发性考虑不足，性能较差 并发性好，性能较高   重点在于页面下载 重点在于爬虫结构   定制灵活 一般定制灵活，深度定制困难   上手十分简单 入门稍难    Scrapy常用命令\n   命令 说明 格式     startproject 创建一个新工程 scrapy startproject \u0026lt;name\u0026gt; [dir]   genspider 创建一个爬虫 scrapy genspider [options] \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt;   settings 获得爬虫配置信息 scrapy settings [options]   crawl 运行一个爬虫 scrapy crawl \u0026lt;spider\u0026gt;   list 列出工程中所有爬虫 scrapy list   shell 启动URL调试命令行 scrapy shell [url]    生成的工程目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  PS E:\\scrapyDemo\u0026gt; tree /f 卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r│ scrapy.cfg -------------------\u0026gt;\u0026gt;部署Scrapy爬虫的配置文件\r│\r└─scrapyDemo ------------\u0026gt;\u0026gt;Scrapy框架的用户自定义Python代码\r│ items.py --------------\u0026gt;\u0026gt;Items代码模板（继承类）\r│ middlewares.py -------\u0026gt;\u0026gt;Middlewares代码模板（继承类）\r│ pipelines.py ---------\u0026gt;\u0026gt;Pipelines代码模板（继承类）\r│ settings.py --------\u0026gt;\u0026gt;Scrapy爬虫的配置文件\r│ __init__.py ---------\u0026gt;\u0026gt;初始化脚本\r│\r├─spiders --------------\u0026gt;\u0026gt;Spiders代码模板目录（继承类）\r│ │ firstSpider.py ------\u0026gt;\u0026gt;生成的爬虫\r│ │ __init__.py ------\u0026gt;\u0026gt;初始文件，无需修改\r│ │\r│ └─__pycache__ --------\u0026gt;\u0026gt;缓存目录，无需修改\r│ firstSpider.cpython-37.pyc\r│ __init__.cpython-37.pyc\r│\r└─__pycache__ -----------\u0026gt;\u0026gt;缓存目录，无需修改\rsettings.cpython-37.pyc\r__init__.cpython-37.pyc\r  Scrapy爬虫的使用步骤\n步骤1：创建一个工程和Spider模板\n步骤2：编写Spider\n步骤3：编写Item Pipeline\n步骤4：优化配置策略\nScrapy爬虫的数据类型\n  Request类\nRequest对象表示一个HTTP请求，由Spider生成，由Downloader执行\n  Response类\nResponse对象表示一个HTTP响应，由Downloader生成，由Spider处理\n  Item类\nItem对象表示一个从HTML页面中提取的信息内容，由Spider生成，由Item Pipeline处理，Item类似字典类型，可以按照字典类型操作\n  Scrapy爬虫支持多种HTML信息提取方法：\n Beautiful Soup lxml re XPath Selector CSS Selector  ","description":"","id":9,"section":"posts","tags":["python"],"title":"Scrapy 框架笔记","uri":"https://eternidad33.github.io/zh/posts/scrapy/"},{"content":"基础页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;\r\u0026lt;h2\u0026gt;前端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;List1\u0026#34;\u0026gt;\r\u0026lt;li id=\u0026#34;li1\u0026#34;\u0026gt;HTML\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;h2\u0026gt;后端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;list2\u0026#34;\u0026gt;\r\u0026lt;li title=\u0026#34;C语言\u0026#34;\u0026gt;C\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;Java语言\u0026#34;\u0026gt;Java\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;我是Python\u0026#34;\u0026gt;Python\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;C Sharp\u0026#34;\u0026gt;C#\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r  运行结果\n通过ID获取元素 1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;list1\u0026#34;);\rvar c2 = document.getElementById(\u0026#34;li1\u0026#34;)\rdocument.write(\u0026#34;通过ID获取 ul 标签\u0026#34; + c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#34;通过ID获取 li 标签\u0026#34; + c2);\r\u0026lt;/script\u0026gt;\r  显示结果：\ninnerHTML用于获取或修改p标签内容\n1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\rc1.innerHTML = \u0026#39;我是修改后的p标签\u0026#39;;\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\r\u0026lt;/script\u0026gt;\r  显示结果：\n改变HTML样式 基本语法格式：Object.style.property=str;\n1 2 3 4 5 6 7  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.style.color = \u0026#39;red\u0026#39;\rc1.style.fontSize = \u0026#39;30px\u0026#39;\rc1.style.fontFamily = \u0026#39;隶书\u0026#39;\rc1.style.backgroundColor = \u0026#39;#cccccc\u0026#39;\r\u0026lt;/script\u0026gt;\r  显示效果：\n改变类选择器 格式object.className = classname\n1 2  var c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.className = \u0026#39;test\u0026#39;\r  显示结果：\n通过name属性获取元素 格式document.getElementsByName(str);\n1 2 3  var c1 = document.getElementsByName(\u0026#39;myname\u0026#39;);\rdocument.write(c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#39;数组的长度为\u0026#39; + c1.length);\r  显示结果：\n通过标签名字获取标签 格式：document.getElementsByTagName(str);\n1 2  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\r  显示结果：\nID是唯一的。\nName可以重复。\nTagName是某一标签类的集合。\n获取属性值 格式：elementNode.getAttribute(name)\n1 2 3 4 5 6 7 8  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  设置新属性 elementNode.setAttribute(name,value)\n1 2 3 4 5 6 7 8 9 10 11 12  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text == \u0026#34;C Sharp\u0026#34;) {\rc1[i].setAttribute(\u0026#39;title\u0026#39;, \u0026#39;C#\u0026#39;)\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;)\r}\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  节点对象属性 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：\n  nodeName : 节点的名称\n  nodeValue ：节点的值\n  nodeType ：节点的类型\n  1 2 3 4 5 6  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的名称:\u0026#34; + c1[i].nodeName)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的类型:\u0026#34; + c1[i].nodeType)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的值:\u0026#34; + c1[i].nodeValue)\r}\r  访问子节点 elementNode.childNodes用于访问子节点\nnode.firstChild用于访问第一个子节点\nnode.lastChild用于访问最后一个子节点\n访问父节点 elementNode.parentNode用于访问父节点\nelementNode.parentNode.parentNode用于访问祖节点\n访问兄弟节点   nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。nodeObject.nextSibling\n  previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。nodeObject.previousSibling \n   如果无兄弟节点，则该属性返回 null。\n 插入节点 appendChild(newnode)\n1 2 3 4  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.appendChild(newNode)\r  insertBefore() 方法可在已有的子节点前插入一个新的子节点。\ninsertBefore(newnode,node);\n1 2 3 4 5  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rvar lNode = document.getElementById(\u0026#39;List1\u0026#39;).firstChild\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.insertBefore(newNode, lNode)\r  删除节点 removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。\nnodeObject.removeChild(node)\n node ：必需，指定需要删除的节点。\n 替换元素节点 replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。\nnode.replaceChild (newnode,oldnew ) \n newnode : 必需，用于替换 oldnew 的对象。\noldnew : 必需，被 newnode 替换的对象。\n 创建元素节点 createElement()方法可创建元素节点。此方法可返回一个 Element 对象。\ndocument.createElement(tagName)\ntagName：字符串值，这个字符串用来指明创建元素的类型。\n 要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。\n 创建文本节点 createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。\ndocument.createTextNode(data)\ndata : 字符串值，可规定此节点的文本。\n","description":"","id":10,"section":"posts","tags":["javaScript","html"],"title":"JavaScript DOM 操作","uri":"https://eternidad33.github.io/zh/posts/javascript-dom%E6%93%8D%E4%BD%9C/"},{"content":"项目配置 @Value(“${变量名}”) 变量名：配置文件中的全局变量\n1 2 3 4  @Value(\u0026#34;${name}\u0026#34;)\rprivate String name;\r@Value(\u0026#34;${desc}\u0026#34;)\rprivate String desc;\r  yml配置文件中的配置\n1 2  name:维吉尔desc:你好，${name}！  @ConfigurationProperties(prefix = \u0026ldquo;对象名\u0026rdquo;) @ConfigurationProperties(prefix = \u0026ldquo;person\u0026rdquo;)注解要和@Component一起用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  @Component\r@ConfigurationProperties(prefix = \u0026#34;person\u0026#34;)\rpublic class Person {\rprivate String name;\rprivate int age;\rprivate String sex;\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\r@Override\rpublic String toString() {\rfinal StringBuffer sb = new StringBuffer(\u0026#34;Person{\u0026#34;);\rsb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#34;, age=\u0026#34;).append(age);\rsb.append(\u0026#34;, sex=\u0026#39;\u0026#34;).append(sex).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#39;}\u0026#39;);\rreturn sb.toString();\r}\r}\r  yml配置文件中的对象配置\n1 2 3 4  person:name:Vigilrage:23sex:男  调用方式，会用到@Autowired和@GetMapping(\u0026quot;/person\u0026quot;)\n1 2 3 4 5 6 7  @Autowired\rprivate Person person;\r@GetMapping(\u0026#34;/person\u0026#34;)\rpublic String printPerson() {\rreturn this.person.toString();\r}\r  请求方式    代码 说明 举例     @GetMapping(\u0026quot;/url\u0026quot;) get请求 @GetMapping(\u0026quot;/user/{id}\u0026quot;)   @PostMapping(\u0026quot;/url\u0026quot;) post请求 @PostMapping(\u0026quot;/user\u0026quot;)   @PutMapping(\u0026quot;/url\u0026quot;) put请求 @PutMapping(\u0026quot;/user/{id}\u0026quot;)    Controller相关注解 @Controller 1 2 3 4 5 6 7  @Controller\rpublic class HelloController {\r@GetMapping(\u0026#34;/index\u0026#34;)\rpublic String printIndex() {\rreturn \u0026#34;index\u0026#34;;\r}\r}\r  直接用可解析HTML\n@ResponseBody 与@Controller配合使用\n1 2 3 4 5 6 7 8  @Controller\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\r@ResponseBody\rpublic String sayHello() {\rreturn desc;\r}\r}\r  @RestController @RestController=@Controller+@ResponseBody\n1 2 3 4 5 6 7  @RestController\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\rpublic String sayHello() {\rreturn desc;\r}\r}\r  获取参数 @PathVariable(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4  @GetMapping(\u0026#34;/user/{id}\u0026#34;)\rpublic UserEntity findId(@PathVariable(\u0026#34;id\u0026#34;) Integer id) {\rreturn repository.findById(id).orElse(null);\r}\r  @RequestParam(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4 5 6 7 8 9  @PostMapping(\u0026#34;/user\u0026#34;)\rpublic UserEntity create(@RequestParam(\u0026#34;age\u0026#34;) Integer age,\r@RequestParam(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;sex\u0026#34;) String sex) {\rUserEntity userEntity = new UserEntity();\ruserEntity.setAge(age);\ruserEntity.setName(name);\ruserEntity.setSex(sex);\rreturn repository.save(userEntity);\r}\r  数据库相关 @Entity 表的定义\n@Id 设置主键\n@GeneratedValue 设置自增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  @Entity\rpublic class UserEntity {\r@Id\r@GeneratedValue\rprivate Integer id;\rprivate String name;\rprivate String sex;\rprivate Integer age;\rpublic UserEntity() {\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\rpublic Integer getAge() {\rreturn age;\r}\rpublic void setAge(Integer age) {\rthis.age = age;\r}\r}\r   在IDEA中声明@Entity后，左侧会有数据库的标志\n @Transactional 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Transactional\rpublic void createTwo() {\rUserEntity userEntity1 = new UserEntity();\ruserEntity1.setAge(12);\ruserEntity1.setName(\u0026#34;wasd\u0026#34;);\ruserEntity1.setSex(\u0026#34;sssss\u0026#34;);\rrepository.save(userEntity1);\rUserEntity userEntity2 = new UserEntity();\ruserEntity2.setAge(1314);\ruserEntity2.setName(\u0026#34;zxcvbnm\u0026#34;);\ruserEntity2.setSex(\u0026#34;ddddddd\u0026#34;);\rrepository.save(userEntity2);\r}\r  数据库表的引擎必须为INNODB才可进行事务管理\n","description":"","id":11,"section":"posts","tags":["java","springboot"],"title":"SpringBoot 必备注解","uri":"https://eternidad33.github.io/zh/posts/springboot%E5%BF%85%E5%A4%87%E6%B3%A8%E8%A7%A3/"},{"content":"[toc]\n简易的图书管理系统 项目简介 推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql\n用到的知识：Java，MySQL\n源码已上传至码云\n项目整体架构 源码目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  PS E:\\IdeaProjects\\BookManager\\src\u0026gt; tree /f\r卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r├─dao\r│ BookDao.java\r│ BookTypeDao.java\r│ UserDao.java\r│\r├─entity\r│ Book.java\r│ Booktype.java\r│ User.java\r│\r├─images\r│ book.png\r│ susu.jpg\r│\r├─META-INF\r│ MANIFEST.MF\r│\r├─util\r│ DbUtil.java\r│ StringUtil.java\r│\r└─view\rAbout.java\rAbout.jfd\rBookAddFrm.java\rBookAddFrm.jfd\rBookTypeAddFrm.java\rBookTypeAddFrm.jfd\rBookTypeManagerFrm.java\rBookTypeManagerFrm.jfd\rLogin.form\rLogin.java\rMainFrm.java\rMainFrm.jfd\r  由此可见，本项目也是采用的 MVC 架构，dao包用于操作数据库，entity包包含本项目的实体类，images包是本项目用到的图片，META-INF包是生成 Jar 包时产生的文件夹，util包包含本项目用到的工具类，view包是本项目的视图层，用于设计窗口显示。\n项目中各类的依赖关系如下图\n具体实现 util包 本项目的工具包，包含两个工具类\nDbUtil.java主要是设计了数据库的驱动，地址，用户名及密码，和控制数据库的连接与断开\nStringUtil.java只是用于判断字符串是否为空，只有空格也算为空\nentity包 此包包含了数据库表的实体对象，可以自己写，也可以通过 idea 的EasyCode插件进行代码生成，但是后边要用到的必要的构造方法要自己写。\n大多数情况下都是简单类包含 Getter 和 Setter 方法，如下是EasyCode插件生成的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  public class Booktype implements Serializable {\rprivate static final long serialVersionUID = -43707012852599825L;\rprivate Integer id;\rprivate String booktypename;\r@Override\rpublic String toString() {\rreturn this.booktypename;\r}\rprivate String booktypedesc;\rpublic Booktype(String booktypename, String booktypedesc) {\rthis.booktypename = booktypename;\rthis.booktypedesc = booktypedesc;\r}\rpublic Booktype() {\rsuper();\r}\rpublic Booktype(Integer id, String booktypename, String booktypedesc) {\rthis(booktypename, booktypedesc);\rthis.id = id;\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getBooktypename() {\rreturn booktypename;\r}\rpublic void setBooktypename(String booktypename) {\rthis.booktypename = booktypename;\r}\rpublic String getBooktypedesc() {\rreturn booktypedesc;\r}\rpublic void setBooktypedesc(String booktypedesc) {\rthis.booktypedesc = booktypedesc;\r}\r}\r  dao包 进行数据库的访问\n类中的方法定义形式基本为public 返回类型 方法名(Connection conn, 实体类 对象名) throws SQLException\n例如用户登录的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public User login(Connection connection, User user) throws SQLException {\rUser resultUser = null;\rString sql = \u0026#34;select * from table_user where userName=? and password=?\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, user.getUserName());\rpsmt.setString(2, user.getPassword());\rResultSet resultSet = psmt.executeQuery();\rif (resultSet.next()) {\rresultUser = new User();\rresultUser.setId(resultSet.getInt(\u0026#34;id\u0026#34;));\rresultUser.setUserName(resultSet.getString(\u0026#34;userName\u0026#34;));\rresultUser.setPassword(resultSet.getString(\u0026#34;password\u0026#34;));\r}\rreturn resultUser;\r}\r  步骤总结：\n  其中 SQL 语句中的要查找的值要用?代替，方便后面设置\nString sql = \u0026quot;select * from table_user where userName=? and password=?\u0026quot;;\n  然后创建 SQL 语句的游标对象\npsmt，PreparedStatement psmt = connection.prepareStatement(sql);\n  设置 SQL 语句中的变量值，第几个?为几，索引就是几，没有 0\npsmt.setString(1, user.getUserName());\n  执行查询语句，并返回ResultSet对象用于保存查询结果\nResultSet resultSet = psmt.executeQuery();\n  然后根据需求进行其他操作\n  BookDao类的设计如下，dao包下的其他类类似\n添加图书\n1 2 3 4 5 6 7 8 9 10 11  public static int add(Connection connection, Book book) throws SQLException {\rString sql = \u0026#34;insert into book values(null,?,?,?,?,?,?)\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setInt(4, book.getBooktypeid());\rpsmt.setString(5, book.getBookdesc());\rpsmt.setFloat(6, book.getPrice());\rreturn psmt.executeUpdate();\r}\r  添加成功返回 1，添加失败返回 0\n删除图书\n1 2 3 4 5 6  public static int delete(Connection conn, String id) throws SQLException {\rString sql = \u0026#34;delete from book where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, id);\rreturn psmt.executeUpdate();\r}\r  删除成功返回 1，删除失败返回 0\n修改图书\n1 2 3 4 5 6 7 8 9 10 11 12  public static int update(Connection conn, Book book) throws SQLException {\rString sql = \u0026#34;update book set bookName=?,author=?,sex=?,price=?,bookTypeid=?,bookDesc=? where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setFloat(4, book.getPrice());\rpsmt.setInt(5, book.getBooktypeid());\rpsmt.setString(6, book.getBookdesc());\rpsmt.setInt(7, book.getId());\rreturn psmt.executeUpdate();\r}\r  修改成功返回 1，修改失败返回 0\n查询图书\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static ResultSet list(Connection conn, Book book) throws SQLException {\rStringBuffer sb = new StringBuffer(\u0026#34;select * from book b,table_booktype bt where b.bookTypeId=bt.id\u0026#34;);\rif (!StringUtil.isEmpty(book.getBookname())) {\rsb.append(\u0026#34; and b.bookName like \u0026#39;%\u0026#34; + book.getBookname() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (!StringUtil.isEmpty(book.getAuthor())) {\rsb.append(\u0026#34; and b.author like \u0026#39;%\u0026#34; + book.getAuthor() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (book.getBooktypeid() != null \u0026amp;\u0026amp; book.getBooktypeid() != -1) {\rsb.append(\u0026#34; and b.bookTypeId=\u0026#34; + book.getBooktypeid());\r}\rPreparedStatement psmt = conn.prepareStatement(sb.toString());\rreturn psmt.executeQuery();\r}\r  返回查询结果\nview包 视图层是利用的 swing 组件设计，但这个不是本项目的重点，因为 Java 的 swing 已经很少有人用了，可以直接使用 idea 中的JFormDesigner插件进行拖拉控件，使用时一定要注意将框架的布局类型设为null Layout，大小设为Design size\n我们只需设计按钮和表格的触发事件\n例如图书添加事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  private void button1ActionPerformed(ActionEvent e) {\rString bookName = this.booknameTXT.getText();\rString author = this.bookAuthorTXT.getText();\rString price = this.bookPriceTXT.getText();\rString bookDesc = this.bookDescTXT.getText();\rif (StringUtil.isEmpty(bookName)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书名称不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(author)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书作者不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(price)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格不能为空\u0026#34;);\rreturn;\r}\rtry {\rfloat pricef = Float.parseFloat(price);\r} catch (NumberFormatException numberFormatException) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格应为数字\u0026#34;);\rreturn;\r}\rString sex = \u0026#34;\u0026#34;;\rif (this.man.isSelected()) {\rsex = \u0026#34;男\u0026#34;;\r} else {\rsex = \u0026#34;女\u0026#34;;\r}\rBooktype booktype = (Booktype) this.booktypecb.getSelectedItem();\rassert booktype != null;\rint booktypeId = booktype.getId();\rBook book = new Book(bookName, author, sex, Float.parseFloat(price), booktypeId, bookDesc);\rConnection conn = null;\rtry {\rconn = dbUtil.getConnection();\rint addNum = BookDao.add(conn, book);\rif (addNum == 1) {\rJOptionPane.showMessageDialog(null, \u0026#34;添加成功\u0026#34;);\rresetValue();\r} else {\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r}\r} catch (Exception ex) {\rex.printStackTrace();\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r} finally {\rtry {\rconn.close();\r} catch (SQLException ex) {\rex.printStackTrace();\r}\r}\r}\r  设计思想：\n 判断必需的输入框是否为空，以及类型是否一致 获取各输入框的数据 根据数据实例化对象 调用dao包中对应的方法进行操作  其他的删除，修改，查询的操作思想基本和添加的方法一样\n项目总结 项目中使用到了 Java 的 swing 技术，但是现在已经很少有人会用 Java 去写软件界面了，Java 不能像 C#那样拖拉控件设计界面，但是可以在 idea 中安装JFormDesigner插件实现 C#那样的效果了。\n MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。\n MVC 即围绕着数据库进行操作，本项目只是简单地实现了对数据库的增删改查，比较适合新手练习。\n","description":"","id":12,"section":"posts","tags":["java","mysql"],"title":"简易的图书管理系统(Java+MySQL8.0)","uri":"https://eternidad33.github.io/zh/posts/%E7%AE%80%E6%98%93%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fjava+mysql8.0/"},{"content":"小程序基本架构 基本架构 利用 app.json文件对小程序进行全局配置\n利用同名.json文件对本页面窗口表现进行配置\n全局配置\n   属性 类型 必填 描述     pages string 是 页面路径列表   window Object 否 全局的默认窗口表现   tabBar Object 否 底部 tab 栏的表现   networkTimeout object 否 网络超时时间    Pages 配置\npages 用于指定小程序由哪些页面组成，每一项都对应一个页面的路径（含文件名）信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的.json，.js，.wxml，.wxss四个文件进行处理。数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。\nWindow 配置\n   属性 类型 描述     navigationBarBackground Color HexColor 导航栏背景颜色，如#000000   navigationBarTextStyle string 导航栏标题颜色，仅支持 black/ white   navigationBarTitleText string 导航栏标题文字内容   backgroundColor HexColor 窗口的背景色    tabBar 配置\n   属性 类型 描述     color HexColor tab 上的文字的默认颜色   selectedColor HexColor tab 上选中文字的颜色   backgroundColor HexColor tab 的背景色   borderStyle string tabbar 上边框的颜色，仅支持 black / white    list 配置\n   属性 类型 必填 说明     pagePath string 是 页面路径，必须在 pages 中先定义   text string 是 tab 上按钮文字   iconPath string 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px*81px，不支持网络图片   selectedIconPath string 否 选中时的图片路径    执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13  //app.js\rApp({\r//\r onLaunch: function() {\rconsole.log(\u0026#34;【app.js】小程序初始化\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【app.js】小程序显示\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【app.js】小程序隐藏\u0026#34;);\r}\r});\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //index.js\rPage({\ronLoad: function() {\rconsole.log(\u0026#34;【index.js】onLoad页面加载\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【index.js】onShow页面显示\u0026#34;);\r},\ronReady: function() {\rconsole.log(\u0026#34;【index.js】onRead页面渲染\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【index.js】onHide页面隐藏\u0026#34;);\r},\ronUnload: function() {\rconsole.log(\u0026#34;【index.js】onUnLoad页面卸载\u0026#34;);\r}\r});\r  显示效果：\n小程序整个生命周期的执行基本顺序是：\n","description":"","id":13,"section":"posts","tags":null,"title":"小程序基本架构","uri":"https://eternidad33.github.io/zh/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"},{"content":"作为一个学习计算机相关知识的人，如果不经常写博客，就容易把刚学到的知识忘记，写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用 Markdown，这样可以很好地使我们的博客页面变得更加美观，这篇文章介绍的就是一些使用的 Markdown 使用技巧。\n推荐工具：Typora，VScode(插件Markdown-preview-enhanced)\n段落格式 字体设置 Markdown 代码\n1  \u0026lt;font size=10 face=\u0026#34;隶书\u0026#34; color=#ff0000\u0026gt;红色 10 号隶书\u0026lt;/font\u0026gt;   运行结果：\n红色 10 号隶书\n粗斜体   用*表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  用下划线表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  下划线 Markdown 代码：\n1  \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt;   显示结果为：\n带下划线文本\n删除线 Markdown 代码：\n1  ~~删除线~~   显示结果为：\n删除线\n脚注格式 Markdown 代码：\n1 2  创建脚注格式是这样的 [^lorem]。 [^lorem]: Lorem ipsum dolor.   显示结果为：\n创建脚注格式是这样的 1。\n引用格式 嵌套结构 Markdown 代码：\n1 2 3 4 5  \u0026gt; 最外层 \u0026gt; \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; 第二层嵌套   显示结果：\n 最外层\n 第一层嵌套\n 第二层嵌套\n   引用中使用列表 Markdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026gt; 引用中使用列表 \u0026gt; \u0026gt; 1. 有序列表第一项 \u0026gt; 2. 有序列表第二项 \u0026gt; 3. 有序列表第三项 \u0026gt; \u0026gt; - 无序列表第一项 \u0026gt; - 无序列表第二项 \u0026gt; - 无序列表第三项   显示结果：\n 引用中使用列表\n 有序列表第一项 有序列表第二项 有序列表第三项   无序列表第一项 无序列表第二项 无序列表第三项   列表项中的引用 Markdown 代码：\n1 2 3 4 5  1. 第一项 \u0026gt; 第一行引用 \u0026gt; 第二行引用 2. 第二项 3. 第三项   显示结果：\n 第一项  第一行引用\n第二行引用\n  第二项 第三项  代码格式 行内代码 Markdown 代码：\n1  Python 代码`print(\u0026#39;helloworld\u0026#39;)`，控制台打印 helloworld   显示结果：\nPython 代码print('helloworld')，控制台打印 helloworld\n代码块  按 Tab 键或四个空格 用```包括起来，第一个后面加上代码语言，可以高亮显示  图片样式  直接放置图片\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png)   显示结果：\n 鼠标悬浮时，显示名称\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png \u0026#34;戴帽子的犬夜叉\u0026#34;)   显示结果：\n 使用 img 标签定义图片的宽高\nMarkdown 代码： 1  \u0026lt;img src=\u0026#39;https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png\u0026#39; width=50% height=50%\u0026gt;   显示结果：\n  链接样式   直接写\nMarkdown 代码：\n1  [百度一下，你就知道](https://www.baidu.com)   显示结果：\n百度一下，你就知道\n  链接用 a 作为网址变量,然后为变量赋值\nMarkdown 代码：\n1 2  [百度一下，你就知道][a] [a]: https://www.baidu.com   显示结果：\n百度一下，你就知道\n  表格样式 Markdown 代码：\n1 2 3 4  | 左对齐 | 居中对齐 | 右对齐 | | :----- | :------: | -----: | | 1 | 2 | 3 | | 4 | 5 | 6 |   显示结果：\n| 左对齐 | 居中对齐 | 右对齐 |\n| :\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;: | \u0026mdash;\u0026ndash;: |\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n支持的 HTML 标签 Markdown 支持很多 HTML 标签,下面列举几个常用的标签\nMarkdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026lt;kbd\u0026gt;Win\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Prtsc\u0026lt;/kbd\u0026gt; 快速截图 \u0026lt;em\u0026gt;强调\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;加强强调\u0026lt;/strong\u0026gt; \u0026lt;b\u0026gt;加粗\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;倾斜\u0026lt;/i\u0026gt; 上标如，3\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; 下标，如 CO\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; 换行符\u0026lt;br\u0026gt; 分割线\u0026lt;hr\u0026gt;   显示结果：\nWin+Prtsc 快速截图\n强调\n加强强调\n加粗\n倾斜\n上标如，32\n下标，如 CO2\n换行符\n分割线\n转义字符 以下这些符号前面加上反斜杠\\来帮助插入普通的符号：\n\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号  特殊符号    符号 代码     © \u0026amp;copy;   ™ \u0026amp;trade;   \u0026amp; \u0026amp;amp;   \u0026lt; \u0026amp;lt;   \u0026gt; \u0026amp;gt;   £ \u0026amp;pound;   ¥ \u0026amp;yen;   € \u0026amp;euro;   ® \u0026amp;reg;   ± \u0026amp;plusmn;   § \u0026amp;sect;   X² X\u0026amp;sup2;   Y³ Y\u0026amp;sup3;   ¾ \u0026amp;frac34;   « \u0026amp;laquo;   » \u0026amp;raquo;   37ºC 37\u0026amp;ordm;C     Lorem ipsum dolor. \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":14,"section":"posts","tags":["markdown"],"title":"用Markdown代码写出好看的页面","uri":"https://eternidad33.github.io/zh/posts/%E7%94%A8markdown%E4%BB%A3%E7%A0%81%E5%86%99%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E9%A1%B5%E9%9D%A2/"},{"content":"开发工具 IDEA 从入门到爱不释手-课程笔记 1-1 代码生成 Generate  Alt+Insert,或者右键-Generate：生成 getter 或 setter  1-2 高效的代码编辑技能    快捷键 功能     Ctrl+Alt+L 格式化   Ctrl+D 复制光标所在行   Alt+Shift+上/下 移动所在行或所选行    1-3 Demo 项目介绍 分层结构\n Config：所有的配置 Controller：请求入口 Service：逻辑层 Mapper：持久层 Domain(Po)：表映射实体 Dto：数据传输对象  1-4 git 更多操作 顶部添加 git 提交选项\n1-5 快速查找和替换    快捷键 功能     Ctrl+F 查找   Ctrl+R 替换   Ctrl+Shift+F 全局查找   Ctrl+Shift+R 全局替换   Ctrl+Shift+N 查找文件   Ctrl+Shift+A 查找所有的菜单或操作   双击 shift 万能查找    2-1 代码模板  psvm：生成主函数 sout：System.out.println(); fori：for 循环 fore：foreach 循环 Live Templates postfix：先打变量或表达式，再打快捷键  2-2 代码重构 Refactor    快捷键 功能     Shift+F6 代码重命名   Ctrl+Alt+V 自动生成返回值   Alt+Delete 安全删除   F5 文件复制粘贴     一个方法只负责实现一个功能  2-3 快速跳转    快捷键 功能     Ctrl+左/右 跳过一个单词   Ctrl+G 快速跳转到指定行   Alt+左/右 左右切换 Tabs   Ctrl+E 查看最近浏览过的文件    3-1 更多实用技巧  Ctrl+Alt+Shift+J ：选中文件中所有和被选中的代码一样的代码  ","description":"","id":15,"section":"posts","tags":["idea"],"title":"idea使用技巧总结","uri":"https://eternidad33.github.io/zh/posts/idea%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"content":"m10c 主题配置 主题地址：GitHub 仓库地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  title = \u0026#34;Vigilr的博客\u0026#34;\r[params]\rdescription = \u0026#34;宁为玉碎，不为瓦全\u0026#34;\ravatar = \u0026#34;avatar.jpg\u0026#34;\r[[params.social]]\rname = \u0026#34;github\u0026#34;\rurl = \u0026#34;https://github.com/eternidad33\u0026#34;\r[[params.social]]\rname = \u0026#34;mail\u0026#34;\rurl = \u0026#34;mailto:3496655347@qq.com\u0026#34;\r[[params.social]]\rname = \u0026#34;link\u0026#34;\rurl = \u0026#34;https://blog.csdn.net/qq_42907802\u0026#34;\r  主题仓库要下载到站点目录/themes下\n文章目录为：站点目录/content/posts\n头像的路径：站点目录/static/avatar.jpg\n只是简单地设计了几个链接，链接的图标在主题目录/data/m10c/icons.json文件中定义\n博客启动：hugo server -t hugo-theme-m10c -D\n浏览器访问:http://localhost:1313/\n至此博客启动成功\n","description":"","id":16,"section":"posts","tags":["hugo","theme"],"title":"m10c主题配置","uri":"https://eternidad33.github.io/zh/posts/m10c%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"content":"Hugo 博客搭建 本地部署 推荐视频：手把手教你从 0 开始搭建自己的个人博客 |第二种姿势 | hugo\n  下载 Hugo，下载地址：GitHub\n  配置环境变量\n  创建自己的站点文件夹hugo new site myHugoSite\n生成的目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  PS C:\\Users\\Administrator\\Desktop\\myHogoSite\u0026gt; tree /f\r文件夹 PATH 列表\r卷序列号为 2A8A-01A5\rC:.\r│ config.toml\r│\r├─archetypes\r│ default.md\r │\r├─content\r├─data\r├─layouts\r├─static\r└─themes\r    新建文章\n在 content 目录下生成博客hugo new 我的第一篇博客.md\n在 content/posts 目录下生成博客hugo new posts/我的第二篇博客.md\n  下载m10c 主题并配置\n  部署到 GitHub  创建远程仓库,仓库名必须为用户名.github.io 生成 public 文件夹hugo -t 主题名 -b https://用户名.github.io -D 然后就是一系列 git 操作 进入 public，初始化 git 仓库 添加到暂存区 提交仓库 连接远程仓库 推送到远程仓库  不清楚的命令可以通过hugo help查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  $ hugo help\rhugo is the main command, used to build your Hugo site.\rHugo is a Fast and Flexible Static Site Generator\rbuilt with love by spf13 and friends in Go.\rComplete documentation is available at http://gohugo.io/.\rUsage:\rhugo [flags]\rhugo [command]\rAvailable Commands:\rconfig Print the site configuration\rconvert Convert your content to different formats\rdeploy Deploy your site to a Cloud provider.\renv Print Hugo version and environment info\rgen A collection of several useful generators.\rhelp Help about any command\rimport Import your site from others.\rlist Listing out various types of content\rmod Various Hugo Modules helpers.\rnew Create new content for your site\rserver A high performance webserver\rversion Print the version number of Hugo\rFlags:\r-b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/\r--templateMetrics display metrics about template executions\r--templateMetricsHints calculate some improvement hints when combined with --templateMetrics\r-t, --theme strings themes to use (located in /themes/THEMENAME/)\r--themesDir string filesystem path to themes directory\r--trace file write trace to file (not useful in general)\r-v, --verbose verbose output\r--verboseLog verbose logging\r-w, --watch watch filesystem for changes and recreate as needed\rAdditional help topics:\rhugo check Contains some verification checks\rUse \u0026#34;hugo [command] --help\u0026#34; for more information about a command.\r  ","description":"","id":17,"section":"posts","tags":["hugo"],"title":"Hugo博客搭建","uri":"https://eternidad33.github.io/zh/posts/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"推荐书籍：\n 《Java 编程的逻辑》 《疯狂 Java 讲义精粹》  Java 基础 从当前所在路径加载类SET ClASSPATH=.\nPATH：是操作系统提供的路径配置，定义所有可执行程序的路径\nCLASSPATH：是由 JRE 提供的，用于定义 Java 程序解释时类加载路径CLASSPATH=路径的命令形式来进行定义；\nJava 1.9 之后才有的Jshell\nint的取值范围为-2147483648 到 2147483647\n大写字母范围：A(65)~Z(90)\n小写字母范围：a(97)~z(122)\n数值范围：\u0026lsquo;0\u0026rsquo;(48)~'9\u0026rsquo;(57)\nthis关键字\nthis():调用无参的构造函数\nthis(name):调用参数为 name 的构造函数\nthis(\u0026hellip;):必须放在首行\nStatic 属性由类名直接调用\nstatic 方法只允许调用 static 属性或 static 方法\n非 static 方法允许调用 static 属性或 static 方法\nstatic 的定义的方法或属性都不是代码编写之初所需要考虑的内容，只有在回避实例化对象描述公共属性的情况下才会考虑 static 定义的属性或者是方法\n静态代码块最先执行，而且只会执行一次，用于对静态属性的初始化，构造块会优于构造方法先执行\n数组 int数组初始化默认为 0\n必须实例化数组才能使用数组下标\nforeach循环可以避免使用下标，\nforeach遍历二维数组\n返回数组的方法\n将数组封装成一个组件\n数组快速排序\n数组逆序\n数组相关的类库\n数组排序可以这样写java.util.Arrays.sort(data);\n系统自带的数组拷贝System.arraycopy(dataA,5,dataB,5,3);是将数组dataA中从索引为 5，长度为 3 的一段数组复制到dataB中索引位置为 5 的地方，并替换掉相应长度\n可变参数\n在方法参数列表中...表示可变参数\n可变参数的作用在于，在以后进行一些程序设计或者开发者调用的时候，利用此种形式可以避免数组的传递操作\n对象数组定义格式如下：\n 动态初始化：类 对象数组名称[]=new 类[长度]，每一个元素的内容都是 null 静态初始化：类 对象数组名称[]=new 类[]{实例化对象，实例化对象，实例化对象\u0026hellip;}  String java 源代码目录:C:\\Program Files (x86)\\Java\\jdk-9\\lib\\src.zip\nJDK 1.8 及以前的 String 支持类\nJDK 1.9 的 String 支持类\nJDK 1.8 及以前 String 类保存的是字符数组\nJDK 1.9 及以后 String 类保存的是字节数组\nString 对象的比较\n直接为字符串赋值会是字符串变量指向字符串池中的内存地址\nnew String()会开辟新的内存\n将所有小写字母转换成大写\n先将字符串转换成字符数组，然后每个字符的编码-32\n判断是否全为数字\n先将字符串转换成字符数组，if (result[i] \u0026lt; '0' || result[i] \u0026gt; '9')\n然后挨个判断每个字符\n字符串的比较\nstr.equals(str1)区分大小写比较\nstr.equalsIgnoreCase(str1)不区分大小写比较\nstr.compareTo(str1)字符串的大小的比较\nstr.compareToIgnoreCase(str1)忽略大小写的字符串大小比较\n字符串的查找\nstr.contains(\u0026quot;hello\u0026quot;)判断字符串中是否含有 hello\nstr.indexOf(\u0026quot;Java\u0026quot;)查询 Java 是否存在于 str 中，存在返回首字母索引位置，不存在返回-1\nstr.lastIndexOf(\u0026quot;Java\u0026quot;)从后向前查询\nstr2.endsWith(\u0026quot;com\u0026quot;)判断是否以 com 结尾\nstr2.startsWith(\u0026quot;www\u0026quot;)判断是否以 www 开头\n字符串的替换\nstr.replaceAll(\u0026quot;Java\u0026quot;, \u0026quot;Python\u0026quot;)将全部的 Java 替换成 Python\nstr.replaceFirst(\u0026quot;Java\u0026quot;, \u0026quot;Python\u0026quot;)将第一个 Java 替换成 Python\n字符串的拆分\nstr.split(\u0026quot; \u0026quot;)以空格全部拆分，返回字符串数组\nstr.split(\u0026quot; \u0026quot;,2)以空格拆分成 2 个，返回字符串数组\nstr1.split(\u0026quot;\\\\.\u0026quot;)拆不开的情况要用\u0026rdquo;\\\u0026ldquo;进行转义\n字符串的截取\nstr.substring(startIndex,endIndex)截取str从startIndex到endIndex的字符串片段\n字符串的格式化\nformat 是一个静态方法,直接通过String 类调用String.format(\u0026quot;姓名：%s，年龄：%d，分数：%5.2f\u0026quot;,name,age,score)\n其他字符串相关的方法\nstr.concat(str2)字符串的连接\nstr.isEmpty()判断字符串内容是否为空\nstr.trim()去掉字符串中所有空格\nstr.toUpperCase()全部转换成大写\n(str.toLowerCase()全部转换成小写\n面向对象 继承 public class object.Student extends object.PersonStudent 类继承 Person 所有共有的属性和方法\n子类被实例化时先调用父类的构造方法\nsuper(...)必须放在首行，this(...)也必须放在首行，所以两者不可同时出现\n多层继承\n理论上层数最多不能超过三层\n 父类的私有方法不存在覆写 子类调用有父类覆写的方法要加 super     Overloading Override     重载 覆写   方法名称相同，参数的类型及个数不同 方法名称，参数类型及个数，返回值相同   没有权限限制 被覆写方法不能拥有更严格的控制权限   发生在一个类中 发生在继承关系类中     在程序类中使用 this 表示先从本类查找所需要的的属性或方法，如果本类中不存在则查找父类定义，如果使用 super 则不查找子类，直接查找父类\n fanal 代表不能被覆写的方法，常量\nAnnotation 注解\n@Override准确覆写\n@Deprecated 代表过时的类或方法\n@SuppressWarnings 压制警告\n多态 向上转型base f = new son()可以调用父类的方法和子类中重写父类的方法\n向下转型son1 s=(son)f不安全\ninstanceof\ninstanceof为了保证向下转型的正确性，用于在转型之前进行判断，判断某个实例是否是某个类的对象\nObject 类 Object 类是所有类型的父类，所以 Object 类可以接收所有子类的对象\ntoString()是 Object 自带的方法，所有继承类都可以使用\n 对象比较 equals() 判断对象是否为 null 判断是不是同一地址 判断 obj 是否转换为 person 判断内容是否相同  抽象类 抽象方法所在的类必须为抽象类，抽象类必须用abstract关键字来定义\n抽象类就是在普通类上追加了抽象方法\n抽象类是无法被实例化的\n 抽象类必须提供子类 抽象类的子类（非抽象类）一定要覆写抽象类中的全部抽象方法 抽象类的对象实例化可以通过子类向上转型的方式完成   抽象类自己无法直接实例化\n final不允许有子类，abstract必须有子类\n 抽象类中可以使用普通方法调用抽象方法\n 包装类 Int temp = new Int(10);装箱，将基本数据类型保存在包装类中\nint x = temp.intValue();拆箱，从包装类中获取基本数据类型\n 对象型的包装类，Boolen,Character 数值型的包装类,Byte,Short,Integer,Long,Float,Double  基本的装箱与拆箱操作\njdk1.5 之后可以实现自动装箱与拆箱操作，包装类可以直接参与数学运算\n接口 接口的组成以抽象方法和全局常量为主，使用关键字interface定义，接口的名称通常首字母加上I\n 接口需要被子类实现，关键字implements，一个子类可以实现多个接口 子类（非抽象类）必须覆写接口中的全部抽象方法 接口对象可以通过子类对象的向上转型实例化  接口的主要目的是一个子类可以实现多个接口\n接口不允许继承父类\n Object 类对象可以接收所有的数据类型，包括基本数据类型，类对象，接口对象，数组…\n方法不写访问权限也是public，不是default\n 接口可以通过extends集成多个父接口\n接口的使用：\n 进行标准设置 表示一种操作的能力 暴露远程方法视图  JDK1.8 之前，在进行设计时，一般子类不直接继承接口，中间加一个过渡抽象类\n接口的方法加上public default代表普通方法\n设计模式 代理设计模式\n一个接口提供两个子类，其中一个是真实业务操作类，另一个是代理业务操作类\n接口与抽象类的比较\n   接口 抽象类     interface 接口名称{} abstract class 抽象类名称{}   抽象方法，全局常量，普通方法，静态方法 构造，普通方法，静态方法，全局变量，成员   只有 public 权限 可以使用各类权限   子类通过implements关键字可以继承多个接口 子类通过extends关键字继承一个抽象类   接口不允许结成抽象类，可以继承多个父接口 抽象类可以实现若干个接口    使用时的共同点\n 抽象类或接口必须定义子类 子类必须覆写抽象类或接口的全部抽象方法 通过子类的向上转型实现抽象类或接口的对象实例化  单例设计\n懒汉式\n在第一次使用时进行实例化处理\n饿汉式\n在系统加载类时，实例化对象\n多例设计\n单例设计是指只保留一个实例化对象，多例设计是指保留多个实例化对象\n单例设计和多例设计的本质是相同的，一定都会在内部提供有static方法以返回实例化对象。都要进行构造方法私有化\n泛型 基本数据类型 → 包装类型 →Object类\n向上转型成Object类，容易出现ClassCastException异常\n  泛型之中只允许设置引用类型，如果要操作基本类型必须使用包装类 泛型对象实例化对象可以简化为Point\u0026lt;Integer\u0026gt; p1=new Point\u0026lt;\u0026gt;();   通配符\u0026lt;?\u0026gt;可以使泛型对象在方法中不被改变\n\u0026lt;T extends 类\u0026gt;:设置泛型的上限\n\u0026lt;T super 类\u0026gt;:设置泛型的下限\n泛型接口\n子类实现泛型接口两种方式：\n  在子类之中继续设置泛型定义\n  子类实现父接口是直接定义泛型类型\n  泛型方法\n泛型方法不一定出现在泛型类之中\n工厂模式中使用泛型方法\n包 同一个目录下不能有同名的程序文件，要创建不同的目录，不同的的目录就是不同的包\njavac -d . hello.java\n-d:表示要生成目录，目录为package定义的结构\n.:表示从当前目录开始生成\n类的名称：包.类名称\nimport util.Message;导入其他包的类\n当导入的几个包中出现重名的类时，定义类要用完整的类名称Message msg=new util.Message();。\n静态导入\nimport static util.Math.*;静态导入后可以直接使用util.Math中的方法\nJar\n想用javac编译，然后用jar打包\njar -cvf \u0026quot;名称.jar\u0026quot; 文件夹\n-c创建一个新的jar文件\n-v得到一个详细输出\n-f设置生成的Jar文件名称\n系统常见包\njava.lang包括 String，Number，Object 等\njava.lang.reflect反射机制处理包\njava.util工具类的定义，包括数据结构的定义\njava.io进行输入与输出流操作的包\njava.net网络程序开发的程序包\njava.sql进行数据库编程的开发包\njava.awt和java.swingJava 的图形界面开发包，awt 是重量级的组件，swing 是轻量级的组件\n访问控制权限\n面向对象的三个主要特点：封装，继承，多态\n   访问范围 private default protected public     同一包中的同一类 √ √ √ √   同一包中的不同类  √ √ √   不同包的子类   √ √   不同包的所有类    √    UML UML 是统一的建模语言，本质是利用图形化的形式来实现程序类关系的描述\n类图\n类一般用三层结构来显示\n   类名称     属性   方法    抽象类一般用斜体表示，也可以加上abstract\n属性的格式为访问权限 属性名称：属性类型\n访问权限的表示符为 public(+),private(-),protected(#)\n方法的格式为访问权限 方法名称():返回值结构\n子类实现接口用\u0026quot;三角和虚线\u0026rdquo;,类的继承用\u0026quot;三角和实线\u0026rdquo;,由子类指向父类\n时序图\n时序图用于描述代码的执行流程\n用例图\n用例图用于描述程序的执行分配\n枚举 枚举主要作用于定义有限个数对象的一种结构（多例设计），通过enum定义枚举类\n遍历枚举\nc.ordinal():c 在枚举类中的序号\nc.name():c 的值\n enum:是从 JDK1.5 之后提供的一个关键字，用来定义枚举类 Enum：是一个抽象类，所有使用enum关键字定义的类，默认继承此类  异常 处理异常的三种组合：try...catch，try...catch...finally，try...finally\n通过e.printStackTrace();获取完整的异常信息\n异常处理流程\n 产生异常，自动产生异常的实例化对象 如果不处理异常，JVM 默认打印异常信息，然后退出程序 如果存在异常处理，异常实例化对象将会被try语句捕获 catch匹配异常 执行finally  处理异常最大的类型是Throwable，有两个子类\n Error:此时程序还未执行出现的错误，开发者无法处理 Exception:程序中出现的异常  在多个异常处理的时候要将捕获范围大的异常放在捕获范围小的异常后面\n通过throws抛出异常\nthrow手动抛出异常\nthrow和throws的区别\n throw是在代码块中使用的，主要是手工对异常对象的抛出 throws是在方法定义上使用的，表示将此方法中可能产生的异常明确告诉给调用处，由调用处进行处理  RuntimeException是Exception的子类\n常见的RuntimeException： NullPointerException，ClassCastException，IndexOutOfBoundsException\n内部类 内部类的优点是可以轻松地访问外部类的私有属性，缺陷是破坏了类的结构\n内部类和外部类之间的操作不需要setter和getter，内部类实例化对象的格式外部类.内部类 内部类对象=new 外部类().new 内部类;\n如果Inner类加上private属性，则Inner无法在外部进行使用\nstatic的类和方法只能访问外部类的static的属性或方法.\nstatic定义的内部类并不常用，static定义内部接口更常用\n在方法中定义内部类\n方法中的内部类既能访问方法中的参数，又能访问外部类的私有成员属性。对于方法中参数的访问是从 JDK1.8 开始支持的。\n匿名内部类的使用\n 往往使用静态方法做一个内部的匿名内部类\n 匿名内部类只是一个没有名字的只能够使用一次的，并且结构固定的一个子类\n函数式编程 从 JDK1.8 开始提供有Lambda表达式的支持\nLambda表达式使用时有一个重要的实现要求就是 SAM(Single Abstract Method)只有一个抽象方法,该接口被称为函数式接口\nLambda 表达式的三种格式：\n 没有参数：()-\u0026gt;{}; 有参数：(参数,参数)-\u0026gt;{}; 只有一条返回语句(参数,参数)-\u0026gt;语句;  对方法的引用\n  引用静态方法：类名称::static 方法名称;\nIFunction\u0026lt;String, Integer\u0026gt; fun = String::valueOf;\n  引用某个实例对象的方法：实例化对象::普通方法;\nIFunction fun=\u0026quot;hellojava\u0026quot;::toUpperCase;\n  引用特定类型的方法：特定类::普通方法;\nIFunction\u0026lt;String\u0026gt; fun=String::compareTo;\n  引用构造方法：类名称::new\nIFunction\u0026lt;Person\u0026gt; fun=Person::new;\n  在java.util.funtion包中可以直接使用函数式接口\n  功能性函数式接口\n1 2  Function\u0026lt;String,Boolean\u0026gt; fun=\u0026#34;hellojava\u0026#34;::startsWith;\rSystem.out.println(fun.apply(\u0026#34;hello\u0026#34;));\r    消费型函数式接口:只能进行数据的处理，没有任何的返回\n1 2  Consumer\u0026lt;String\u0026gt; fun=System.out::println;\rfun.accept(\u0026#34;HelloJava\u0026#34;);\r    供给型函数式接口\n1 2  Supplier\u0026lt;String\u0026gt; fun=\u0026#34;hellojava\u0026#34;::toUpperCase;\rSystem.out.println(fun.get());\r    断言型函数式接口\n1 2  Predicate\u0026lt;String\u0026gt; fun=\u0026#34;hello\u0026#34;::equals;\rSystem.out.println(fun.test(\u0026#34;hello\u0026#34;));\r    链表 由于数组的长度是固定的，所以要引入链表\n链表节点的增加\n 判断增加的节点是否为空 判断根节点是否为空 添加节点  Link 类只负责数据的操作与根节点的处理而所有后续节点的处理全部都是有 Node 类负责。\n获取链表元素的个数\n  在ILink接口中增加size()方法\n  在LinkImpl中重写size()方法\n  在LinkImpl中增加私有属性count,然后在add(E e)加上this.count++;语句\n  判断链表是否为空\n既可以判断根节点是否为空，也可以判断长度是否为 0\n返回链表数据\n  在ILink接口中追加public Object[] toArray();方法\n  在LinkImpl中加上两个属性\n  在Node中递归获取数据\n  在LinkImpl中重写public Object[] toArray();方法\n  链表数据的返回是以数组的形式返回\n根据索引获取数据\n  ILink加上public E get(int index);\n  在Node中定义public E getNode(int index)\n  在LinkImpl中重写public E get(int index)\n  修改指定索引的数据\n 在ILink加上public void set(int index,E value); 在Node中定义public void setNode(int index,E value) 在LinkImpl中重写public void set(int index, E value)  判断指定数据是否存在\n 在ILink加上public boolean contains(E data) 在Node中定义public boolean containsNode(E data) 在LinkImpl中重写public boolean contains(E data)  数据删除\n 在ILink中加上public void remove(E data) 在LinkImpl中判断要删除的元素是否为根节点 如果不是根节点，在Node中定义删除节点 在LinkImpl中完善public void remove(E data)方法  数据清除\n 在ILink中追加public void clean();方法 在LinkImpl中重写public void clean()  AWT   AWT 界面组件：包括窗口、对话框、基本组件、菜单组件。 AWT 布局管理器：包括流式布局 FlowLayout、区域布局 BorderLayout、网格布局 GridLayout、卡片布局 CardLayout。 AWT 事件处理：事件授权模型、事件类型，监听器和适配器的使用。   AWT 的组件包括两大类：Component 和 MenuComponent，即组件与菜单栏\n类 java.awt.Component 是许多组件类的父类，Component 类中封装了组件通用的方法和属性，如图形的组件对象、大小、显示位置、前景色和背景色、边界、可见性等。\n一般我们要生成一个窗口，通常是用 Window 的子类 Frame 来进行实例化，而不是直接用到 Window 类\nPanel是一个容器，放在 Frame 组件内，可以用于包装一组组件。\n idea 中中文乱码设置VM option: -Dfile.encoding=GB18030\n 对话框Dialog\n创建文本对话框FileDialog\n基本组件\n 文本Label 按钮Button 复选框Checkbox 复选框组CheckboxGroup 下拉列表Choice 文本框TextField 文本区域TextArea 列表List 画布CAnvas  菜单组件\n 菜单栏MenuBar 菜单Menu 菜单选项MenuItem  AWT 布局管理器\n Frame 是一个顶级窗口。Frame 的默认布局管理器为BorderLayout。\nPanel 无法单独显示，必须添加到某个容器中。Panel 的默认布局管理器为 FlowLayout。\n当把 Panel 作为一个组件添加到某个容器中后，该 Panel 仍然可以有自己的布局管理器。因此，可以利用 Panel 使得BorderLayout中某个区域显示多个组件，达到设计复杂用户界面的目的。\n如果采用无布局管理器setLayout(null)，则必须使用setLocation()、setSize()、setBounds()等方法手工设置组件的大小和位置，此方法会导致平台相关，不鼓励使用。\n 流式布局 FlowLayout\nFlowLayout 是 Panel、Applet 的默认布局管理器。其组件的放置规律是从上到下、从左到右进行放置，如果容器足够宽，第一个组件先添加到容器中第一行的最左边，后续的组件依次添加到上一个组件的右边，如果当前行已放置不下该组件，则放置到下一行的最左边。\nFlowLayout(FlowLayout.RIGHT,20,40);：第一个参数表示组件的对齐方式，指组件在这一行中的位置是居中对齐、居右对齐还是居左对齐，第二个参数是组件之间的横向间隔，第三个参数是组件之间的纵向间隔，单位是像素。\n区域布局 BorderLayout\nBorderLayout 是 Window、Frame 和 Dialog 的默认布局管理器。BorderLayout 布局管理器把容器分成 5 个区域：North、South、East、West 和 Center，每个区域只能放置一个组件。\n 不一定所有的区域都有组件，如果四周的区域（West、East、North、South 区域）没有组件，则由 Center 区域去补充，但是如果 Center 区域没有组件，则保持空白\n 网格布局 GridLayout\nGridLayout 使容器中各个组件呈网格状布局，平均占据容器的空间，创建该布局时需要指定网格的行数和列数，然后依次添加各个组件时，会按照先行后列的顺序依次添加。\n卡片布局 CardLayout\nCardLayout 卡片布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件，当然每层都可以利用 Panel 来实现复杂的用户界面。\nAWT 事件处理\n使用授权处理模型进行事件处理的一般方法归纳如下。\n  对于某种类型的事件 XXXEvent，要想接收并处理这类事件，必须定义相应的事件监听器类，该类需要实现与该事件相对应的接口 XXXListener。\n  事件源实例化以后，必须进行授权，注册该类事件的监听器，使用 addXXXListener(XXXListener )方法来注册监听器。\n  AWT 事件共有 10 类，可以归为两大类：低级事件和高级事件。\n低级事件是指基于组件和容器的事件，当一个组件上发生事件，如：鼠标的进入、单击、拖放等，或组件的窗口开关等，触发了组件事件。\n高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类，如在 TextField 中按 Enter 键会触发 ActionEvent 事件，滑动滚动条会触发 AdjustmentEvent 事件，或是选中项目列表的某一条就会触发 ItemEvent 事件。\n事件监听器\n每类事件都有对应的事件监听器，监听器是接口，根据动作来定义方法\n使用事件监听器：实现监听器接口、使用内部类和匿名类。\n使用事件适配器。\n多媒体处理\n 图像处理——java.awt.image 二维图像绘制——Java2D。 音频录制与播放——JavaSound。 视频拍照与播放——JMF。  正则表达式 基本语法\n 八进制表示的字符，以\\0开头，后跟 1 ～ 3 位数字 十六进制表示的字符，以\\x开头，后跟两位字符 Unicode 编号表示的字符，以\\u开头，后跟 4 位字符 点号字符.是一个元字符，默认模式下，它匹配除了换行符以外的任意字符 以(? s)开头，s 表示 single line，即单行匹配模式 为方便表示连续的多个字符，字符组中可以使用连字符\u0026rsquo;-\u0026rsquo; 字符组支持排除的概念，在[后紧跟一个字符^,只有在字符组的开头才是元字符，如果不在开头，就是普通字符，匹配它自身 \\d: d 表示 digit，匹配一个数字字符 \\w: w 表示 word，匹配一个单词字符 \\s: s 表示 space，匹配一个空白字符 \\D：匹配一个非数字字符 \\W：匹配一个非单词字符 \\S：匹配一个非空白字符  量词指的是指定出现次数的元字符：\n +：表示前面字符的一次或多次出现 \\*：表示前面字符的零次或多次出现 ? ：表示前面字符可能出现，也可能不出现 更为通用的表示出现次数的语法是{m, n}，出现次数从 m 到 n，包括 m 和 n，如果 n 没有限制，可以省略，如果 m 和 n 一样，可以写为{m} 使用懒惰量词，在量词的后面加一个符号? 表达式可以用括号()括起来，表示一个分组  特殊边界匹配\n 默认情况下，^匹配整个字符串的开始 默认情况下，$匹配整个字符串的结束 \\A与^类似，但不管什么模式，它匹配的总是整个字符串的开始边界。 \\Z和\\z与$类似，但不管什么模式，它们匹配的总是整个字符串的结束边界。 \\b匹配的是单词边界  环视边界匹配\n环视的字面意思就是左右看看，需要左右符合一些条件，本质上，它也是匹配边界，对边界有一些要求，这个要求是针对左边或右边的字符串的。\n 肯定顺序环视，语法是(? =...)，要求右边的字符串匹配指定的表达式。 否定顺序环视，语法是(? ! ...)，要求右边的字符串不能匹配指定的表达式。 肯定逆序环视，语法是(? \u0026lt;=...)，要求左边的字符串匹配指定的表达式。 否定逆序环视，语法是(? \u0026lt;! ...)，要求左边的字符串不能匹配指定的表达式。  这些环视结构也被称为断言，断言的对象是边界，边界不占用字符，没有宽度，所以也被称为零宽度断言。\nJava API\n正则表达式相关的类位于包 java.util.regex 下，有两个主要的类，一个是 Pattern，另一个是 Matcher\n  表示正则表达式\n在 Java 中，没有什么特殊的语法能直接表示正则表达式，需要用字符串表示，而在字符串中，''也是一个元字符，为了在字符串中表示正则表达式的\u0026rsquo;'，就需要使用两个\u0026rsquo;'，即\u0026rsquo;\\'，而要匹配\u0026rsquo;'本身，就需要 4 个\u0026rsquo;'，即\u0026rsquo;\\\\\u0026rsquo;\n三种匹配模式：单行模式（点号模式）、多行模式和大小写无关模式，它们对应的常量分别为：Pattern.DOTALL、Pattern.MULTILINE 和 Pattern.CASE_INSENSI-TIVE，多个模式可以一起使用，通过'|'连起来即可\n  切分\n  验证\n  查找\n  替换\n  List 集合 集合操作最常用的两种方法：add()，iterator()\npublic interface List\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt;\nCollection 的继承关系，如图：\nList 的三个常用子类：\n ArrayList LinkedList Vector  ArrayList\n继承关系\n1 2 3  public class ArrayList\u0026lt;E\u0026gt;\rextends AbstractList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, Serializable\r  LinkedList\n继承关系\n1 2 3  public class LinkedList\u0026lt;E\u0026gt;\rextends AbstractSequentialList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, Serializable\r  Vector\nVector 是一个古老的集合（从 JDK 1.0 就有了）\n继承关系\n1 2 3  public class Vector\u0026lt;E\u0026gt;\rextends AbstractList\u0026lt;E\u0026gt;\rimplements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, Serializable\r  Set 集合 Set 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add 方法返回 false，且新元素不会被加入。\nSet 判断两个对象相同不是使用==运算符，而是根据 equals 方法\nHashSet\nHashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。\nHashSet 不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或者两个以上线程同时修改了 HashSet 集合时，则必须通过代码来保证其同步。\nLinkedHashSet\nHashSet 还有一个子类 LinkedHashSet，LinkedHashSet 集合也是根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。\nTreeSet\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。\nTreeSet 并不是根据元素的插入顺序进行排序的，而是根据元素实际值的大小来进行排序的。\nEnumSet\nEnumSet 是一个专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式地指定。EnumSet 的集合元素也是有序的，EnumSet 以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。\nMap 集合 Map 用于保存具有映射关系的数据，因此 Map 集合里保存着两组值，一组值用于保存 Map 里的 key，另外一组值用于保存 Map 里的 value，key 和 value 都可以是任何引用类型的数据。\nMap 的继承关系，如图：\nHashMap和Hashtable都是 Map 接口的典型实现类，它们之间的关系完全类似于ArrayList和Vector的关系\n Hashtable 是一个线程安全的 Map 实现，但 HashMap 是线程不安全的实现\nHashtable 不允许使用 null 作为 key 和 value\n HashMap、Hashtable也不能保证其中 key-value 对的顺序。\nProperties类是Hashtable类的子类，正如它的名字所暗示的，该对象在处理属性文件时特别方便（Windows 操作平台上的 ini 文件就是一种属性文件）。\nTreeMap就是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap存储 key-value 对（节点）时，需要根据 key 对节点进行排序。\n ArrayList 和 Vector 的显著区别：ArrayList 是线程不安全的，当多个线程访问同一个 ArrayList 集合时，如果有超过一个线程修改了 ArrayList 集合，则程序必须手动保证该集合的同步性；但 Vector 集合则是线程安全的，无须程序保证该集合的同步性。\n Java 多线程编程 Java 是多线程的编程语言，有利于并发访问处理。\n继承Thread 类实现多线程\n多线程的执行的方法在run()中定义，\nstart()方法是并发执行\n每一个线程类对象只允许启动一次，如果重复启动，就会抛出异常\nRunnable接口的使用\n1 2  Thread th=new Thread(new MyThread(\u0026#34;线程1启动\u0026#34;));\rth.start();\r  Thread 与 Runnable 关系 Thread 用于实现 Runnable，如图所示：\n多线程的设计之中，使用了代理设计模式的结构，用户设计的线程主体负责项目核心功能，其他辅助功能由 Thread 类实现\n多线程开发的本质实质上是在于多个线程可以进行统一资源的抢占\nCallable 实现多线程\nCallable的定义\n1 2 3 4  @FunctionalInterface\rpublic interface Callable\u0026lt;V\u0026gt; {\rV call() throws Exception;\r}\r  如图 Callable 的继承关系：\n   Runnable Callable     JDK1.0 JDK1.5   只有 void run()，无返回值 V call()，有返回值    线程常用操作方法 构造方法public Thread(Runnable target, String name)\n设置名字public final synchronized void setName(String name)\n取得名字public final String getName()\n使用 Java 命令就会启动一个 JVM 的进程，一台电脑可以同时启动若干个 JVM 进程\n主线程可以创建若干个子线程，主线程负责处理整体流程，而子线程负责处理耗时操作\n线程休眠\n两种休眠处理方式\n一个参数，毫秒：public static native void sleep(long millis) throws InterruptedException;\n两个参数，毫秒纳秒public static void sleep(long millis, int nanos)throws InterruptedException\n休眠的主要特点是自动实现线程的唤醒，以继续进行后续的处理，多个线程休眠是有顺序的\n线程中断\n所有的线程都能被中断，线程中断必须进行异常处理\n线程的强制执行\n正常情况下主线程和子线程交替执行\n强制执行public final void join() throws InterruptedException\n线程礼让\n礼让方法：public static native void yield();\n线程优先级\n设置优先级public final void setPriority(int newPriority)\n获取优先级public final int getPriority()\n三个优先级常量\n1 2 3  public final static int MIN_PRIORITY = 1;\rpublic final static int NORM_PRIORITY = 5;\rpublic final static int MAX_PRIORITY = 10;\r  优先级高的最有可能先执行，并不是绝对先执行\n线程的同步与死锁 同步问题的引出\n系统休眠或网络延迟会产生数据不同步问题\n线程同步\n解决同步问题的关键是锁\n关键字synchronized\n同步实际上会使系统的性能降低\n解决同步问题的两种方法：同步代码块和同步方法\n线程死锁\n线程死锁就是若干个线程互相等待的状态\n死锁是开发中不确定的状态\n若干个线程访问同一资源时一定要进行同步处理，而过多的同步则会造成死锁\n基础类库 StringBuffer 类\n构造方法：public StringBuffer()\n构造方法：public StringBuffer(String str)\n基本操作方法：\n1 2 3 4 5 6 7  public static void main(String[] args) {\rStringBuffer sb=new StringBuffer(\u0026#34;baidu\u0026#34;);\rsb.append(\u0026#34;.com\u0026#34;).insert(0,\u0026#34;www.\u0026#34;);\rSystem.out.println(sb);\rsb.delete(0,4);\rSystem.out.println(sb);\r}\r  字符串反转：sb.reverse()\nStringBuffer属于线程安全的全部使用synchronized，StringBuilder是非线程安全的。\nCharSequence 接口\nCharSequence 是描述字符串结构的接口\n   String StringBuffer StringBuilder     public final class Stringextends Objectimplements Serializable, Comparable, CharSequence public final class StringBufferextends Objectimplements Serializable, CharSequence public final class StringBuilderextends Objectimplements Serializable, CharSequence    Runtime 类\n在每一个 JVM 只允许提供有一个 Runtime 类的对象，所以这个类的构造方法被默认私有化了\nSystem 类\n  数组拷贝：public static native void arraycopy(Object src,int srcPos,Object dest,int destPos,int length);\n  获取当前日期时间数值：public static native long currentTimeMillis();\n  进行垃圾回收：public static void gc()\n  Math 类\nMath 类的全部方法:\n1 2 3 4 5 6 7 8  /**\r* 指定小数位数四舍五入\r* @param: [num, scale]\r* @return: double\r*/\rpublic static double round(double num,int scale){\rreturn Math.round(num*Math.pow(10,scale))/Math.pow(10,scale);\r}\r  Random 类\n生成不包含边界的随机正整数：public int nextInt(int bound)\nUUID 类\nUUID 是一种生成无重复字符串的一种程序类，这种程序类的主要功能是根据时间戳实现一个自动的无重复字符串定义。\n随机获取 UUID:public static UUID randomUUID()\n根据字符串获取 UUID 内容:public static UUID fromString(String name)\nOption 类\nOption 类的主要功能是进行 null 的相关处理\n返回空数据：public static\u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; empty()\n获取数据：public T get()\n保存数据，但是不许出现 null：public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; of(T value)\n保存数据，允许出现 null：public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value)\n空的时候返回其他数据:public T orElse(T other)\nThreadLocal 类\n构造方法：public ThreadLocal()\n设置数据：public void set(T value)\n取出数据：public T get()\n删除数据：public void remove()\nBase64 类\nBase64 可以实现加密与解密的处理，包含的内部类和方法如下图：\n比较器 Arrays 类\n数组的排序：public static void sort(int[] a)\n数组的输出：public static String toString(int[] a)\nComparable 比较器\n接口定义：public interface Comparable\u0026lt;T\u0026gt;\n实现比较的方法：int compareTo(T o)\nComparator 比较器\nComparator 属于一种挽救的比较器支持，其主要目的是解决一些没有使用 Comparable 排序的类的对象的数组排序操作\n红黑树原理  红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。\n红黑树是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。\n红黑树是一种特化的 AVL 树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。\n它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在 O(log n)时间内做查找，插入和删除，这里的 n 是树中元素的数目。\n 红黑树的特点：\n 每个节点不是黑色就是红色 根节点必须是黑色 叶子节点是黑色  Java 实现的红黑树使用 null 代表空节点，因此遍历红黑树时将看不到黑丝的叶子节点，反而看到每个叶子节点都是红色的   红色节点的子节点必须是黑色的 一个节点到该节点的所有子孙节点的所有路径上包含相同数目的黑色节点  利用红色节点与黑色节点实现均衡的控制\n文件操作 File 类\n构造方法：public File(String pathname)\n构造方法：public File(String parent, String child)\n创建文件：public boolean createNewFile() throws IOException\n判断文件是否存在：public boolean exists()\n删除文件：public boolean delete()\nWindows 的路径分隔符是\\,Linux 的路径分隔符是/，\nFile 类中的路径分隔符常量separator\n获取父路径：public File getParentFile()\n创建单级目录：public boolean mkdir()\n创建多级目录：public boolean mkdirs()\n是否可读：public boolean canRead()\n是否可写：public boolean canWrite()\n获取文件长度：public long length()\n最后得到修改时间：public long lastModified()\n判断是否为目录：public boolean isFile()\n判断是否为文件：public boolean isDirectory()\n列出目录：public File[] listFiles()\n字节流与字符流 File 类只能够操作文件本身，而不能操作文件的内容\n字节处理流：OutputStream（输出字节流）,InputStream（输入字节流）\n字符处理流：Writer（输出字符流）,Reader（输入字符流）\n流的操作属于资源操作，资源操作必须进行关闭处理\nOutputStream字节输出流\n定义：public abstract class OutputStream implements Closeable, Flushable\nOutputStream的继承关系如图:\nOutputStream是一个公共的输出操作标准\nFileOutputStream是OutputStream的实现子类\n【覆盖】构造方法：public FileOutputStream(File file) throws FileNotFoundException\n【追加】构造方法：public FileOutputStream(File file, boolean append) throws FileNotFoundException\nInputStream字节输入流\nInputStream的继承关系与方法\n使用 read()方法读取的时候只能够以字节数组为主进行接收\nWriter字符输出流\nWriter 的继承关系及方法：\nWriter是字符流，字符处理的优势在于中文数据。\nReader字符输入流\nReader 的构造：\n字节流与字符流的区别\nOutputStream不关闭可以正常保存\nWriter不关闭不能正常保存\n因为Writer使用了缓冲区\n涉及中文信息的都采用字符流\n转换流\n   OutputStreamWriter InputStreamReader     public class OutputStreamWriter extends Writer public class InputStreamReader extends Reader   public OutputStreamWriter(OutputStream out) public InputStreamReader(InputStream in)    转换流可以使字节流转换为字符流\nFileWriter继承结构\nFileReader继承结构\nIO 操作深入 字符编码\n GBK/GB2312：国际编码，可以描述中文信息，GB2312 只描述简体中文 ISO8859-1：国际通用编码，可以用于描述所有字母信息 UNICODE 编码：采用十六进制方式存储，可用于描述所有的文字信息 UTF 编码：象形文字采用十六进制编码，字母采用 ISO8859-1 编码，有利于数据传输，节省带宽 项目中一般都统一使用 UTF-8 编码  列出系统信息System.getProperties().list(System.out);\n内存操作流\nJava 有两类内存操作流：\n  字节内存操作流\n  字符内存操作流\n  管道流\n 字节管道流 字符管道流  输入与输出支持 打印流\n   PrintStream PrintWriter     public class PrintStream extends FilterOutputStream implements Appendable, Closeable public class PrintWriter extends Writer   public PrintStream(OutputStream out) public PrintWriter (Writer out),public PrintWriter(OutputStream out)    对文件进行操作时通常使用打印流\nSystem 类对 IO 的支持\n 标准输出（显示器）：public final static PrintStream out = null; 错误输出：public final static PrintStream err = null; 标准输入（键盘）：public final static InputStream in = null;  1 2  System.out.println(\u0026#34;我是System.out\u0026#34;);\rSystem.err.println(\u0026#34;我是System.err\u0026#34;);\r  System.out输出黑色字体\nSystem.err输出红色字体\nSystem.in并不常用\nBufferedReader缓冲输入流\n读取一行数据public String readLine() throws IOException\nScanner 扫描流\n构造：public Scanner(InputStream source)\n判断是否有数据：public boolean hasNext()\n取出数据：public String next()\n设置分隔符：public Scanner useDelimiter(Pattern pattern)\n对象序列化  序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n Person 类产生的每一个对象都可以实现二进制的数据传输，属于可以被序列化的程序类\n序列化与反序列化\n   序列化 反序列化     ObjectOutputStream ObjectInputStream   public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants   public ObjectOutputStream(OutputStream out) throws IOException public ObjectInputStream(InputStream in) throws IOException   public final void writeObject(Object obj) throws IOException public final Object readObject() throws IOException, ClassNotFoundException    在 Java 中的序列化与反序列化必须使用内部提供的对象操作流，如果要实现一组对象的序列化，则可以使用对象数组完成\ntransient 关键字\n默认情况下当执行了对象序列化的时候会将类中的全部属性的内容进行全部的序列化操作，但是很多情况下有一些属性可能并不需要进行序列化的处理。\nprivate transient String name;\n进行序列化处理的时候，name属性的内容是不会被保存下来的，换言之，读取的数据name将是其对应数据类型的默认值null\n反射机制  所有的技术实现的目标只有一点：重用性\n 根据实例化对象反推出其类型\n 获取 Class 对象信息：public final Class\u0026lt;?\u0026gt; getClass()  class 类定义：public final class Class\u0026lt;T\u0026gt; implements java.io.Serializable,GenericDeclaration,Type,AnnotatedElement   JVM 直接支持采用“类.class”的形式实例化 Class.forName().public static Class\u0026lt;?\u0026gt; forName(String className) throws ClassNotFoundException  反射实例化对象\n通过public T newInstance()实例化对象\n相当于“类名 对象名 = new 类()”，但是该方法只能调用无参构造，JDK9 之后被废弃\n集合工具类 Stack 类\n入栈public E push(E item)\n出栈public synchronized E pop()\nStack 的继承结构如下：\n空栈时出栈会出现Exception in thread \u0026quot;main\u0026quot; java.util.EmptyStackException\nQueue 接口\n追加数据：boolean add(E e);或boolean offer(E e);\n通过队列获取数据：E poll();弹出后删除数据\n优先级队列PriorityQueue\nProperties 属性操作\nProperties 类只能操作 String\n使用 Properties 类型的最大特点是可以进行资源内容的输入与输出的处理操作\nCollections 类\n解释 Collection 与 Collections 的区别\n Collection 是集合接口，允许保存单值对象 Collections 是集合操作的工具类。  Stream 数据流 Stream 基础操作\nStream 主要功能是进行数据的分析处理，主要是针对于集合中的数据进行分析操作\n可以通过函数式编程进行数据的流式处理\n数据采集\n\u0026lt;R, A\u0026gt; R collect(Collector\u0026lt;? super T, A, R\u0026gt; collector);\n分页处理方法\n  设置取出的最大数据量：Stream\u0026lt;T\u0026gt; limit(long maxSize);\n  跳过指定数据量：Stream\u0026lt;T\u0026gt; skip(long n);\n  MapReduce 基础模型\nall.stream()用于初始化 Stream 对象\n.filter((ele)-\u0026gt;ele.getName().contains(\u0026quot;小米\u0026quot;))过滤出商品名称中含有小米的数据。\n.mapToDouble((olderObject)-\u0026gt;olderObject.getPrice()*olderObject.getCount()).summaryStatistics();计算出单种商品的总价，然后返回DoubleSummaryStatistics类型的对象。\nDoubleSummaryStatistics一些常用的方法\n网络编程 针对网络程序的开发有两种模型：\n C/S（Client/Server，客户端与服务器端） B/S（Browser/Server，浏览器与服务器端）  TCP（可靠的数据连接）\nUDP（不可靠的数据连接）\nTCP\nTCP 的程序开发是网络程序最基本的开发模型，其核心的特点是使用两个类实现数据的交互处理：ServerSocket（服务器端），Socket（客户端）\n简要工作流程如图：\nServerSocket 的主要目的是设置服务器监听的端口，Socket 要指明要连接的服务器地址与端口\nUDP\nUDP 程序是基于数据报的网络编程实现，如果想实现 UDP 程序需要两个类：DatagramSocket和DatagramPacket\nJDBC 对于 JDBC 的程序数据库的访问分为如下四种形式：\n  JDBC-ODBC 桥连接\n处理流程：程序 →JDBC→ODBC→ 数据库\n  JDBC 连接：直接通过 JDBC 进行数据库的连接\n处理流程：程序 →JDBC→ 数据库\n  JDBC 网络连接：通过特定的网络协议连接指定的数据库服务\n处理流程：程序 →JDBC→ 网络数据库(IP 地址，端口号)\n  JDBC 协议连接\n  Java 访问 MySQL 过程；\n  设置驱动\n1  `static final String JDBC_DRIVER = \u0026#34;com.mysql.jdbc.Driver\u0026#34;;\r    设置数据库地址\n1  static final String DB_URL = \u0026#34;jdbc:mysql://localhost:3308/test\u0026#34;;\r    设置用户名和密码\n1 2  static final String USER = \u0026#34;root\u0026#34;;\rstatic final String PASS = \u0026#34;123456\u0026#34;;\r    初始化连接对象和游标对象\n1 2  Connection conn = null;\rStatement stmt = null;\r    注册 JDBC 驱动\n1  Class.forName(JDBC_DRIVER);\r    打开连接\n1  conn = DriverManager.getConnection(DB_URL, USER, PASS);\r    执行查询语句\n1 2 3 4 5  System.out.println(\u0026#34; 实例化Statement对象...\u0026#34;);\rstmt = conn.createStatement();\rString sql;\rsql = \u0026#34;SELECT id, name, url FROM websites\u0026#34;;\rResultSet rs = stmt.executeQuery(sql);\r    用ResultSet对象接收返回结果\n1  ResultSet rs = stmt.executeQuery(sql);\r    遍历ResultSet对象\n1 2 3 4 5 6 7 8 9 10 11  while (rs.next()) {\r// 通过字段检索\r int id = rs.getInt(\u0026#34;id\u0026#34;);\rString name = rs.getString(\u0026#34;name\u0026#34;);\rString url = rs.getString(\u0026#34;url\u0026#34;);\r// 输出数据\r System.out.print(\u0026#34;ID: \u0026#34; + id);\rSystem.out.print(\u0026#34;, 站点名称: \u0026#34; + name);\rSystem.out.print(\u0026#34;, 站点 URL: \u0026#34; + url);\rSystem.out.print(\u0026#34;\\n\u0026#34;);\r}\r    关闭资源\n  1 2 3  rs.close();\rstmt.close();\rconn.close();\r  运行结果：\n1 2 3 4 5 6 7 8  Thu Apr 09 18:03:44 CST 2020 WARN: Establishing SSL connection without server\u0026#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn\u0026#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to \u0026#39;false\u0026#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.\r实例化Statement对象...\rID: 1, 站点名称: Google, 站点 URL: https://www.google.cm/\rID: 2, 站点名称: 淘宝, 站点 URL: https://www.taobao.com/\rID: 3, 站点名称: 菜鸟教程, 站点 URL: http://www.runoob.com\rID: 4, 站点名称: 微博, 站点 URL: http://weibo.com/\rID: 5, 站点名称: Facebook, 站点 URL: https://www.facebook.com/\rGoodbye!\r   MySQL 8.0 以上版本需设置 JDBC 为static final String JDBC_DRIVER = \u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;;\n ","description":"","id":18,"section":"posts","tags":["java"],"title":"JavaSE 学习笔记","uri":"https://eternidad33.github.io/zh/posts/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"码云上搭建 Hexo 静态博客   下载 Node.js\n  下载并配置 Git\n  安装 Hexo\n 设置 cnpm，设置为国内的淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 Hexo， cnpm install -g hexo-cli 查看是否安装成功 hexo -v    建立博客文件夹\n  执行hexo init\n  Hexo 常用的几个命令\n hexo s运行 Hexo hexo n 文件名.md创建博客文章，也可以直接在\\source\\_posts文件夹中创建 hexo g生成博客文件 hexo clean清理缓存 hexo d推送到远端服务器    创建远程仓库，仓库名要与自己的用户名相同\n  安装 Git 依赖，cnpm install --save hexo-deployer-git\n  修改配置文件\n1 2 3 4  deploy:type:gitrepo:https://gitee.com/eternidad33/eternidad33.gitbranch:master    开启Gitee Pages服务\n  推荐 B 站 Up 主：CodeSheep\n参考的是他的视频手把手教你从 0 开始搭建自己的个人博客 |无坑版视频教程| hexo\n","description":"","id":19,"section":"posts","tags":["hexo"],"title":"码云上搭建Hexo博客","uri":"https://eternidad33.github.io/zh/posts/%E7%A0%81%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"content":"学习类 中国大学 MOOC（涵盖各个行业的课程）\n慕课网（计算机互联网行业学习的网站）\n哔哩哔哩（各个领域的 UP 主）\nw3cSchool（学习编程）\n廖雪峰的官方网站（学习编程）\n菜鸟教程（学习编程）\n实验楼（学习编程）\n数据酷客（学习 Python，大数据）\n阿里云大学(提供编程各个方向的学习路线)\nhow2j（学习 Java）\n素材类 微信读书（只要有无限卡，全场免费读）\n鸠摩搜书（基本上想搜的书都能搜到）\nGreasy Fork（配合油猴插件下载脚本）\nMSDN，我告诉你（免费下载纯净的 Windows 系统镜像）\n我的 MSDN（免费下载纯净的 Windows 系统镜像）\n电脑壁纸（免费好看的桌面壁纸）\n阿里巴巴矢量图标库（下载各种格式的图标）\n第一 PPT（免费 PPT 模板）\n优品 PPT（免费 PPT 模板）\n站长素材（下载图标，字体，PSD，矢量图，jQuery 等）\n编程相关 ProcessOn（在线作图）\nGitHub（ 世界上最大的软件项目的托管平台 ）\n码云（相当于国内的 GitHub）\n牛客（刷题）\nLeetCode（刷题）\n洛谷（刷题）\nwakatime（记录编码时间）\nSM.MS（图床工具）\nShields.IO（生成展示在 Markdown 文档中的徽章）\nSimple Icons（下载 SVG 图标）\n","description":"","id":20,"section":"posts","tags":null,"title":"网站推荐","uri":"https://eternidad33.github.io/zh/posts/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"},{"content":"1. Alibaba Cloud Tookit  Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；并且还内置了 Arthas 诊断、Dubbo 工具、Terminal 终端、文件上传、函数计算 和 MySQL 执行器等工具。（产品官网：https://www.aliyun.com/product/cloudtoolkit）\n 通过该插件就可以直接在 VScode 上直接控制自己的远程服务器了，可以很方便地上传本机的文件到服务器上。\n需要配置的就是服务器的 ip,AccessKeyId,AccessKeySecret,用户名和密码\n2. Auto Import  Automatically finds, parses and provides code actions and code completion for all available imports. Works with Typescript and TSX.\n 该插件用于在编写代码时，自动导入文件中忘记写的需要的包，配置里的钩根据自己的需求打就行了\n3. Auto Rename Tag  Automatically rename paired HTML/XML tag, same as Visual Studio IDE does.\n 顾名思义就是 html，xml 的起始标签改变时，结束标签也会跟随改变\n4. Code Runner  Run code snippet or code file for multiple languages: C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, and custom command\n 如果用 VScode 编写 Java 可以用该插件编译，调试，和运行，其他语言可能也行，配置信息根据自身需求设置\n 如果是编写 Java，VScode 会提示安装许多 Java 的插件，例如：Debugger for Java，Java Dependency Viewer，Java Extension Pack，Java Test Runner，Language support for Java ™ for Visual Studio Code，Maven for Java，自动安装上即可\n 5. Color Info 该插件是在编写 CSS 需要设置颜色时用的，可以快速从调色板中选取颜色，设置透明度等。即装即用，无需配置。\n6. GitLens — Git supercharged  GitLens supercharges the Git capabilities built into Visual Studio Code. It helps you to visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more.\n 这个 Git 插件配合 VScode 自带的源代码管理工具，可以很好的管理自己的本地仓库和远程仓库。\n这个需要先把快捷键配置上,将 commit 的快捷键设置为 Alt+/\n7. Indent-Rainbow 不同缩进会显示不同的颜色，编写 Python 必装的插件，因为 Python 对缩进的要求很严格，即装即用，无需配置\n显示效果：\n8. LeetCode 刷 LeetCode 上的题必备的插件，可以查看自己刷过的题，支持查看，测试，提交，看自己的运行结果等\n配置时先把 user-account 设为 leetcode-cn，然后登陆自己的账户即可，然后配置上自己习惯用的语言\n9. wakatime 记录自己的编码时间，在wakatime 官网上直接查看自己每天的编码时间，免费版最多可以保存最近 14 天的。\n如果使用其他的 IDE 也可以安装该插件，然后在官网上查看自己编写各种语言的时间，和使用各个 IDE 的时间，每周会给自己邮箱发一个周报\n只需配置上自己在官网上注册的账号的 api key 即可。\n10. PicGo 图床工具，支持的图床有 qiniu, tcyun, upyun, github, aliyun, imgur 和 SM.MS，默认是 SM.MS。但是 SM.MS 经常上传失败，我也不太清楚怎么解决。介绍一下 GitHub 图床的配置\n PicBed 设为GitHub branch 设为master Custom Url：https://cdn.jsdelivr.net/gh/user/repo@master采用 cdn 访问，因为国内访问 GitHub 相对较慢  gh表示 github user填写自己的用户名 repo填写自己图床的仓库 例如https://cdn.jsdelivr.net/gh/eternidad33/picbed@master   Path:images/图片上传到仓库中的 images 文件夹中 Repo：user/repo填写自己的仓库即可 Token：自己在 GitHub 上创建一个拥有 repo 权限的 Token，填上即可  上传本机图片的快捷键是 Ctrl+Alt+E\n11. Markdown Preview Enhanced with litvis 全面支持 Markdown 的预览，默认的 Markdown 预览显示的不太好看，[Toc]生成的目录是显示不出的，还有一些 HTML 的标签支持的也不是很好，而该插件就可以很好地显示，同时还可以将 Markdown 文件导出为 HTML，PDF 等格式的文件\nWallpaper 每日壁纸分享 标题：Fantasy World\n创作者：Mrs.Venus\n","description":"Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；","id":21,"section":"posts","tags":null,"title":"VSCode插件推荐","uri":"https://eternidad33.github.io/zh/posts/vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"content":"个人主页 代码：码云，Github\n博客：简书，CSDN，博客园\n刷题：牛客，LeetCode\n社交：今日头条，哔哩哔哩，steam，知乎，百度贴吧，微博\n欢迎大家关注我的动态\n","description":"个人动态","id":22,"section":"","tags":null,"title":"关于","uri":"https://eternidad33.github.io/zh/about/"}]