[{"content":"欢迎大家访问我的github\n创建以用户名为名称的仓库\n自定义自己的README文件即可在自己的github显示了\n我这个上边显示的编码时长，是添加了一个action每天更新自己的编码时长\n具体设计步骤可参考 github上的athul/waka-readme项目\n总结一下简要的步骤\n 注册wakatime账号 在自己常用的IDE上下载wakatime插件，配置上自己的API key 将自己的API key存到自己GitHub仓库的secrets 在README文件上加上  1 2  \u0026lt;!--START_SECTION:waka--\u0026gt;\r\u0026lt;!--END_SECTION:waka--\u0026gt;\r  配置GitHub仓库的Action，这样就能每天自动运行了  ","description":"","id":0,"section":"posts","tags":["github"],"title":"自定义GitHub主页","uri":"https://eternidad33.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89github%E4%B8%BB%E9%A1%B5/"},{"content":"连接SQLite 要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；\n连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。\nPython定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。\n由于SQLite的驱动内置在Python标准库中，可以直接来操作SQLite数据库。\n1 2  # 导入SQLite驱动: import sqlite3   1 2 3 4  # 连接到SQLite数据库 # 数据库文件是test.db # 如果文件不存在，会自动在当前目录创建: conn = sqlite3.connect(\u0026#39;test.db\u0026#39;)   1 2  # 创建一个Cursor: cursor = conn.cursor()   1 2  # 执行一条SQL语句，创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 继续执行一条SQL语句，插入一条记录: cursor.execute(\u0026#39;insert into user (id, name) values (\u0026#34;1\u0026#34;, \u0026#34;vigilr\u0026#34;)\u0026#39;)   \u0026lt;sqlite3.Cursor at 0x2040e1eff10\u0026gt;  1 2  # 通过rowcount获得插入的行数: cursor.rowcount   1  1 2 3 4 5 6  # 关闭Cursor: cursor.close() # 提交事务: conn.commit() # 关闭Connection: conn.close()   1 2 3 4  conn = sqlite3.connect(\u0026#39;test.db\u0026#39;) cursor = conn.cursor() # 执行查询语句: cursor.execute(\u0026#39;select * from user where id=?\u0026#39;,(\u0026#39;1\u0026#39;,))   \u0026lt;sqlite3.Cursor at 0x2040e224810\u0026gt;  1 2 3  # 获得查询结果集: values = cursor.fetchall() values   [('1', 'vigilr')]  1 2  cursor.close() conn.close()   使用Python的DB-API时，只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用。\n使用Cursor对象执行insert，update，delete语句时，执行结果由rowcount返回影响的行数，就可以拿到执行结果。\n使用Cursor对象执行select语句时，通过featchall()可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。\n如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，例如：\n1  cursor.execute(\u0026#39;select * from user where name=? and pwd=?\u0026#39;, (\u0026#39;abc\u0026#39;, \u0026#39;password\u0026#39;))   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # -*- coding: utf-8 -*- import sqlite3 # 初始数据: conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;create table user(id varchar(20) primary key, name varchar(20), score int)\u0026#39;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-001\u0026#39;, \u0026#39;Adam\u0026#39;, 95)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-002\u0026#39;, \u0026#39;Bart\u0026#39;, 62)\u0026#34;) cursor.execute(r\u0026#34;insert into user values (\u0026#39;A-003\u0026#39;, \u0026#39;Lisa\u0026#39;, 78)\u0026#34;) cursor.close() conn.commit() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13  def get_score_in(low, high): \u0026#39;\u0026#39;\u0026#39;返回指定分数区间的名字，按分数从低到高排序\u0026#39;\u0026#39;\u0026#39; conn = sqlite3.connect(\u0026#39;test1.db\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;select name from user where score\u0026gt;=? and score\u0026lt;=? ORDER BY score\u0026#39;,(low,high)) temp=cursor.fetchall() result=[] for t in temp: for i in t: result.append(i) cursor.close() conn.close() return result   1 2 3 4 5 6 7  # 测试: assert get_score_in(80, 95) == [\u0026#39;Adam\u0026#39;], get_score_in(80, 95) assert get_score_in(60, 80) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;], get_score_in(60, 80) assert get_score_in(60, 100) == [\u0026#39;Bart\u0026#39;, \u0026#39;Lisa\u0026#39;, \u0026#39;Adam\u0026#39;], get_score_in(60, 100) print(\u0026#39;Pass\u0026#39;)   Pass  连接MySQL 安装MySQL驱动\n由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。\nMySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数--allow-external：\npip install mysql-connector-python --allow-external mysql-connector-python\n如果上面的命令安装失败，可以试试另一个驱动：\npip install mysql-connector\n除了使用mysql.connector还可以使用pymysql\n1 2  # 导入pymysql模块 import pymysql   1 2 3 4 5 6 7 8 9 10 11 12  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 创建user表: cursor.execute(\u0026#39;create table user (id varchar(20) primary key, name varchar(20))\u0026#39;) cursor.close() conn.close()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) cursor = conn.cursor() # 插入一行记录，注意MySQL的占位符是%s: cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;1\u0026#39;, \u0026#39;wasd\u0026#39;]) cursor.execute(\u0026#39;insert into user (id, name) values (%s, %s)\u0026#39;, [\u0026#39;2\u0026#39;, \u0026#39;zxc\u0026#39;]) print(\u0026#39;受影响行数：\u0026#39;,cursor.rowcount) # 提交事务: conn.commit() cursor.close() conn.close()   受影响行数： 1  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 连接database conn = pymysql.connect( host=\u0026#34;127.0.0.1\u0026#34;, port=3308, user=\u0026#34;root\u0026#34;,password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;, charset=\u0026#34;utf8\u0026#34;) # 运行查询: cursor = conn.cursor() cursor.execute(\u0026#39;select * from user\u0026#39;) values = cursor.fetchall() print(values) # 关闭Cursor和Connection: cursor.close() conn.close()   (('1', 'wasd'), ('2', 'zxc'))  使用SQLAlchemy ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。\n在Python中，最有名的ORM框架是SQLAlchemy。\n首先通过pip安装SQLAlchemy：pip install sqlalchemy\n1 2 3 4 5 6  # 第一步，导入SQLAlchemy，并初始化DBSession： # 导入: from sqlalchemy import Column, String, create_engine,ForeignKey from sqlalchemy.orm import sessionmaker,relationship from sqlalchemy.ext.declarative import declarative_base   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 创建对象的基类: Base = declarative_base() # 定义User对象: class User(Base): # 表的名字: __tablename__ = \u0026#39;users\u0026#39; # 表的结构: id = Column(String(20), primary_key=True) name = Column(String(20)) # 以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如Scho class School(Base): __tablename__ = \u0026#39;school\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # 初始化数据库连接:mysqlconnector和pymysql都可以用 # engine = create_engine(\u0026#39;mysql+mysqlconnector://root:123456@localhost:3308/test\u0026#39;) engine = create_engine(\u0026#39;mysql+pymysql://root:123456@localhost:3308/test\u0026#39;) # 创建DBSession类型: DBSession = sessionmaker(bind=engine)   create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：\n数据库类型+数据库驱动名称://用户名:密码@数据库地址:端口号/数据库名\n由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 创建所有定义的表到数据库中 Base.metadata.create_all(engine) # 创建session对象: session = DBSession() # 创建新User对象: user1 = User(id=\u0026#39;1\u0026#39;, name=\u0026#39;wasd\u0026#39;) user2 = User(id=\u0026#39;2\u0026#39;, name=\u0026#39;zxc\u0026#39;) user3 = User(id=\u0026#39;3\u0026#39;, name=\u0026#39;qwe\u0026#39;) user4 = User(id=\u0026#39;4\u0026#39;, name=\u0026#39;rty\u0026#39;) user5 = User(id=\u0026#39;5\u0026#39;, name=\u0026#39;vbn\u0026#39;) user6 = User(id=\u0026#39;6\u0026#39;, name=\u0026#39;fgh\u0026#39;) # 添加到session: session.add(user1) session.add(user2) session.add(user3) session.add(user4) session.add(user5) session.add(user6) # 提交即保存到数据库: session.commit() # 关闭session: session.close() # 关键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接。   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\pymysql\\cursors.py:170: Warning: (1366, \u0026quot;Incorrect string value: '\\\\xD6\\\\xD0\\\\xB9\\\\xFA\\\\xB1\\\\xEA...' for column 'VARIABLE_VALUE' at row 489\u0026quot;) result = self._query(query)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 查询数据 # 创建Session: session = DBSession() # 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行: user = session.query(User).filter(User.id==\u0026#39;1\u0026#39;).one() users = session.query(User).filter(User.id!=\u0026#39;1\u0026#39;).all() # 打印类型和对象的name属性: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) for user in users: print(\u0026#39;type:\u0026#39;, type(user)) print(\u0026#39;name:\u0026#39;, user.name) # 关闭Session: session.close()   type: \u0026lt;class '__main__.User'\u0026gt; name: wasd type: \u0026lt;class '__main__.User'\u0026gt; name: zxc type: \u0026lt;class '__main__.User'\u0026gt; name: qwe type: \u0026lt;class '__main__.User'\u0026gt; name: rty type: \u0026lt;class '__main__.User'\u0026gt; name: vbn type: \u0026lt;class '__main__.User'\u0026gt; name: fgh  ORM就是把数据库表的行与相应的对象建立关联，互相转换。\n由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。\n例如，如果一个User拥有多个Book，就可以定义一对多关系如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class User(Base): __tablename__ = \u0026#39;user\u0026#39; __table_args__ = {\u0026#39;extend_existing\u0026#39;: True} id = Column(String(20), primary_key=True) name = Column(String(20)) # 一对多: books = relationship(\u0026#39;Book\u0026#39;) class Book(Base): __tablename__ = \u0026#39;book\u0026#39; id = Column(String(20), primary_key=True) name = Column(String(20)) # “多”的一方的book表是通过外键关联到user表的: user_id = Column(String(20), ForeignKey(\u0026#39;user.id\u0026#39;)) # 当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。 # 创建所有定义的表到数据库中 Base.metadata.create_all(engine)   E:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\sqlalchemy\\ext\\declarative\\clsregistry.py:129: SAWarning: This declarative base already contains a class with the same class name and module name as __main__.User, and will be replaced in the string-lookup table. % (item.__module__, item.__name__)  更多用法可参考：这篇文章https://www.jianshu.com/p/65903a69d61d\n","description":"","id":1,"section":"posts","tags":["python"],"title":"Python三种连接数据库的方式","uri":"https://eternidad33.github.io/zh/posts/python%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"content":"购买服务器 直接购买皆可以了\n有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器\n现在购买可以91.8一年\n学生购买是9.50一个月（参与云翼计划然后学生认证即可）\n 我是单买的一个月的，因为不经常用，想用的时候就买一个月的\n 安装镜像 从镜像市场选择宝塔控制面板安装\n 宝塔Linux面板（LAMP/LNMP/Tomcat/Node.js）\n功能强大且终身免费的Linux服务器管理软件，一键部署：LAMP/LNMP/Tomcat/Node.js、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。\n 镜像安装完要配置安全组打开相应端口\n面板配置 bt命令进行相关的操作\n可以更改掉默认的用户名和密码\n浏览器访问公网ip:8888进行环境的安装\n可以选择LNMP安装，大约5~6分钟安装完成\n配置mysql数据库相应的端口，默认3306，可以改为其他端口\n安装完成后可以数据库的root密码\n安装Tomcat 从左侧的软件商店安装Tomcat（不用单独安装Java，面板自动安装Java）\n安装完tomcat后要在面板中放行8080端口，前边的安全组也要放行8080端口\n浏览器成功访问公网ip:8080，即为成功安装\n部署项目 本文部署的是GitHub上的 一个基于SSM+Websocket的实时在线聊天室项目\n配置数据库信息并生成war包\n成功生成war包后的效果如下：\n在服务器的mysql运行本项目中的sql文件\n将生成的war文件上传到/www/server/tomcat/webapps目录下，tomcat会自动解压\n 上传文件方法有很多，可以通过命令行，也可以用工具，我知道的工具如下：\n xshell及xftp IDEA的阿里云部署插件(Alibaba Cloud Toolkit) 通过宝塔面板上传   浏览器访问公网IP:8080/网站应用名，出现下面的界面即为成功部署\n","description":"","id":2,"section":"posts","tags":["java"],"title":"阿里云宝塔面板配置及部署Java项目","uri":"https://eternidad33.github.io/zh/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE/"},{"content":" Scrapy is a fast high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.\n​\t\u0026mdash;\u0026mdash;\u0026mdash;来自官方文档的介绍\n  Engine从Spider处获得爬取请求(Request) Engine将爬取请求转发给Scheduler，用于调度 Engine从Scheduler处获得下一个要爬取的请求 Engine将爬取请求通过中间件发送给Downloader 爬取网页后，Downloader形成响应（Response）通过中间件发给Engine Engine将收到的响应通过中间件发送给Spider处理 Spider处理响应后产生爬取项（scraped Item）和新的爬取请求（Requests）给Engine Engine将爬取项发送给Item Pipeline（框架出口） Engine将爬取请求发送给Scheduler  Engine控制各模块数据流，不间断从Scheduler处获得爬取请求，直至请求为空。\n数据流的出入口\n框架入口：Spider的初始爬取请求\n框架出口：Item Pipeline\n用户只需编写(配置)Spider和Item Pipeline\nEngine\n 控制所有模块之间的数据流 根据条件触发事件  不需要用户修改\nDownloader\n根据请求下载网页\n不需要用户修改\nScheduler\n对所有爬取请求进行调度管理\n不需要用户修改\nDownloader Middleware\n目的：实施Engine、Scheduler和Downloader之间进行用户可配置的控制\n功能：修改、丢弃、新增请求或响应\n用户可以编写配置代码\nSpider\n 解析Downloader返回的响应（Response） 产生爬取项（scraped item） 产生额外的爬取请求（Request）  需要用户编写配置代码\nItem Pipelines\n 以流水线方式处理Spider产生的爬取项 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库  需要用户编写配置代码\nSpider Middleware\n目的：对请求和爬取项的再处理\n功能：修改、丢弃、新增请求或爬取项\n用户可以编写配置代码\nrequests 和 Scrapy的异同\n相同点：\n 两者都可以进行页面请求和爬取，Python爬虫的两个重要技术路线 两者可用性都好，文档丰富，入门简单 两者都没有处理js、提交表单、应对验证码等功能（可扩展）  不同点：\n   requests Scrapy     页面级爬虫 网站级爬虫   功能库 框架   并发性考虑不足，性能较差 并发性好，性能较高   重点在于页面下载 重点在于爬虫结构   定制灵活 一般定制灵活，深度定制困难   上手十分简单 入门稍难    Scrapy常用命令\n   命令 说明 格式     startproject 创建一个新工程 scrapy startproject \u0026lt;name\u0026gt; [dir]   genspider 创建一个爬虫 scrapy genspider [options] \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt;   settings 获得爬虫配置信息 scrapy settings [options]   crawl 运行一个爬虫 scrapy crawl \u0026lt;spider\u0026gt;   list 列出工程中所有爬虫 scrapy list   shell 启动URL调试命令行 scrapy shell [url]    生成的工程目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  PS E:\\scrapyDemo\u0026gt; tree /f 卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r│ scrapy.cfg -------------------\u0026gt;\u0026gt;部署Scrapy爬虫的配置文件\r│\r└─scrapyDemo ------------\u0026gt;\u0026gt;Scrapy框架的用户自定义Python代码\r│ items.py --------------\u0026gt;\u0026gt;Items代码模板（继承类）\r│ middlewares.py -------\u0026gt;\u0026gt;Middlewares代码模板（继承类）\r│ pipelines.py ---------\u0026gt;\u0026gt;Pipelines代码模板（继承类）\r│ settings.py --------\u0026gt;\u0026gt;Scrapy爬虫的配置文件\r│ __init__.py ---------\u0026gt;\u0026gt;初始化脚本\r│\r├─spiders --------------\u0026gt;\u0026gt;Spiders代码模板目录（继承类）\r│ │ firstSpider.py ------\u0026gt;\u0026gt;生成的爬虫\r│ │ __init__.py ------\u0026gt;\u0026gt;初始文件，无需修改\r│ │\r│ └─__pycache__ --------\u0026gt;\u0026gt;缓存目录，无需修改\r│ firstSpider.cpython-37.pyc\r│ __init__.cpython-37.pyc\r│\r└─__pycache__ -----------\u0026gt;\u0026gt;缓存目录，无需修改\rsettings.cpython-37.pyc\r__init__.cpython-37.pyc\r  Scrapy爬虫的使用步骤\n步骤1：创建一个工程和Spider模板\n步骤2：编写Spider\n步骤3：编写Item Pipeline\n步骤4：优化配置策略\nScrapy爬虫的数据类型\n  Request类\nRequest对象表示一个HTTP请求，由Spider生成，由Downloader执行\n  Response类\nResponse对象表示一个HTTP响应，由Downloader生成，由Spider处理\n  Item类\nItem对象表示一个从HTML页面中提取的信息内容，由Spider生成，由Item Pipeline处理，Item类似字典类型，可以按照字典类型操作\n  Scrapy爬虫支持多种HTML信息提取方法：\n Beautiful Soup lxml re XPath Selector CSS Selector  ","description":"","id":3,"section":"posts","tags":["python","爬虫"],"title":"Scrapy 框架笔记","uri":"https://eternidad33.github.io/zh/posts/scrapy/"},{"content":"基础页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;\r\u0026lt;h2\u0026gt;前端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;List1\u0026#34;\u0026gt;\r\u0026lt;li id=\u0026#34;li1\u0026#34;\u0026gt;HTML\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;h2\u0026gt;后端语言\u0026lt;/h2\u0026gt;\r\u0026lt;ul id=\u0026#34;list2\u0026#34;\u0026gt;\r\u0026lt;li title=\u0026#34;C语言\u0026#34;\u0026gt;C\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;Java语言\u0026#34;\u0026gt;Java\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;我是Python\u0026#34;\u0026gt;Python\u0026lt;/li\u0026gt;\r\u0026lt;li title=\u0026#34;C Sharp\u0026#34;\u0026gt;C#\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r  运行结果\n通过ID获取元素 1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;list1\u0026#34;);\rvar c2 = document.getElementById(\u0026#34;li1\u0026#34;)\rdocument.write(\u0026#34;通过ID获取 ul 标签\u0026#34; + c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#34;通过ID获取 li 标签\u0026#34; + c2);\r\u0026lt;/script\u0026gt;\r  显示结果：\ninnerHTML用于获取或修改p标签内容\n1 2 3 4 5 6  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\rc1.innerHTML = \u0026#39;我是修改后的p标签\u0026#39;;\rdocument.write(c1.innerHTML + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;)\r\u0026lt;/script\u0026gt;\r  显示结果：\n改变HTML样式 基本语法格式：Object.style.property=str;\n1 2 3 4 5 6 7  \u0026lt;script\u0026gt;\rvar c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.style.color = \u0026#39;red\u0026#39;\rc1.style.fontSize = \u0026#39;30px\u0026#39;\rc1.style.fontFamily = \u0026#39;隶书\u0026#39;\rc1.style.backgroundColor = \u0026#39;#cccccc\u0026#39;\r\u0026lt;/script\u0026gt;\r  显示效果：\n改变类选择器 格式object.className = classname\n1 2  var c1 = document.getElementById(\u0026#34;ppp\u0026#34;)\rc1.className = \u0026#39;test\u0026#39;\r  显示结果：\n通过name属性获取元素 格式document.getElementsByName(str);\n1 2 3  var c1 = document.getElementsByName(\u0026#39;myname\u0026#39;);\rdocument.write(c1 + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;);\rdocument.write(\u0026#39;数组的长度为\u0026#39; + c1.length);\r  显示结果：\n通过标签名字获取标签 格式：document.getElementsByTagName(str);\n1 2  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\r  显示结果：\nID是唯一的。\nName可以重复。\nTagName是某一标签类的集合。\n获取属性值 格式：elementNode.getAttribute(name)\n1 2 3 4 5 6 7 8  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  设置新属性 elementNode.setAttribute(name,value)\n1 2 3 4 5 6 7 8 9 10 11 12  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rdocument.write(\u0026#39;li 标签的数量为：\u0026#39; + c1.length);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;);\rif (text == \u0026#34;C Sharp\u0026#34;) {\rc1[i].setAttribute(\u0026#39;title\u0026#39;, \u0026#39;C#\u0026#39;)\rtext = c1[i].getAttribute(\u0026#39;title\u0026#39;)\r}\rif (text != null) {\rdocument.write(\u0026#39;\u0026lt;br\u0026gt;\u0026#39; + text)\r}\r}\r  节点对象属性 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：\n  nodeName : 节点的名称\n  nodeValue ：节点的值\n  nodeType ：节点的类型\n  1 2 3 4 5 6  var c1 = document.getElementsByTagName(\u0026#34;li\u0026#34;);\rfor (var i = 0; i \u0026lt; c1.length; i++) {\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的名称:\u0026#34; + c1[i].nodeName)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的类型:\u0026#34; + c1[i].nodeType)\rdocument.write(\u0026#34;\u0026lt;br\u0026gt;节点\u0026#34; + i + \u0026#34;的值:\u0026#34; + c1[i].nodeValue)\r}\r  访问子节点 elementNode.childNodes用于访问子节点\nnode.firstChild用于访问第一个子节点\nnode.lastChild用于访问最后一个子节点\n访问父节点 elementNode.parentNode用于访问父节点\nelementNode.parentNode.parentNode用于访问祖节点\n访问兄弟节点   nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。nodeObject.nextSibling\n  previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。nodeObject.previousSibling \n   如果无兄弟节点，则该属性返回 null。\n 插入节点 appendChild(newnode)\n1 2 3 4  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.appendChild(newNode)\r  insertBefore() 方法可在已有的子节点前插入一个新的子节点。\ninsertBefore(newnode,node);\n1 2 3 4 5  var c1 = document.getElementById(\u0026#39;List1\u0026#39;)\rvar newNode = document.createElement(\u0026#39;li\u0026#39;)\rvar lNode = document.getElementById(\u0026#39;List1\u0026#39;).firstChild\rnewNode.innerHTML = \u0026#39;jQuery\u0026#39;\rc1.insertBefore(newNode, lNode)\r  删除节点 removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。\nnodeObject.removeChild(node)\n node ：必需，指定需要删除的节点。\n 替换元素节点 replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。\nnode.replaceChild (newnode,oldnew ) \n newnode : 必需，用于替换 oldnew 的对象。\noldnew : 必需，被 newnode 替换的对象。\n 创建元素节点 createElement()方法可创建元素节点。此方法可返回一个 Element 对象。\ndocument.createElement(tagName)\ntagName：字符串值，这个字符串用来指明创建元素的类型。\n 要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。\n 创建文本节点 createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。\ndocument.createTextNode(data)\ndata : 字符串值，可规定此节点的文本。\n","description":"目录 基础页面，通过ID获取元素，改变HTML样式，改变类选择器，通过name属性获取元素，通过标签名字获取标签，获取属性值，设置新属性节点，对象属性访问子节点，访问父节点，访问兄弟节点，插入节点，删除节点，替换元素节点，创建元素节点，创建文本节点","id":4,"section":"posts","tags":["JavaScript","html"],"title":"JavaScript DOM 操作","uri":"https://eternidad33.github.io/zh/posts/javascript-dom%E6%93%8D%E4%BD%9C/"},{"content":"项目配置 @Value(“${变量名}”) 变量名：配置文件中的全局变量\n1 2 3 4  @Value(\u0026#34;${name}\u0026#34;)\rprivate String name;\r@Value(\u0026#34;${desc}\u0026#34;)\rprivate String desc;\r  yml配置文件中的配置\n1 2  name:维吉尔desc:你好，${name}！  @ConfigurationProperties(prefix = \u0026ldquo;对象名\u0026rdquo;) @ConfigurationProperties(prefix = \u0026ldquo;person\u0026rdquo;)注解要和@Component一起用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  @Component\r@ConfigurationProperties(prefix = \u0026#34;person\u0026#34;)\rpublic class Person {\rprivate String name;\rprivate int age;\rprivate String sex;\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\r@Override\rpublic String toString() {\rfinal StringBuffer sb = new StringBuffer(\u0026#34;Person{\u0026#34;);\rsb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#34;, age=\u0026#34;).append(age);\rsb.append(\u0026#34;, sex=\u0026#39;\u0026#34;).append(sex).append(\u0026#39;\\\u0026#39;\u0026#39;);\rsb.append(\u0026#39;}\u0026#39;);\rreturn sb.toString();\r}\r}\r  yml配置文件中的对象配置\n1 2 3 4  person:name:Vigilrage:23sex:男  调用方式，会用到@Autowired和@GetMapping(\u0026quot;/person\u0026quot;)\n1 2 3 4 5 6 7  @Autowired\rprivate Person person;\r@GetMapping(\u0026#34;/person\u0026#34;)\rpublic String printPerson() {\rreturn this.person.toString();\r}\r  请求方式    代码 说明 举例     @GetMapping(\u0026quot;/url\u0026quot;) get请求 @GetMapping(\u0026quot;/user/{id}\u0026quot;)   @PostMapping(\u0026quot;/url\u0026quot;) post请求 @PostMapping(\u0026quot;/user\u0026quot;)   @PutMapping(\u0026quot;/url\u0026quot;) put请求 @PutMapping(\u0026quot;/user/{id}\u0026quot;)    Controller相关注解 @Controller 1 2 3 4 5 6 7  @Controller\rpublic class HelloController {\r@GetMapping(\u0026#34;/index\u0026#34;)\rpublic String printIndex() {\rreturn \u0026#34;index\u0026#34;;\r}\r}\r  直接用可解析HTML\n@ResponseBody 与@Controller配合使用\n1 2 3 4 5 6 7 8  @Controller\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\r@ResponseBody\rpublic String sayHello() {\rreturn desc;\r}\r}\r  @RestController @RestController=@Controller+@ResponseBody\n1 2 3 4 5 6 7  @RestController\rpublic class HelloController {\r@GetMapping({\u0026#34;/hello\u0026#34;, \u0026#34;hi\u0026#34;})\rpublic String sayHello() {\rreturn desc;\r}\r}\r  获取参数 @PathVariable(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4  @GetMapping(\u0026#34;/user/{id}\u0026#34;)\rpublic UserEntity findId(@PathVariable(\u0026#34;id\u0026#34;) Integer id) {\rreturn repository.findById(id).orElse(null);\r}\r  @RequestParam(\u0026ldquo;参数名\u0026rdquo;) 1 2 3 4 5 6 7 8 9  @PostMapping(\u0026#34;/user\u0026#34;)\rpublic UserEntity create(@RequestParam(\u0026#34;age\u0026#34;) Integer age,\r@RequestParam(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;sex\u0026#34;) String sex) {\rUserEntity userEntity = new UserEntity();\ruserEntity.setAge(age);\ruserEntity.setName(name);\ruserEntity.setSex(sex);\rreturn repository.save(userEntity);\r}\r  数据库相关 @Entity 表的定义\n@Id 设置主键\n@GeneratedValue 设置自增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  @Entity\rpublic class UserEntity {\r@Id\r@GeneratedValue\rprivate Integer id;\rprivate String name;\rprivate String sex;\rprivate Integer age;\rpublic UserEntity() {\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getSex() {\rreturn sex;\r}\rpublic void setSex(String sex) {\rthis.sex = sex;\r}\rpublic Integer getAge() {\rreturn age;\r}\rpublic void setAge(Integer age) {\rthis.age = age;\r}\r}\r   在IDEA中声明@Entity后，左侧会有数据库的标志\n @Transactional 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Transactional\rpublic void createTwo() {\rUserEntity userEntity1 = new UserEntity();\ruserEntity1.setAge(12);\ruserEntity1.setName(\u0026#34;wasd\u0026#34;);\ruserEntity1.setSex(\u0026#34;sssss\u0026#34;);\rrepository.save(userEntity1);\rUserEntity userEntity2 = new UserEntity();\ruserEntity2.setAge(1314);\ruserEntity2.setName(\u0026#34;zxcvbnm\u0026#34;);\ruserEntity2.setSex(\u0026#34;ddddddd\u0026#34;);\rrepository.save(userEntity2);\r}\r  数据库表的引擎必须为INNODB才可进行事务管理\n","description":"Spring Boot常用注解项目配置@Value(“${变量名}”)变量名：配置文件中的全局变量","id":5,"section":"posts","tags":["java","springboot"],"title":"SpringBoot 必备注解","uri":"https://eternidad33.github.io/zh/posts/springboot%E5%BF%85%E5%A4%87%E6%B3%A8%E8%A7%A3/"},{"content":"[toc]\n简易的图书管理系统 项目简介 推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql\n用到的知识：Java，MySQL\n源码已上传至码云\n项目整体架构 源码目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  PS E:\\IdeaProjects\\BookManager\\src\u0026gt; tree /f\r卷 软件 的文件夹 PATH 列表\r卷序列号为 54DD-69A2\rE:.\r├─dao\r│ BookDao.java\r│ BookTypeDao.java\r│ UserDao.java\r│\r├─entity\r│ Book.java\r│ Booktype.java\r│ User.java\r│\r├─images\r│ book.png\r│ susu.jpg\r│\r├─META-INF\r│ MANIFEST.MF\r│\r├─util\r│ DbUtil.java\r│ StringUtil.java\r│\r└─view\rAbout.java\rAbout.jfd\rBookAddFrm.java\rBookAddFrm.jfd\rBookTypeAddFrm.java\rBookTypeAddFrm.jfd\rBookTypeManagerFrm.java\rBookTypeManagerFrm.jfd\rLogin.form\rLogin.java\rMainFrm.java\rMainFrm.jfd\r  由此可见，本项目也是采用的 MVC 架构，dao包用于操作数据库，entity包包含本项目的实体类，images包是本项目用到的图片，META-INF包是生成 Jar 包时产生的文件夹，util包包含本项目用到的工具类，view包是本项目的视图层，用于设计窗口显示。\n项目中各类的依赖关系如下图\n具体实现 util包 本项目的工具包，包含两个工具类\nDbUtil.java主要是设计了数据库的驱动，地址，用户名及密码，和控制数据库的连接与断开\nStringUtil.java只是用于判断字符串是否为空，只有空格也算为空\nentity包 此包包含了数据库表的实体对象，可以自己写，也可以通过 idea 的EasyCode插件进行代码生成，但是后边要用到的必要的构造方法要自己写。\n大多数情况下都是简单类包含 Getter 和 Setter 方法，如下是EasyCode插件生成的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  public class Booktype implements Serializable {\rprivate static final long serialVersionUID = -43707012852599825L;\rprivate Integer id;\rprivate String booktypename;\r@Override\rpublic String toString() {\rreturn this.booktypename;\r}\rprivate String booktypedesc;\rpublic Booktype(String booktypename, String booktypedesc) {\rthis.booktypename = booktypename;\rthis.booktypedesc = booktypedesc;\r}\rpublic Booktype() {\rsuper();\r}\rpublic Booktype(Integer id, String booktypename, String booktypedesc) {\rthis(booktypename, booktypedesc);\rthis.id = id;\r}\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic String getBooktypename() {\rreturn booktypename;\r}\rpublic void setBooktypename(String booktypename) {\rthis.booktypename = booktypename;\r}\rpublic String getBooktypedesc() {\rreturn booktypedesc;\r}\rpublic void setBooktypedesc(String booktypedesc) {\rthis.booktypedesc = booktypedesc;\r}\r}\r  dao包 进行数据库的访问\n类中的方法定义形式基本为public 返回类型 方法名(Connection conn, 实体类 对象名) throws SQLException\n例如用户登录的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public User login(Connection connection, User user) throws SQLException {\rUser resultUser = null;\rString sql = \u0026#34;select * from table_user where userName=? and password=?\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, user.getUserName());\rpsmt.setString(2, user.getPassword());\rResultSet resultSet = psmt.executeQuery();\rif (resultSet.next()) {\rresultUser = new User();\rresultUser.setId(resultSet.getInt(\u0026#34;id\u0026#34;));\rresultUser.setUserName(resultSet.getString(\u0026#34;userName\u0026#34;));\rresultUser.setPassword(resultSet.getString(\u0026#34;password\u0026#34;));\r}\rreturn resultUser;\r}\r  步骤总结：\n  其中 SQL 语句中的要查找的值要用?代替，方便后面设置\nString sql = \u0026quot;select * from table_user where userName=? and password=?\u0026quot;;\n  然后创建 SQL 语句的游标对象\npsmt，PreparedStatement psmt = connection.prepareStatement(sql);\n  设置 SQL 语句中的变量值，第几个?为几，索引就是几，没有 0\npsmt.setString(1, user.getUserName());\n  执行查询语句，并返回ResultSet对象用于保存查询结果\nResultSet resultSet = psmt.executeQuery();\n  然后根据需求进行其他操作\n  BookDao类的设计如下，dao包下的其他类类似\n添加图书\n1 2 3 4 5 6 7 8 9 10 11  public static int add(Connection connection, Book book) throws SQLException {\rString sql = \u0026#34;insert into book values(null,?,?,?,?,?,?)\u0026#34;;\rPreparedStatement psmt = connection.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setInt(4, book.getBooktypeid());\rpsmt.setString(5, book.getBookdesc());\rpsmt.setFloat(6, book.getPrice());\rreturn psmt.executeUpdate();\r}\r  添加成功返回 1，添加失败返回 0\n删除图书\n1 2 3 4 5 6  public static int delete(Connection conn, String id) throws SQLException {\rString sql = \u0026#34;delete from book where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, id);\rreturn psmt.executeUpdate();\r}\r  删除成功返回 1，删除失败返回 0\n修改图书\n1 2 3 4 5 6 7 8 9 10 11 12  public static int update(Connection conn, Book book) throws SQLException {\rString sql = \u0026#34;update book set bookName=?,author=?,sex=?,price=?,bookTypeid=?,bookDesc=? where id=?\u0026#34;;\rPreparedStatement psmt = conn.prepareStatement(sql);\rpsmt.setString(1, book.getBookname());\rpsmt.setString(2, book.getAuthor());\rpsmt.setString(3, book.getSex());\rpsmt.setFloat(4, book.getPrice());\rpsmt.setInt(5, book.getBooktypeid());\rpsmt.setString(6, book.getBookdesc());\rpsmt.setInt(7, book.getId());\rreturn psmt.executeUpdate();\r}\r  修改成功返回 1，修改失败返回 0\n查询图书\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static ResultSet list(Connection conn, Book book) throws SQLException {\rStringBuffer sb = new StringBuffer(\u0026#34;select * from book b,table_booktype bt where b.bookTypeId=bt.id\u0026#34;);\rif (!StringUtil.isEmpty(book.getBookname())) {\rsb.append(\u0026#34; and b.bookName like \u0026#39;%\u0026#34; + book.getBookname() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (!StringUtil.isEmpty(book.getAuthor())) {\rsb.append(\u0026#34; and b.author like \u0026#39;%\u0026#34; + book.getAuthor() + \u0026#34;%\u0026#39;\u0026#34;);\r}\rif (book.getBooktypeid() != null \u0026amp;\u0026amp; book.getBooktypeid() != -1) {\rsb.append(\u0026#34; and b.bookTypeId=\u0026#34; + book.getBooktypeid());\r}\rPreparedStatement psmt = conn.prepareStatement(sb.toString());\rreturn psmt.executeQuery();\r}\r  返回查询结果\nview包 视图层是利用的 swing 组件设计，但这个不是本项目的重点，因为 Java 的 swing 已经很少有人用了，可以直接使用 idea 中的JFormDesigner插件进行拖拉控件，使用时一定要注意将框架的布局类型设为null Layout，大小设为Design size\n我们只需设计按钮和表格的触发事件\n例如图书添加事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  private void button1ActionPerformed(ActionEvent e) {\rString bookName = this.booknameTXT.getText();\rString author = this.bookAuthorTXT.getText();\rString price = this.bookPriceTXT.getText();\rString bookDesc = this.bookDescTXT.getText();\rif (StringUtil.isEmpty(bookName)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书名称不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(author)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书作者不能为空\u0026#34;);\rreturn;\r}\rif (StringUtil.isEmpty(price)) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格不能为空\u0026#34;);\rreturn;\r}\rtry {\rfloat pricef = Float.parseFloat(price);\r} catch (NumberFormatException numberFormatException) {\rJOptionPane.showMessageDialog(null, \u0026#34;图书价格应为数字\u0026#34;);\rreturn;\r}\rString sex = \u0026#34;\u0026#34;;\rif (this.man.isSelected()) {\rsex = \u0026#34;男\u0026#34;;\r} else {\rsex = \u0026#34;女\u0026#34;;\r}\rBooktype booktype = (Booktype) this.booktypecb.getSelectedItem();\rassert booktype != null;\rint booktypeId = booktype.getId();\rBook book = new Book(bookName, author, sex, Float.parseFloat(price), booktypeId, bookDesc);\rConnection conn = null;\rtry {\rconn = dbUtil.getConnection();\rint addNum = BookDao.add(conn, book);\rif (addNum == 1) {\rJOptionPane.showMessageDialog(null, \u0026#34;添加成功\u0026#34;);\rresetValue();\r} else {\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r}\r} catch (Exception ex) {\rex.printStackTrace();\rJOptionPane.showMessageDialog(null, \u0026#34;添加失败\u0026#34;);\r} finally {\rtry {\rconn.close();\r} catch (SQLException ex) {\rex.printStackTrace();\r}\r}\r}\r  设计思想：\n 判断必需的输入框是否为空，以及类型是否一致 获取各输入框的数据 根据数据实例化对象 调用dao包中对应的方法进行操作  其他的删除，修改，查询的操作思想基本和添加的方法一样\n项目总结 项目中使用到了 Java 的 swing 技术，但是现在已经很少有人会用 Java 去写软件界面了，Java 不能像 C#那样拖拉控件设计界面，但是可以在 idea 中安装JFormDesigner插件实现 C#那样的效果了。\n MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。\n MVC 即围绕着数据库进行操作，本项目只是简单地实现了对数据库的增删改查，比较适合新手练习。\n","description":"推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql用到的知识：Java，MySQL工具：IDEA源码已上传至码云点击查看预览效果","id":6,"section":"posts","tags":["java","mysql"],"title":"简易的图书管理系统(Java+MySQL8.0)","uri":"https://eternidad33.github.io/zh/posts/%E7%AE%80%E6%98%93%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fjava+mysql8.0/"},{"content":"小程序基本架构 基本架构 利用 app.json文件对小程序进行全局配置\n利用同名.json文件对本页面窗口表现进行配置\n全局配置\n   属性 类型 必填 描述     pages string 是 页面路径列表   window Object 否 全局的默认窗口表现   tabBar Object 否 底部 tab 栏的表现   networkTimeout object 否 网络超时时间    Pages 配置\npages 用于指定小程序由哪些页面组成，每一项都对应一个页面的路径（含文件名）信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的.json，.js，.wxml，.wxss四个文件进行处理。数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。\nWindow 配置\n   属性 类型 描述     navigationBarBackground Color HexColor 导航栏背景颜色，如#000000   navigationBarTextStyle string 导航栏标题颜色，仅支持 black/ white   navigationBarTitleText string 导航栏标题文字内容   backgroundColor HexColor 窗口的背景色    tabBar 配置\n   属性 类型 描述     color HexColor tab 上的文字的默认颜色   selectedColor HexColor tab 上选中文字的颜色   backgroundColor HexColor tab 的背景色   borderStyle string tabbar 上边框的颜色，仅支持 black / white    list 配置\n   属性 类型 必填 说明     pagePath string 是 页面路径，必须在 pages 中先定义   text string 是 tab 上按钮文字   iconPath string 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px*81px，不支持网络图片   selectedIconPath string 否 选中时的图片路径    执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 13  //app.js\rApp({\r//\r onLaunch: function() {\rconsole.log(\u0026#34;【app.js】小程序初始化\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【app.js】小程序显示\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【app.js】小程序隐藏\u0026#34;);\r}\r});\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //index.js\rPage({\ronLoad: function() {\rconsole.log(\u0026#34;【index.js】onLoad页面加载\u0026#34;);\r},\ronShow: function() {\rconsole.log(\u0026#34;【index.js】onShow页面显示\u0026#34;);\r},\ronReady: function() {\rconsole.log(\u0026#34;【index.js】onRead页面渲染\u0026#34;);\r},\ronHide: function() {\rconsole.log(\u0026#34;【index.js】onHide页面隐藏\u0026#34;);\r},\ronUnload: function() {\rconsole.log(\u0026#34;【index.js】onUnLoad页面卸载\u0026#34;);\r}\r});\r  显示效果：\n小程序整个生命周期的执行基本顺序是：\n","description":"小程序基本架构 基本架构 利用 `app.json`文件对小程序进行全局配置 利用同名`.json`文件对本页面窗口表现进行配置","id":7,"section":"posts","tags":null,"title":"小程序基本架构","uri":"https://eternidad33.github.io/zh/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"},{"content":"作为一个学习计算机相关知识的人，如果不经常写博客，就容易把刚学到的知识忘记，写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用 Markdown，这样可以很好地使我们的博客页面变得更加美观，这篇文章介绍的就是一些使用的 Markdown 使用技巧。\n推荐工具：Typora，VScode(插件Markdown-preview-enhanced)\n段落格式 字体设置 Markdown 代码\n1  \u0026lt;font size=10 face=\u0026#34;隶书\u0026#34; color=#ff0000\u0026gt;红色 10 号隶书\u0026lt;/font\u0026gt;   运行结果：\n红色 10 号隶书\n粗斜体   用*表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  用下划线表示\nMarkdown 代码\n1 2 3  _斜体_ **粗体** **_粗斜体_**   显示结果为：\n斜体\n粗体\n粗斜体\n  下划线 Markdown 代码：\n1  \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt;   显示结果为：\n带下划线文本\n删除线 Markdown 代码：\n1  ~~删除线~~   显示结果为：\n删除线\n脚注格式 Markdown 代码：\n1 2  创建脚注格式是这样的 [^lorem]。 [^lorem]: Lorem ipsum dolor.   显示结果为：\n创建脚注格式是这样的 1。\n引用格式 嵌套结构 Markdown 代码：\n1 2 3 4 5  \u0026gt; 最外层 \u0026gt; \u0026gt; \u0026gt; 第一层嵌套 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; 第二层嵌套   显示结果：\n 最外层\n 第一层嵌套\n 第二层嵌套\n   引用中使用列表 Markdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026gt; 引用中使用列表 \u0026gt; \u0026gt; 1. 有序列表第一项 \u0026gt; 2. 有序列表第二项 \u0026gt; 3. 有序列表第三项 \u0026gt; \u0026gt; - 无序列表第一项 \u0026gt; - 无序列表第二项 \u0026gt; - 无序列表第三项   显示结果：\n 引用中使用列表\n 有序列表第一项 有序列表第二项 有序列表第三项   无序列表第一项 无序列表第二项 无序列表第三项   列表项中的引用 Markdown 代码：\n1 2 3 4 5  1. 第一项 \u0026gt; 第一行引用 \u0026gt; 第二行引用 2. 第二项 3. 第三项   显示结果：\n 第一项  第一行引用\n第二行引用\n  第二项 第三项  代码格式 行内代码 Markdown 代码：\n1  Python 代码`print(\u0026#39;helloworld\u0026#39;)`，控制台打印 helloworld   显示结果：\nPython 代码print('helloworld')，控制台打印 helloworld\n代码块  按 Tab 键或四个空格 用```包括起来，第一个后面加上代码语言，可以高亮显示  图片样式  直接放置图片\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png)   显示结果：\n 鼠标悬浮时，显示名称\nMarkdown 代码： 1  ![戴帽子的犬夜叉.png](https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png \u0026#34;戴帽子的犬夜叉\u0026#34;)   显示结果：\n 使用 img 标签定义图片的宽高\nMarkdown 代码： 1  \u0026lt;img src=\u0026#39;https://cdn.jsdelivr.net/gh/eternidad33/picbed@master/img/戴帽子的犬夜叉.png\u0026#39; width=50% height=50%\u0026gt;   显示结果：\n  链接样式   直接写\nMarkdown 代码：\n1  [百度一下，你就知道](https://www.baidu.com)   显示结果：\n百度一下，你就知道\n  链接用 a 作为网址变量,然后为变量赋值\nMarkdown 代码：\n1 2  [百度一下，你就知道][a] [a]: https://www.baidu.com   显示结果：\n百度一下，你就知道\n  表格样式 Markdown 代码：\n1 2 3 4  | 左对齐 | 居中对齐 | 右对齐 | | :----- | :------: | -----: | | 1 | 2 | 3 | | 4 | 5 | 6 |   显示结果：\n| 左对齐 | 居中对齐 | 右对齐 |\n| :\u0026mdash;\u0026ndash; | :\u0026mdash;\u0026mdash;: | \u0026mdash;\u0026ndash;: |\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n支持的 HTML 标签 Markdown 支持很多 HTML 标签,下面列举几个常用的标签\nMarkdown 代码：\n1 2 3 4 5 6 7 8 9  \u0026lt;kbd\u0026gt;Win\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Prtsc\u0026lt;/kbd\u0026gt; 快速截图 \u0026lt;em\u0026gt;强调\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;加强强调\u0026lt;/strong\u0026gt; \u0026lt;b\u0026gt;加粗\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;倾斜\u0026lt;/i\u0026gt; 上标如，3\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; 下标，如 CO\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; 换行符\u0026lt;br\u0026gt; 分割线\u0026lt;hr\u0026gt;   显示结果：\nWin+Prtsc 快速截图\n强调\n加强强调\n加粗\n倾斜\n上标如，32\n下标，如 CO2\n换行符\n分割线\n转义字符 以下这些符号前面加上反斜杠\\来帮助插入普通的符号：\n\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号  特殊符号    符号 代码     © \u0026amp;copy;   ™ \u0026amp;trade;   \u0026amp; \u0026amp;amp;   \u0026lt; \u0026amp;lt;   \u0026gt; \u0026amp;gt;   £ \u0026amp;pound;   ¥ \u0026amp;yen;   € \u0026amp;euro;   ® \u0026amp;reg;   ± \u0026amp;plusmn;   § \u0026amp;sect;   X² X\u0026amp;sup2;   Y³ Y\u0026amp;sup3;   ¾ \u0026amp;frac34;   « \u0026amp;laquo;   » \u0026amp;raquo;   37ºC 37\u0026amp;ordm;C     Lorem ipsum dolor. \u0026#x21a9;\u0026#xfe0e;\n   ","description":"写博客是一个很好的学习习惯，而写好博客也就是要学会熟练使用Markdown","id":8,"section":"posts","tags":["markdown"],"title":"小白必看，用Markdown代码写出好看的页面","uri":"https://eternidad33.github.io/zh/posts/%E5%B0%8F%E7%99%BD%E5%BF%85%E7%9C%8B%E7%94%A8markdown%E4%BB%A3%E7%A0%81%E5%86%99%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E9%A1%B5%E9%9D%A2/"},{"content":"开发工具 IDEA 从入门到爱不释手-课程笔记 1-1 代码生成 Generate  Alt+Insert,或者右键-Generate：生成 getter 或 setter  1-2 高效的代码编辑技能    快捷键 功能     Ctrl+Alt+L 格式化   Ctrl+D 复制光标所在行   Alt+Shift+上/下 移动所在行或所选行    1-3 Demo 项目介绍 分层结构\n Config：所有的配置 Controller：请求入口 Service：逻辑层 Mapper：持久层 Domain(Po)：表映射实体 Dto：数据传输对象  1-4 git 更多操作 顶部添加 git 提交选项\n1-5 快速查找和替换    快捷键 功能     Ctrl+F 查找   Ctrl+R 替换   Ctrl+Shift+F 全局查找   Ctrl+Shift+R 全局替换   Ctrl+Shift+N 查找文件   Ctrl+Shift+A 查找所有的菜单或操作   双击 shift 万能查找    2-1 代码模板  psvm：生成主函数 sout：System.out.println(); fori：for 循环 fore：foreach 循环 Live Templates postfix：先打变量或表达式，再打快捷键  2-2 代码重构 Refactor    快捷键 功能     Shift+F6 代码重命名   Ctrl+Alt+V 自动生成返回值   Alt+Delete 安全删除   F5 文件复制粘贴     一个方法只负责实现一个功能  2-3 快速跳转    快捷键 功能     Ctrl+左/右 跳过一个单词   Ctrl+G 快速跳转到指定行   Alt+左/右 左右切换 Tabs   Ctrl+E 查看最近浏览过的文件    3-1 更多实用技巧  Ctrl+Alt+Shift+J ：选中文件中所有和被选中的代码一样的代码  ","description":"推荐几个比较好用的插件 图片背景`Background Image Plus` 彩虹括号`Rainbow Brackets` 主题`Material Theme ul` 记录编码时长`wakatime` 统计项目代码行数`Statistic`","id":9,"section":"posts","tags":["idea"],"title":"idea使用技巧总结","uri":"https://eternidad33.github.io/zh/posts/idea%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"content":"m10c 主题配置 主题地址：GitHub 仓库地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  title = \u0026#34;Vigilr的博客\u0026#34;\r[params]\rdescription = \u0026#34;宁为玉碎，不为瓦全\u0026#34;\ravatar = \u0026#34;avatar.jpg\u0026#34;\r[[params.social]]\rname = \u0026#34;github\u0026#34;\rurl = \u0026#34;https://github.com/eternidad33\u0026#34;\r[[params.social]]\rname = \u0026#34;mail\u0026#34;\rurl = \u0026#34;mailto:3496655347@qq.com\u0026#34;\r[[params.social]]\rname = \u0026#34;link\u0026#34;\rurl = \u0026#34;https://blog.csdn.net/qq_42907802\u0026#34;\r  主题仓库要下载到站点目录/themes下\n文章目录为：站点目录/content/posts\n头像的路径：站点目录/static/avatar.jpg\n只是简单地设计了几个链接，链接的图标在主题目录/data/m10c/icons.json文件中定义\n博客启动：hugo server -t hugo-theme-m10c -D\n浏览器访问:http://localhost:1313/\n至此博客启动成功\n","description":"m10c是一款比较简洁的主题，而且容易配置","id":10,"section":"posts","tags":["hugo","theme"],"title":"m10c主题配置","uri":"https://eternidad33.github.io/zh/posts/m10c%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"content":"Hugo 博客搭建 本地部署 推荐视频：手把手教你从 0 开始搭建自己的个人博客 |第二种姿势 | hugo\n  下载 Hugo，下载地址：GitHub\n  配置环境变量\n  创建自己的站点文件夹hugo new site myHugoSite\n生成的目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  PS C:\\Users\\Administrator\\Desktop\\myHogoSite\u0026gt; tree /f\r文件夹 PATH 列表\r卷序列号为 2A8A-01A5\rC:.\r│ config.toml\r│\r├─archetypes\r│ default.md\r │\r├─content\r├─data\r├─layouts\r├─static\r└─themes\r    新建文章\n在 content 目录下生成博客hugo new 我的第一篇博客.md\n在 content/posts 目录下生成博客hugo new posts/我的第二篇博客.md\n  下载m10c 主题并配置\n  部署到 GitHub  创建远程仓库,仓库名必须为用户名.github.io 生成 public 文件夹hugo -t 主题名 -b https://用户名.github.io -D 然后就是一系列 git 操作 进入 public，初始化 git 仓库 添加到暂存区 提交仓库 连接远程仓库 推送到远程仓库  不清楚的命令可以通过hugo help查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  $ hugo help\rhugo is the main command, used to build your Hugo site.\rHugo is a Fast and Flexible Static Site Generator\rbuilt with love by spf13 and friends in Go.\rComplete documentation is available at http://gohugo.io/.\rUsage:\rhugo [flags]\rhugo [command]\rAvailable Commands:\rconfig Print the site configuration\rconvert Convert your content to different formats\rdeploy Deploy your site to a Cloud provider.\renv Print Hugo version and environment info\rgen A collection of several useful generators.\rhelp Help about any command\rimport Import your site from others.\rlist Listing out various types of content\rmod Various Hugo Modules helpers.\rnew Create new content for your site\rserver A high performance webserver\rversion Print the version number of Hugo\rFlags:\r-b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/\r--templateMetrics display metrics about template executions\r--templateMetricsHints calculate some improvement hints when combined with --templateMetrics\r-t, --theme strings themes to use (located in /themes/THEMENAME/)\r--themesDir string filesystem path to themes directory\r--trace file write trace to file (not useful in general)\r-v, --verbose verbose output\r--verboseLog verbose logging\r-w, --watch watch filesystem for changes and recreate as needed\rAdditional help topics:\rhugo check Contains some verification checks\rUse \u0026#34;hugo [command] --help\u0026#34; for more information about a command.\r  ","description":"本文介绍如何搭建Hugo个人博客","id":11,"section":"posts","tags":["hugo"],"title":"Hugo博客搭建","uri":"https://eternidad33.github.io/zh/posts/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"content":"码云上搭建 Hexo 静态博客   下载 Node.js\n  下载并配置 Git\n  安装 Hexo\n 设置 cnpm，设置为国内的淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 Hexo， cnpm install -g hexo-cli 查看是否安装成功 hexo -v    建立博客文件夹\n  执行hexo init\n  Hexo 常用的几个命令\n hexo s运行 Hexo hexo n 文件名.md创建博客文章，也可以直接在\\source\\_posts文件夹中创建 hexo g生成博客文件 hexo clean清理缓存 hexo d推送到远端服务器    创建远程仓库，仓库名要与自己的用户名相同\n  安装 Git 依赖，cnpm install --save hexo-deployer-git\n  修改配置文件\n1 2 3 4  deploy:type:gitrepo:https://gitee.com/eternidad33/eternidad33.gitbranch:master    开启Gitee Pages服务\n  推荐 B 站 Up 主：CodeSheep\n参考的是他的视频手把手教你从 0 开始搭建自己的个人博客 |无坑版视频教程| hexo\n","description":"","id":12,"section":"posts","tags":["hexo"],"title":"码云上搭建Hexo博客","uri":"https://eternidad33.github.io/zh/posts/%E7%A0%81%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"content":"学习类 中国大学 MOOC（涵盖各个行业的课程）\n慕课网（计算机互联网行业学习的网站）\n哔哩哔哩（各个领域的 UP 主）\nw3cSchool（学习编程）\n廖雪峰的官方网站（学习编程）\n菜鸟教程（学习编程）\n实验楼（学习编程）\n数据酷客（学习 Python，大数据）\n阿里云大学(提供编程各个方向的学习路线)\nhow2j（学习 Java）\n素材类 微信读书（只要有无限卡，全场免费读）\n鸠摩搜书（基本上想搜的书都能搜到）\nGreasy Fork（配合油猴插件下载脚本）\nMSDN，我告诉你（免费下载纯净的 Windows 系统镜像）\n我的 MSDN（免费下载纯净的 Windows 系统镜像）\n电脑壁纸（免费好看的桌面壁纸）\n阿里巴巴矢量图标库（下载各种格式的图标）\n第一 PPT（免费 PPT 模板）\n优品 PPT（免费 PPT 模板）\n站长素材（下载图标，字体，PSD，矢量图，jQuery 等）\n编程相关 ProcessOn（在线作图）\nGitHub（ 世界上最大的软件项目的托管平台 ）\n码云（相当于国内的 GitHub）\n牛客（刷题）\nLeetCode（刷题）\n洛谷（刷题）\nwakatime（记录编码时间）\nSM.MS（图床工具）\nShields.IO（生成展示在 Markdown 文档中的徽章）\nSimple Icons（下载 SVG 图标）\n","description":"大学期间收集的网站，主要分为学习类，素材类，和编程相关","id":13,"section":"posts","tags":null,"title":"网站推荐","uri":"https://eternidad33.github.io/zh/posts/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"},{"content":"1. Alibaba Cloud Tookit  Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；并且还内置了 Arthas 诊断、Dubbo 工具、Terminal 终端、文件上传、函数计算 和 MySQL 执行器等工具。（产品官网：https://www.aliyun.com/product/cloudtoolkit）\n 通过该插件就可以直接在 VScode 上直接控制自己的远程服务器了，可以很方便地上传本机的文件到服务器上。\n需要配置的就是服务器的 ip,AccessKeyId,AccessKeySecret,用户名和密码\n2. Auto Import  Automatically finds, parses and provides code actions and code completion for all available imports. Works with Typescript and TSX.\n 该插件用于在编写代码时，自动导入文件中忘记写的需要的包，配置里的钩根据自己的需求打就行了\n3. Auto Rename Tag  Automatically rename paired HTML/XML tag, same as Visual Studio IDE does.\n 顾名思义就是 html，xml 的起始标签改变时，结束标签也会跟随改变\n4. Code Runner  Run code snippet or code file for multiple languages: C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, and custom command\n 如果用 VScode 编写 Java 可以用该插件编译，调试，和运行，其他语言可能也行，配置信息根据自身需求设置\n 如果是编写 Java，VScode 会提示安装许多 Java 的插件，例如：Debugger for Java，Java Dependency Viewer，Java Extension Pack，Java Test Runner，Language support for Java ™ for Visual Studio Code，Maven for Java，自动安装上即可\n 5. Color Info 该插件是在编写 CSS 需要设置颜色时用的，可以快速从调色板中选取颜色，设置透明度等。即装即用，无需配置。\n6. GitLens — Git supercharged  GitLens supercharges the Git capabilities built into Visual Studio Code. It helps you to visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more.\n 这个 Git 插件配合 VScode 自带的源代码管理工具，可以很好的管理自己的本地仓库和远程仓库。\n这个需要先把快捷键配置上,将 commit 的快捷键设置为 Alt+/\n7. Indent-Rainbow 不同缩进会显示不同的颜色，编写 Python 必装的插件，因为 Python 对缩进的要求很严格，即装即用，无需配置\n显示效果：\n8. LeetCode 刷 LeetCode 上的题必备的插件，可以查看自己刷过的题，支持查看，测试，提交，看自己的运行结果等\n配置时先把 user-account 设为 leetcode-cn，然后登陆自己的账户即可，然后配置上自己习惯用的语言\n9. wakatime 记录自己的编码时间，在wakatime 官网上直接查看自己每天的编码时间，免费版最多可以保存最近 14 天的。\n如果使用其他的 IDE 也可以安装该插件，然后在官网上查看自己编写各种语言的时间，和使用各个 IDE 的时间，每周会给自己邮箱发一个周报\n只需配置上自己在官网上注册的账号的 api key 即可。\n10. PicGo 图床工具，支持的图床有 qiniu, tcyun, upyun, github, aliyun, imgur 和 SM.MS，默认是 SM.MS。但是 SM.MS 经常上传失败，我也不太清楚怎么解决。介绍一下 GitHub 图床的配置\n PicBed 设为GitHub branch 设为master Custom Url：https://cdn.jsdelivr.net/gh/user/repo@master采用 cdn 访问，因为国内访问 GitHub 相对较慢  gh表示 github user填写自己的用户名 repo填写自己图床的仓库 例如https://cdn.jsdelivr.net/gh/eternidad33/picbed@master   Path:images/图片上传到仓库中的 images 文件夹中 Repo：user/repo填写自己的仓库即可 Token：自己在 GitHub 上创建一个拥有 repo 权限的 Token，填上即可  上传本机图片的快捷键是 Ctrl+Alt+E\n11. Markdown Preview Enhanced with litvis 全面支持 Markdown 的预览，默认的 Markdown 预览显示的不太好看，[Toc]生成的目录是显示不出的，还有一些 HTML 的标签支持的也不是很好，而该插件就可以很好地显示，同时还可以将 Markdown 文件导出为 HTML，PDF 等格式的文件\nWallpaper 每日壁纸分享 标题：Fantasy World\n创作者：Mrs.Venus\n","description":"Cloud Toolkit 是免费的本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、Kubernetes 和 小程序云 等）；","id":14,"section":"posts","tags":null,"title":"VSCode插件推荐","uri":"https://eternidad33.github.io/zh/posts/vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"content":"个人主页 代码：码云，Github\n博客：简书，CSDN，博客园\n刷题：牛客，LeetCode\n社交：今日头条，哔哩哔哩，steam，知乎，百度贴吧，微博\n欢迎大家关注我的动态\n","description":"个人动态","id":15,"section":"","tags":null,"title":"关于","uri":"https://eternidad33.github.io/zh/about/"}]